\documentclass{cern-art} % Specifies the document style.
%
\usepackage{hyperref}
\usepackage{xspace}

\usepackage{vmargin,times,graphicx,amsmath,amssymb,color} % ,draftcopy use draftcopy for experiments
\usepackage{verbatim} % to allow for verbatim and comment
\usepackage{here}
\usepackage{wrapfig}
\usepackage{fancyref}
\usepackage{listings}

\usepackage{color}
\definecolor{grey}{rgb}{0.4,0.4,0.4}
\definecolor{darkgreen}{rgb}{0,0.4,0}
\definecolor{comment}{rgb}{0.1,0.50,0.56}
\definecolor{strings}{rgb}{0.25,0.44,0.63}

% programming language
\lstset{ basicstyle=\footnotesize\ttfamily, % Standardschrift
         %numbers=left,               % Line numbers..
         numberstyle=\color{grey}\tiny,          % Numbers style..
         %stepnumber=2,               % Distance between line numbers
         %numbersep=5pt,              % Distance from line number to text
         tabsize=2,                  % Tabs size
         extendedchars=true,         %
         breaklines=true,            % Break long lines
         keywordstyle=\color{darkgreen}\bfseries,
         stringstyle=\color{strings}\ttfamily, % String color
         commentstyle=\it\color{comment}\ttfamily,
%          showspaces=false,           % Show spaces
%          showtabs=false,             % Show tabs
         xleftmargin=0pt,
         framexleftmargin=17pt,
         framexrightmargin=5pt,
         framexbottommargin=4pt,
         showstringspaces=false
}

\everymath{\displaystyle}

\lstset{language=Fortran}
\lstset{keywordstyle=\color{blue}\bfseries}
\lstset{numbers=left,stepnumber=2}
\lstset{commentstyle=\color{red}\bfseries}

\setmarginsrb{15mm}{8mm}{15mm}{10mm}{12pt}{10mm}{0pt}{10mm}

% shortcut
\renewcommand{\L}[1]{\lstinline[firstnumber=last]{#1}}
\newcommand{\T}[1]{{\tt #1}}
\newcommand{\madx}{\mbox{MAD-X}\xspace}
\newcommand{\madeight}{\mbox{MAD8}\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}

\PSLogo{fig/cern-logo.pdf}
\DocReference{CERN-ACC-NOTE-2014-XXXX}

\Date{April 2014}
% \RevisionDate{April 15, 2014}

\Author{L. Deniau and A. Latina}
\Institute{CERN -- BE/ABP}
\Email{\{laurent.deniau, andrea.latina\}@cern.ch}

\Title{Ndiff Reference Manual}
\Title{MAD-X Technical Notes on Twiss Module}

\Keywords{\madx, beam dynamics, thick tracking, optical functions.}
%\Distribution{ABP group}

\Maketitle

\Summary{%
	This technical note describes in details the transport maps used by the Twiss module of \madx, including the commented code. It also proposes some alternatives formulations for potential future implementations.
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage
\tableofcontents

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\cleardoublepage
\section{Motivation}

The implementation of the Twiss module was inherited from \madeight and adapted to the LHC studies during the crash program for the development of its successor \madx. The root of this code goes back into the 80's and some approximations and adaptations were never documented. Hence, the purpose of this work is to recover the physics of this module using reverse engineer, and to document the approximations and assumptions made by the code. It will be also the opportunity to clarify some features and inconsistencies, and potentially correct some known bugs.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Bending magnets}

\madx does not support the so called ``true \T{RBEND}'' element. This kind of magnet is internally represented as a sector bend (i.e. \T{SBEND}) with the pole faces made parallel by setting the pole face angles to $\T{e1}=\T{e2}=\alpha/2$, where $\alpha$ is the \T{SBEND} angle.


\subsection{The routine \L{tmbend}}
\subsubsection{Preamble}
Declarations and preamble:
\begin{lstlisting}[firstnumber=auto]
SUBROUTINE tmbend(ftrk,orbit,fmap,el,ek,re,te)

  use twtrrfi
  use twisslfi
  use twiss_elpfi
  implicit none

  !----------------------------------------------------------------------*
  !     Purpose:                                                         *
  !     TRANSPORT map for sector bending magnets                         *
  !     Input:                                                           *
  !     ftrk      (logical) if true, track orbit.                        *
  !     Input/output:                                                    *
  !     orbit(6)  (double)  closed orbit.                                *
  !     Output:                                                          *
  !     fmap      (logical) if true, element has a map.                  *
  !     el        (double)  element length.                              *
  !     ek(6)     (double)  kick due to element.                         *
  !     re(6,6)   (double)  transfer matrix.                             *
  !     te(6,6,6) (double)  second-order terms.                          *
  !----------------------------------------------------------------------*
  logical ftrk,cplxy,dorad
  integer nd,n_ferr,node_fd_errors,code
  double precision orbit(6),f_errors(0:maxferr),ek(6),re(6,6),           &
       te(6,6,6),rw(6,6),tw(6,6,6),x,y,deltap,field(2,0:maxmul),fintx,   &
       el,tilt,e1,e2,sk1,sk2,h1,h2,hgap,fint,sks,an,h,dh,corr,ek0(6),ct, &
       st,hx,hy,rfac,arad,gamma,pt,rhoinv,blen,node_value,get_value,bvk, &
       el0,orbit0(6)
  double precision orbit00(6),ek00(6),re00(6,6),te00(6,6,6)
  integer, external :: el_par_vector ! function from the C core
  integer elpar_vl
\end{lstlisting}
{\em The following piece of code has been moved up and rewritten for clarity}. If the element has zero length it simply jumps to the end (physically correct?).
\begin{lstlisting}[firstnumber=last]
  !---- Test for non-zero length.
  if (el.eq.0) then return
\end{lstlisting}
The following statements initializes the matrix \L{rw} to the identity, and the tensor \L{tw} and the vector \L{ek0} to zero.
\begin{lstlisting}[firstnumber=last]
  !---- Initialize.
  ct=0
  st=0
  deltap=0
  call dzero(ek0,6)
  call m66one(rw)
  call dzero(tw,216)
  call dzero(f_errors,maxferr+1)
\end{lstlisting}
The next code reads the probe and the magnet parameters from the command line and some dynamic variables. It also converts \L{tkicker} (39) to \L{kicker} (15), and \L{placeholder} (38) to \L{instrument} (24).
\begin{lstlisting}[firstnumber=last]
    code = node_value('mad8_type ') ! function from the C core
    if(code.eq.39) code=15
    if(code.eq.38) code=24

     n_ferr   = node_fd_errors(f_errors)        ! get field errors
     elpar_vl = el_par_vector(b_k3s, g_elpar) ! get strengths up to k3s
     bvk      = node_value('other_bv ')
     arad     = get_value('probe ','arad ')
     deltap   = get_value('probe ','deltap ')
     gamma    = get_value('probe ','gamma ')
     dorad    = get_value('probe ','radiate ') .ne. 0
     an       = bvk * g_elpar(b_angle)              ! sbend angle
     tilt     = g_elpar(b_tilt)                   ! sbend tilt
     e1       = g_elpar(b_e1)                       ! sbend entry pole face angle
     e2       = g_elpar(b_e2)                       ! sbend exit  pole face angle
     sk1      = g_elpar(b_k1)
     sk2      = g_elpar(b_k2)
     h1       = g_elpar(b_h1)
     h2       = g_elpar(b_h2)
     hgap     = g_elpar(b_hgap)
     fint     = g_elpar(b_fint)
     fintx    = g_elpar(b_fintx)
     sks      = g_elpar(b_k1s)

     ! rbend treated as a sbend with parallel pole faces
     if(code.eq.2) then
        e1 = e1 + an / 2
        e2 = e2 + an / 2
     endif

     h = an / el
\end{lstlisting}
TODO \L{h} is $h=1/\rho$. I guess the following \L{dh} is how much does the inverse of the bending radius change for a particle with momentum difference \L{deltap} is w.r.t. the nominal value. The first branch of this \L{if} takes into account the field errors, also.
  \begin{lstlisting}[firstnumber=last]
     !---- Apply field errors and change coefficients using DELTAP.
     if (n_ferr .gt. 0) then
        nd = n_ferr
        call dzero(field,nd)
        call dcopy(f_errors,field,n_ferr)
        dh = (- h * deltap + bvk * field(1,0) / el) / (1 + deltap)
        sk1 = (sk1 + field(1,1) / el) / (1 + deltap)
        sk2 = (sk2 + field(1,2) / el) / (1 + deltap)
        sks = (sks + field(2,1) / el) / (1 + deltap)
     else
        dh = - h * deltap / (1 + deltap)
        sk1 = sk1 / (1 + deltap)
        sk2 = sk2 / (1 + deltap)
        sks = sks / (1 + deltap)
     endif
  \end{lstlisting}
Applies \L{bvk}-flag.
 \begin{lstlisting}[firstnumber=last]
     sk1 = bvk * sk1
     sk2 = bvk * sk2
     sks = bvk * sks
  \end{lstlisting}
  if the flags \L{(ftrk .and. dorad)} are set, then it applies half radiation at the entrance. Also, it applies the tilt rotation.
 \begin{lstlisting}[firstnumber=last]
     !---- Half radiation effects at entrance.
     if (ftrk .and. dorad) then
        ct = cos(tilt)
        st = sin(tilt)
        x =   orbit(1) * ct + orbit(3) * st
        y = - orbit(1) * st + orbit(3) * ct
        hx = h + dh + sk1*(x - h*y**2/2) + sks*y +                  &
             sk2*(x**2 - y**2)/2
        hy = sks * x - sk1*y - sk2*x*y
        rfac = (arad * gamma**3 * el / 3)                         &
             * (hx**2 + hy**2) * (1 + h*x) * (1 - tan(e1)*x)
        pt = orbit(6)
        orbit(2) = orbit(2) - rfac * (1 + pt) * orbit(2)
        orbit(4) = orbit(4) - rfac * (1 + pt) * orbit(4)
        orbit(6) = orbit(6) - rfac * (1 + pt) ** 2
     endif
  \end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Option ``centre''}
If \L{centre} option
   \begin{lstlisting}[firstnumber=last]
     !---- Body of the dipole.
     !---- centre option
     if(centre_cptk.or.centre_bttk) then
        call dcopy(orbit,orbit00,6)
        call dcopy(ek,ek00,6)
        call dcopy(re,re00,36)
        call dcopy(te,te00,216)
  \end{lstlisting}
It halves the length of the element.
   \begin{lstlisting}[firstnumber=last]
        el0=el/2
\end{lstlisting}
It stores the element's \textit{kick}, \textit{transfer matrix}, and \textit{tensor} for such a halved sector bend in \L{ek,re,te}:
\begin{lstlisting}[firstnumber=last]
        call tmsect(.true.,el0,h,dh,sk1,sk2,ek,re,te)
\end{lstlisting}
It stores the $R$ and $T$ for the fringing field in \L{rw} and \L{tw} respectively; then it concatenates the transport maps in such that the fringe fields precede the half-bending magnet. The resulting transport map is stored in   \L{ek},  \L{re}, and \L{te}:
\begin{lstlisting}[firstnumber=last]
        !---- Fringe fields.
        corr = (h + h) * hgap * fint
        call tmfrng(.true.,h,sk1,e1,h1,1,corr,rw,tw)
        call tmcat1(.true.,ek,re,te,ek0,rw,tw,ek,re,te)
\end{lstlisting}
It rotates the map:
\begin{lstlisting}[firstnumber=last]
        !---- Apply tilt.
        if (tilt .ne. 0) then
           call tmtilt(.true.,tilt,ek,re,te)
           cplxy = .true.
        endif
\end{lstlisting}
If the flag \L{ftrk} is set, tracks the orbit through such a halved bend then zeroes \L{ek},  \L{re}, and \L{te}:
\begin{lstlisting}[firstnumber=last]
        !---- Track orbit.
        call dcopy(orbit,orbit0,6)
        if (ftrk) call tmtrak(ek,re,te,orbit0,orbit0)
        if(centre_cptk) call twcptk(re,orbit0)
        if(centre_bttk) call twbttk(re,te)
        call dcopy(orbit00,orbit,6)
        call dcopy(ek00,ek,6)
        call dcopy(re00,re,36)
        call dcopy(te00,te,216)
     endif
     !---- End
  \end{lstlisting}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\subsubsection{Body of the dipole}
  It fills  \L{ek},  \L{re}, and \L{te} with kick, matrix and tensor for the sector bend. Then fills  \L{rw}, and \L{tw} with the fringing fields and combines the maps such that the body of the bend is sandwiched between the two fringing fields. Notice that if the option ``centre'' is selected, the initial fringing field has  already been applied, thing which not seems to be correct.  
   \begin{lstlisting}[firstnumber=last]
     call tmsect(.true.,el,h,dh,sk1,sk2,ek,re,te)

     !---- Fringe fields.
     corr = (h + h) * hgap * fint
     call tmfrng(.true.,h,sk1,e1,h1,1,corr,rw,tw)
     call tmcat1(.true.,ek,re,te,ek0,rw,tw,ek,re,te)
     !---- Tor: use FINTX if set
     if (fintx .ge. 0) then
        corr = (h + h) * hgap * fintx
     else
        corr = (h + h) * hgap * fint
     endif
     call tmfrng(.true.,h,sk1,e2,h2,-1,corr,rw,tw)
     call tmcat1(.true.,ek0,rw,tw,ek,re,te,ek,re,te)
\end{lstlisting}
It rotates the map:
\begin{lstlisting}[firstnumber=last]
     !---- Apply tilt.
     if (tilt .ne. 0) then
        call tmtilt(.true.,tilt,ek,re,te)
        cplxy = .true.
     endif
\end{lstlisting}
Tracks the orbit:
\begin{lstlisting}[firstnumber=last]
     !---- Track orbit.
     if (ftrk) then
        call tmtrak(ek,re,te,orbit,orbit)
\end{lstlisting}
Radiation effects at the exit:
\begin{lstlisting}[firstnumber=last]
        !---- Half radiation effects at exit.
        if (ftrk .and. dorad) then
           x =   orbit(1) * ct + orbit(3) * st
           y = - orbit(1) * st + orbit(3) * ct
           hx = h + dh + sk1*(x - h*y**2/2) + sks*y +                &
                sk2*(x**2 - y**2)/2
           hy = sks * x - sk1*y - sk2*x*y
           rfac = (arad * gamma**3 * el / 3)                       &
                * (hx**2 + hy**2) * (1 + h*x) * (1 - tan(e2)*x)
           pt = orbit(6)
           orbit(2) = orbit(2) - rfac * (1 + pt) * orbit(2)
           orbit(4) = orbit(4) - rfac * (1 + pt) * orbit(4)
           orbit(6) = orbit(6) - rfac * (1 + pt) ** 2
        endif
     endif
  endif ! if (fmap)

  !---- Tor: set parameters for sychrotron integral calculations
  ! LD: useless code?
  rhoinv = h
  blen = el

end SUBROUTINE tmbend
\end{lstlisting}

\subsection{The routine {tmsect}}
\L{tmsect(fsec,el,h,dh,sk1,sk2,ek,re,te)} fills \L{ek,re,te} with kick, matrix and tensor for this sector bend.

\section{Lattice parameters tracking}
\subsection{Coupled tracking}
Following the MAD-8 physics guide (the implementation, and actually also the code, are exactly the same), we understand the initialisation of the tracking of the linear coupled parameters. Given one-turn transfer matrix,
$$M=\left(\begin{array}[t]{cc}
A & B\\
C & D
\end{array}\right),$$
$M$ is diagonalized via a ``sympletic rotation'' $$\mathcal{R}=\left(\begin{array}[t]{cc}
I\,\cos\phi & \bar{R}\,\sin\phi\\
-R\,\sin\phi & I\,\cos\phi
\end{array}\right)$$
to
$$\mathcal{R}M\mathcal{R}^{-1}=\left(\begin{array}[t]{cc}
A^{\prime} & 0\\
0 & D^{\prime}
\end{array}\right)$$
with
$$R=\left(\begin{array}[t]{cc}
a & b\\
c & d
\end{array}\right),\qquad\left|R\right|=\left|\begin{array}[t]{cc}
a & b\\
c & d
\end{array}\right|=1,\qquad\bar{R}=\left(\begin{array}[t]{cc}
d & -b\\
-c & a
\end{array}\right)
$$
and
$$\begin{aligned}A^{\prime} & =A-B\, R,\\
D^{\prime} & =D+\bar{R}\, C.
\end{aligned}$$
Like in the code, $A^{\prime}$ and $D^{\prime}$ will simply be called $A$ and $D$. $R$ is defined as
\begin{eqnarray*}
\text{aux} & = & C+\bar{B}=\left(\begin{array}[t]{cc}
M_{31}+M_{24} & M_{32}-M_{14}\\
M_{41}-M_{23} & M_{42}-M_{13}
\end{array}\right)\\
\text{dtr} & = & \frac{1}{2}\left(M_{11}+M_{22}-M_{33}-M_{44}\right)=\frac{1}{2}\left(\mathrm{Tr}\, A-\mathrm{Tr}\, D\right)\\
R & = & \frac{\text{aux}}{\text{dtr}+\mathrm{sign}\left(\mathrm{det}\,\left(\text{aux}\right)\right)\sqrt{\mathrm{det}\,\left(\text{aux}\right)+\text{dtr}^{2}}}
\end{eqnarray*}
\begin{description}
\item[twcpin] initialises the coupled tracking:
\\\begin{enumerate}
\item \L{rmat0} is set to be equal to $R$;
\item computes $A$ and $D$, and the initial twiss parameters for these matrices:
\[
\begin{array}{ccl}
\text{if} & \left|\frac{1}{2}\mathrm{Tr}\left(A\right)\right|<1\\
 & \mathrm{sinmux}=\sin\mu_{x} & =\mathrm{sign}\left(A_{12}\right)\sqrt{-A_{12}\cdot A_{21}-\frac{1}{4}\left(A_{11}-A_{22}\right)^{2}}\\
 & \beta_{0,x} & =\frac{A_{12}}{\sin\mu_{x}}\\
 & \alpha_{0,x} & =\frac{A_{11}-A_{22}}{2\sin\mu_{x}}\\
\text{else}\\
 & \beta_{0,x} & =0\\
 & \alpha_{0,x} & =0\\
\text{endif}
\end{array}
\]
and the same for $y$, with $D$ instead of $A$;
\end{enumerate}
\item[twcptk] tracks the coupled lattice functions, given the element transfer matrix $M$:
\begin{enumerate}
\item tracks the dispersion $$d \leftarrow M\cdot d$$
\item saying, 
$$M\equiv\left(\begin{array}[t]{cc}
A & D\\
B & C
\end{array}\right),$$
creates the auxiliary matrices
\[
\begin{aligned}A & =A-D\cdot R\\
B & =B-C\cdot R\\
C & =C-\bar{R}\cdot B
\end{aligned}
\]
in order to track $R$ matrix (\L{rmat}):
\[
R\leftarrow-\frac{B\cdot\bar{A}}{\left|A\right|}
\]
\item given $A$ and $C$, that in this function are such that
\[\mathcal{R}M\mathcal{R}^{-1}=\left(\begin{array}[t]{cc}
A & 0\\
0 & C
\end{array} \right) \]

the twiss parameters are tracked:
\end{enumerate}
\end{description}

\subsubsection*{The subroutine \L{twcptk}}
\begin{lstlisting}[firstnumber=1]
SUBROUTINE twcptk(re,orbit)
  use twiss0fi
  use twisslfi
  use twisscfi
  use twissotmfi
  implicit none

  !----------------------------------------------------------------------*
  !     Purpose:                                                         *
  !     Track coupled lattice functions.                                 *
  !     Input:                                                           *
  !     re(6,6)  (double)   transfer matrix of element.                  *
  !     rt(6,6)  (double)   one turn transfer matrix.                    *
  !     orbit(6) (double)   closed orbit                                 *
  !----------------------------------------------------------------------*
  integer i,i1,i2,j,inval,get_option
  double precision re(6,6),orbit(6),rw0(6,6),rwi(6,6),rc(6,6),      &
       rmat0(2,2),a(2,2),adet,b(2,2),c(2,2),dt(6),tempa,tempb,alfx0,     &
       alfy0,betx0,bety0,amux0,amuy0,zero,one
  parameter(zero=0d0,one=1d0)

  !initialize
  bety0=zero
  betx0=zero
  amux0=zero
  amuy0=zero
  alfy0=zero
  alfx0=zero
\end{lstlisting}

\[
\begin{aligned}\beta_{x,0} & =0\\
\beta_{y,0} & =0\\
\alpha_{x,0} & =0\\
\alpha_{y,0} & =0\\
\mu_{x,0} & =0\\
\mu_{y,0} & =0
\end{aligned}
\]

\begin{lstlisting}[firstnumber=last]

  !---- Dispersion.
  call dzero(dt,6)
  do i = 1, 6
     do j = 1, 6
        dt(i) = dt(i) + re(i,j) * disp(j)
     enddo
  enddo
\end{lstlisting}

\[
\vec{\text{dt}}=\mathbf{re}\cdot\vec{\text{disp}}
\]

\begin{lstlisting}[firstnumber=last]

  if(.not.centre.or.centre_cptk) then
     opt_fun(15)=dt(1)  // disp_x
     opt_fun(16)=dt(2)  // disp_xp
     opt_fun(17)=dt(3)  // disp_y
     opt_fun(18)=dt(4)  // disp_yp
  endif
  if(centre_cptk) then
     alfx0=alfx
     alfy0=alfy
     betx0=betx
     bety0=bety
     amux0=amux
     amuy0=amuy
     call dcopy(rmat,rmat0,4)
     if(rmatrix) call dcopy(rw,rw0,36)
\end{lstlisting}

\[
\begin{aligned}\beta_{x,0} & =\beta_{x}\\
\beta_{y,0} & =\beta_{y}\\
\alpha_{x,0} & =\alpha_{x}\\
\alpha_{y,0} & =\alpha_{y}\\
\mu_{x,0} & =\mu_{x}\\
\mu_{y,0} & =\mu_{y}
\end{aligned}
\]
\[
\text{rmat0}=\text{rmat}
\]

\begin{lstlisting}[firstnumber=last]

  else
     call dcopy(dt,disp,6)
     disp(5) = zero
     disp(6) = one
\end{lstlisting}

\[
\text{disp}=\left(\begin{array}[t]{c}
\text{dt(1)}\\
\text{dt(2)}\\
\text{dt(3)}\\
\text{dt(4)}\\
0\\
1
\end{array}\right)
\]

\begin{lstlisting}[firstnumber=last]

  endif

  !---- Auxiliary matrices.
  a(1,1) = re(1,1) - (re(1,3) * rmat(1,1) + re(1,4) * rmat(2,1))
  a(1,2) = re(1,2) - (re(1,3) * rmat(1,2) + re(1,4) * rmat(2,2))
  a(2,1) = re(2,1) - (re(2,3) * rmat(1,1) + re(2,4) * rmat(2,1))
  a(2,2) = re(2,2) - (re(2,3) * rmat(1,2) + re(2,4) * rmat(2,2))
\end{lstlisting}

\[
\text{re}=\left(\begin{array}[t]{cc}
\text{re}_{a} & \text{re}_{d}\\
\text{re}_{b} & \text{re}_{c}
\end{array}\right)\quad\text{rmat}=\left(\begin{array}[t]{cc}
\text{rmat}_{a} & \text{rmat}_{d}\\
\text{rmat}_{b} & \text{rmat}_{c}
\end{array}\right)
\]
\[
\left(\begin{array}[t]{cc}
a & -\\
b & \begin{array}[t]{cc}
c\\
\\
\end{array}
\end{array}\right)=\left(\begin{array}[t]{cc}
\text{re}_{a}\\
\text{re}_{b} & \text{re}_{c}
\end{array}\right)-\left(\begin{array}[t]{cc}
\text{re}_{d}\cdot\text{rmat}_{a}\\
\text{re}_{c}\cdot\text{rmat}_{a} & \text{re}_{a}\cdot\text{rmat}_{a}
\end{array}\right)
\]

\begin{lstlisting}[firstnumber=last]

  b(1,1) = re(3,1) - (re(3,3) * rmat(1,1) + re(3,4) * rmat(2,1))
  b(1,2) = re(3,2) - (re(3,3) * rmat(1,2) + re(3,4) * rmat(2,2))
  b(2,1) = re(4,1) - (re(4,3) * rmat(1,1) + re(4,4) * rmat(2,1))
  b(2,2) = re(4,2) - (re(4,3) * rmat(1,2) + re(4,4) * rmat(2,2))
  c(1,1) = re(3,3) + (re(3,1) * rmat(2,2) - re(3,2) * rmat(2,1))
  c(1,2) = re(3,4) - (re(3,1) * rmat(1,2) - re(3,2) * rmat(1,1))
  c(2,1) = re(4,3) + (re(4,1) * rmat(2,2) - re(4,2) * rmat(2,1))
  c(2,2) = re(4,4) - (re(4,1) * rmat(1,2) - re(4,2) * rmat(1,1))

  !---- Track R matrix.
  adet = a(1,1) * a(2,2) - a(1,2) * a(2,1)
  rmat(1,1) = - (b(1,1) * a(2,2) - b(1,2) * a(2,1)) / adet
  rmat(1,2) =   (b(1,1) * a(1,2) - b(1,2) * a(1,1)) / adet
  rmat(2,1) = - (b(2,1) * a(2,2) - b(2,2) * a(2,1)) / adet
  rmat(2,2) =   (b(2,1) * a(1,2) - b(2,2) * a(1,1)) / adet

  !---- Cummulative R matrix and one-turn map at element location.
  if(rmatrix) then
     inval=get_option('twiss_inval ')
     call m66mpy(re,rw,rw)
     if (inval.ne.0) then
        call dcopy(rw,rc,36)
     else
        call m66inv(rw,rwi)
        call m66mpy(rotm,rwi,rc)
        call m66mpy(rw,rc,rc)
     endif
  endif

  !---- Mode 1.
  tempb = a(1,1) * betx - a(1,2) * alfx
  tempa = a(2,1) * betx - a(2,2) * alfx
  alfx = - (tempa * tempb + a(1,2) * a(2,2)) / (adet * betx)
  betx =   (tempb * tempb + a(1,2) * a(1,2)) / (adet * betx)
  if(a(1,2).ne.zero.or.tempb.ne.zero) amux=amux+atan2(a(1,2),tempb)

  !---- Mode 2.
  tempb = c(1,1) * bety - c(1,2) * alfy
  tempa = c(2,1) * bety - c(2,2) * alfy
  alfy = - (tempa * tempb + c(1,2) * c(2,2)) / (adet * bety)
  bety =   (tempb * tempb + c(1,2) * c(1,2)) / (adet * bety)
  if(c(1,2).ne.zero.or.tempb.ne.zero) amuy=amuy+atan2(c(1,2),tempb)

  if(.not.centre.or.centre_cptk) then
     opt_fun(3 )=betx
     opt_fun(4 )=alfx
     opt_fun(5 )=amux
     opt_fun(6 )=bety
     opt_fun(7 )=alfy
     opt_fun(8 )=amuy
     opt_fun(29)=rmat(1,1)
     opt_fun(30)=rmat(1,2)
     opt_fun(31)=rmat(2,1)
     opt_fun(32)=rmat(2,2)
  endif
  if(rmatrix) then
     do i1=1,6
        do i2=1,6
           opt_fun(33+(i1-1)*6+i2)=rc(i1,i2)
        enddo
     enddo
  endif
\end{lstlisting}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Quadrupole magnets}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Multipoles magnets}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{Solenoide magnets}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{RF cavities}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\appendix
\section{Appendix}
\begin{itemize}
\item[-] \L{dcopy(in,out,n)}
\item[-] \L{m66mpy(fact1,fact2,target)} matrix multiplication $$\text{target} = \text{fact1} \cdot \text{fact2}$$
\item[-] \L{tmcat1(fsec,eb,rb,tb,ea,ra,ta,ed,rd,td)}$$\left\{ \begin{array}{c}
e_{d}\\
R_{d}\\
T_{d}
\end{array}\right\} =\left\{ \begin{array}{c}
e_{b}\\
R_{b}\\
T_{b}
\end{array}\right\} \circ \left\{ \begin{array}{c}
e_{a}\\
R_{a}\\
T_{a}
\end{array}\right\} $$
\end{itemize}

\end{document}