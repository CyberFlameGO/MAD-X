%%%\title{Range Selection}
%  Changed by: Chris ISELIN, 27-Jan-1997 
%  Changed by: Hans Grote, 30-Sep-2002 

\subsection{Program Flow Statements}

\begin{itemize}
	\item IF
\begin{verbatim}

if (logical_expression) {statement 1; statement 2; ...; statement n; }
\end{verbatim}
\href{logical}{ where "logical\_expression" } is one of 
\begin{verbatim}

expr1 oper expr2
expr11 oper1 expr12 && expr21 oper2 expr22
expr11 oper1 expr12 || expr21 oper2 expr22
\end{verbatim} 
and oper one of 
\begin{verbatim}

==          ! equal
<>          ! not equal
<           ! less than
>           ! greater than
<=          ! less than or equal
>=          ! greater than or equal
\end{verbatim} 
The expressions are arithmetic expressions of type real. The statements
in the curly brackets are executed if the logical expression is true.  


	\item ELSEIF%elseif}{ELSEIF}
\begin{verbatim}

elseif (logical_expression) {statement 1; statement 2; ...; statement n; }
\end{verbatim} 
Only possible (in any number) behind an IF, or another ELSEIF; is
executed if  logical\_expression is true, and if none of the preceding
IF or ELSEIF logical conditions was true.  


	\item ELSE%else}{ELSE}
\begin{verbatim}

else {statement 1; statement 2; ...; statement n; }
\end{verbatim} 
Only possible (once) behind an IF, or an ELSEIF; is executed if
logical\_expression is true, and if none of the preceding IF or ELSEIF
logical conditions was true.  

For a real life example, see \href{foot.html}{ELSE example}. 


	\item WHILE
\begin{verbatim}

while (logical_condition){statement 1; statement 2; ...; statement n; }
\end{verbatim}  
executes the statements in curly brackets while the logical\_expression
is true. A simple example (in case you have forgotten the first ten
factorials) would be  
\begin{verbatim}

option,-info;   ! otherwise you get redifiniton warnings
n=1; m=1;
while (n <= 10)
{
  m = m * n;  value, m;
  n = n + 1;
};
\end{verbatim}

For a real life example, see \href{foot.html}{WHILE example}.

	\item MACRO

\begin{verbatim}

label: macro = {statement 1; statement 2; ...; statement n; };
label(arg1,...,argn): macro = {statement 1; statement 2; ...; statement n; };
\end{verbatim} 
The first form allows the execution of a group of statements via a
single command:  
\begin{verbatim}

exec, label;
\end{verbatim} 
will execute the statements in curly brackets exactly once. This command
can be issued any number of times.  

The second form allows to replace strings anywhere inside the statements
in curly brackets by other strings, or integer numbers prior to
execution. This is a powerful construct and should be handled with care.  

Simple example: 
\begin{verbatim}

option,-echo,-info;  ! otherwise the output is somewhat confusing
simple(xx,yy): macro = { xx = yy^2 + xx; value, xx;};
a = 3;
b = 5;
exec, simple(a,b);
\end{verbatim}

Somewhat more tricky (a "\$" in front of an argument means that the
truncated integer value of this argument is used for replacement, rather
than the argument string itself).  
\begin{verbatim}

tricky(xx,yy,zz): macro = {mzz.yy: xx, l = 1.yy, kzz = k.yy;};
n=0;
while (n < 3)
{
  n = n+1;
  exec,tricky(quadrupole,$n,1);
  exec,tricky(sextupole,$n,2);
};
\end{verbatim} 
Whereas the actual use of the preceding example is NOT recommended,
a real life example, showing the full power (!) of macros is to be
found under \href{foot.html}{macro usage} for the usage, and
under \href{foot.html#macro}{macro definition} for the
definition.


Beware of the following rules:

	\item Generally speaking: \textit{ special constructs } like IF, WHILE,
MACRO will only allow one level of inclusion of another \textit{
special construct }.

	\item  Macros must not be called with numbers, but with strings
(i.e. variable names in case of numerical values), i.e. 



NOT

\begin{verbatim}

exec,thismacro($99,$129);
\end{verbatim}
BUT

\begin{verbatim}

n1=99; n2=219;
exec,thismacro($n1,$n2);
\end{verbatim}

\end{itemize}

%\href{http://www.cern.ch/Hans.Grote/hansg_sign.html}{hansg}, June 17, 2002

