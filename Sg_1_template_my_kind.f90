!The Polymorphic Tracking Code
!Copyright (C) Etienne Forest and Frank Schmidt
! See file Sa_rotation_mis
module USER_kind1
  use S_status
  private INTR,INTP,INTS,ZEROr_user1,ZEROp_user1
  private ALLOC_user1,KILL_user1,POINTERS_user1R,POINTERS_user1P
  private copy_el_elp ,copy_elp_el ,copy_el_el
  private scale_user1R,scale_user1P,PRINT_,READ_
  !   This can be called using EL=USER_1("name of EL",L) of the mad-like input without
  !   recompiling.  Then, of course, parameters must be set elsewhere. For example,
  !
  !   dr8_b = USER_1("dr8_b",c_4d_1)
  !   dr8_b%U1%internal=c_1_5e0
  !

  TYPE USER1
     TYPE(MAGNET_CHART), POINTER :: P
     real(dp), POINTER ::L      !  MUST ALWAYS BE THERE
     real(dp),  DIMENSION(:), POINTER :: AN,BN         !Multipole component (OPTIONAL)
     !   ADD INTERNAL STUFF HERE AS POINTERS
     !           .........
     real(dp), POINTER ::INTERNAL           ! INTERNAL IS AN EXAMPLE
  END  TYPE USER1

  TYPE USER1P
     TYPE(MAGNET_CHART), POINTER :: P
     TYPE(REAL_8), POINTER ::L                             !  MUST ALWAYS BE THERE
     TYPE(REAL_8),  DIMENSION(:), POINTER :: AN,BN         !Multipole component (OPTIONAL but always defined)
     !   ADD INTERNAL STUFF HERE AS POINTERS
     TYPE(REAL_8), POINTER ::INTERNAL        ! INTERNAL is an example of a variable specific to user1p
  END  TYPE USER1P

  INTERFACE TRACK
     MODULE PROCEDURE INTR
     MODULE PROCEDURE INTP
     MODULE PROCEDURE INTS
  END INTERFACE


  INTERFACE ALLOC
     MODULE PROCEDURE ALLOC_user1
  END INTERFACE

  INTERFACE POINTERS_user1
     MODULE PROCEDURE POINTERS_user1R
     MODULE PROCEDURE POINTERS_user1P
  END INTERFACE


  INTERFACE KILL
     MODULE PROCEDURE KILL_user1
  END INTERFACE

  INTERFACE copy
     MODULE PROCEDURE copy_el_elp
     MODULE PROCEDURE copy_elp_el
     MODULE PROCEDURE copy_el_el
  END INTERFACE

  INTERFACE scale_user1
     MODULE PROCEDURE scale_user1R
     MODULE PROCEDURE scale_user1P
  END INTERFACE

  INTERFACE PRINT_USER
     MODULE PROCEDURE PRINT_
  END INTERFACE

  INTERFACE READ_USER
     MODULE PROCEDURE READ_
  END INTERFACE

  INTERFACE ASSIGNMENT (=)
     MODULE PROCEDURE ZEROr_user1
     MODULE PROCEDURE ZEROp_user1
  END INTERFACE

contains

  SUBROUTINE INTR(EL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    INTEGER IPAUSE,MYPAUSE
    TYPE(USER1),INTENT(IN):: EL

    WRITE(6,*) "USER1 NOT DEFINED "
    IPAUSE=MYPAUSE(111)


  END SUBROUTINE INTR






  SUBROUTINE INTP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    INTEGER IPAUSE,MYPAUSE
    TYPE(USER1P),INTENT(IN):: EL

    WRITE(6,*) "USER1P NOT DEFINED "
    IPAUSE=MYPAUSE(112)

  END SUBROUTINE INTP

  SUBROUTINE INTS(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    INTEGER IPAUSE,MYPAUSE
    TYPE(USER1P),INTENT(IN):: EL

    WRITE(6,*) "USER1P NOT DEFINED "
    IPAUSE=MYPAUSE(113)

  END SUBROUTINE INTS



  SUBROUTINE ZEROR_user1(EL,I)
    IMPLICIT NONE
    TYPE(USER1), INTENT(inout)::EL
    INTEGER, INTENT(IN)::I
    IF(I==-1) THEN
       !  Set real(dp) variables to zero or whatever  if any
       !  IF POINTED ASSOCIATED DEASSOCIATE
       IF(ASSOCIATED(EL%INTERNAL))  THEN
          DEALLOCATE(EL%INTERNAL)
       ENDIF
    elseif(i==0)       then
       NULLIFY(EL%INTERNAL)
       ! nullifies pointers
       ! And also zeroes for security ordinary variables
    endif

  END SUBROUTINE ZEROR_user1

  SUBROUTINE ZEROp_user1(EL,I)
    IMPLICIT NONE
    TYPE(USER1P), INTENT(inout)::EL
    INTEGER, INTENT(IN)::I
    IF(I==-1) THEN
       !  Set real(dp) variables to zero or whatever  if any
       !  IF POINTED ASSOCIATED KILL AND DEASSOCIATE
       IF(ASSOCIATED(EL%INTERNAL))  THEN
          CALL KILL(EL)              ! FPP DEALLOCATION FIRST OBVIOUSLY
          DEALLOCATE(EL%INTERNAL)
       ENDIF
    elseif(i==0)       then
       NULLIFY(EL%INTERNAL)
       ! nullifies pointers
       ! And also zeroes for security ordinary variables
       !
    endif

  END SUBROUTINE ZEROp_user1

  SUBROUTINE copy_el_elp(EL,ELP)
    IMPLICIT NONE
    TYPE(USER1), INTENT(in)::EL
    TYPE(USER1P), INTENT(inout)::ELP

    ELP%INTERNAL    =EL%INTERNAL
    !  COPY CODING HERE NO ALLOCATION OF POINTERS OR POLYMORPH NEEDED
    !  IF DONE CORRECTLY

  END SUBROUTINE copy_el_elp

  SUBROUTINE copy_elp_el(EL,ELP)
    IMPLICIT NONE
    TYPE(USER1P), INTENT(in)::EL
    TYPE(USER1), INTENT(inout)::ELP




    ELP%INTERNAL    =EL%INTERNAL
    !  COPY CODING HERE NO ALLOCATION OF POINTERS OR POLYMORPH NEEDED
    !  IF DONE CORRECTLY


  END SUBROUTINE copy_elp_el

  SUBROUTINE copy_el_el(EL,ELP)
    IMPLICIT NONE
    TYPE(USER1), INTENT(in)::EL
    TYPE(USER1), INTENT(inout)::ELP

    ELP%INTERNAL    =EL%INTERNAL
    !  COPY CODING HERE NO ALLOCATION OF POINTERS


  END SUBROUTINE copy_el_el



  SUBROUTINE POINTERS_user1R(EL)
    IMPLICIT NONE
    TYPE(USER1), INTENT(INOUT)::EL

    ALLOCATE(EL%INTERNAL)


    ! ALLOCATE INTERNAL POINTERS IF ANY

  END SUBROUTINE POINTERS_user1R

  SUBROUTINE POINTERS_user1P(EL)
    IMPLICIT NONE
    TYPE(USER1P), INTENT(INOUT)::EL

    ALLOCATE(EL%INTERNAL)
    ! ALLOCATE INTERNAL POINTERS IF ANY

  END SUBROUTINE POINTERS_user1P


  SUBROUTINE ALLOC_user1(EL)
    IMPLICIT NONE
    TYPE(USER1P), INTENT(INOUT)::EL
    CALL ALLOC(EL%INTERNAL)
    ! ALLOC INTERNAL POLYMORPHS IF ANY
  END SUBROUTINE ALLOC_user1


  SUBROUTINE KILL_user1(EL)
    IMPLICIT NONE
    TYPE(USER1P), INTENT(INOUT)::EL

    CALL KILL(EL%INTERNAL)
    ! KILL INTERNAL POLYMORPHS IF ANY

  END SUBROUTINE KILL_user1

  SUBROUTINE reset_U1(EL)
    IMPLICIT NONE
    TYPE(USER1P), INTENT(INOUT)::EL


    CALL resetpoly_R31(EL%INTERNAL)
    ! CALL resetpoly_R31 ON ALL THE INTERNAL POLYMORPHS

  END SUBROUTINE reset_U1


  SUBROUTINE PRINT_(EL,MF)
    IMPLICIT NONE
    TYPE(USER1), INTENT(INOUT)::EL
    INTEGER MF

    WRITE(MF,*) EL%INTERNAL
    ! CALL resetpoly_R31 ON ALL THE INTERNAL POLYMORPHS

  END SUBROUTINE PRINT_

  SUBROUTINE READ_(EL,MF)
    IMPLICIT NONE
    TYPE(USER1), INTENT(INOUT)::EL
    INTEGER MF

    READ(MF,*) EL%INTERNAL
    ! CALL resetpoly_R31 ON ALL THE INTERNAL POLYMORPHS

  END SUBROUTINE READ_

  SUBROUTINE  ELp_POL_user1(S2,S1,DONEIT)
    implicit none
    type (POL_BLOCK),INTENT(IN):: S1
    TYPE(user1p),INTENT(inOUT):: S2
    logical(lp),INTENT(inOUT)::  DONEIT

    ! ONE CAN LINK INTERNAL POLYMORPHS TO PART OF POL_BLOCK WHICH IS NOT USED
    ! HERE THE VARIABLE "INTERNAL" IS LINKED TO VOLT


    IF(S1%IVOLT>0) THEN
       s2%INTERNAL%I=S1%IVOLT+S1%NPARA
       s2%INTERNAL%S=S1%SVOLT
       s2%INTERNAL%KIND=3
       DONEIT=.TRUE.
       IF(S1%SET_TPSAFIT) THEN
          s2%INTERNAL%R=s2%INTERNAL%R+s2%INTERNAL%S*s1%TPSAFIT(S1%IVOLT)
       ENDIF
    ENDIF

    !  or try
    !             IF(S1%user1%Iinternal>0) THEN
    !                s2%INTERNAL%I=S1%user1%Iinternal+S1%NPARA
    !                s2%INTERNAL%S=S1%user1%Sinternal
    !                s2%INTERNAL%KIND=3
    !                DONEIT=.TRUE.
    !                IF(S1%SET_TPSAFIT) THEN
    !                   s2%INTERNAL%R=s2%INTERNAL%R+s2%INTERNAL%S*s1%TPSAFIT(S1%user1%Iinternal)
    !                ENDIF
    !             ENDIF


  end SUBROUTINE  ELp_POL_user1

  SUBROUTINE  scale_user1R(S2,P0C_OLD,P0C_NEW)
    implicit none
    TYPE(USER1),INTENT(inOUT):: S2
    real(dp),INTENT(IN)::  P0C_OLD,P0C_NEW

    ! EXAMPLE

    S2%INTERNAL= S2%INTERNAL*P0C_OLD/P0C_NEW


  end SUBROUTINE  scale_user1R

  SUBROUTINE  scale_user1P(S2,P0C_OLD,P0C_NEW)
    implicit none
    TYPE(USER1p),INTENT(inOUT):: S2
    real(dp),INTENT(IN)::  P0C_OLD,P0C_NEW

    ! EXAMPLE

    S2%INTERNAL= S2%INTERNAL*P0C_OLD/P0C_NEW


  end SUBROUTINE  scale_user1P



end module USER_kind1
