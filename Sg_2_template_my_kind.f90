!The Polymorphic Tracking Code
!Copyright (C) Etienne Forest and Frank Schmidt
! See file Sa_rotation_mis
module USER_kind2
  use S_status
  private INTR,INTP,INTS,ZEROr_USER2,ZEROp_USER2
  private ALLOC_USER2,KILL_USER2,POINTERS_USER2R,POINTERS_USER2P
  private copy_el_elp ,copy_elp_el ,copy_el_el
  private scale_user2R,scale_user2P,PRINT_,READ_

  !   This can be called using EL=USER_2("name of EL",L) of the mad-like input without
  !   recompiling.  Then, of course, parameters must be set elsewhere. For example,
  !
  !   dr8_b = USER_2("dr8_b",c_4d_1)
  !   dr8_b%U2%internal=c_1_5e0
  !

  TYPE USER2
     TYPE(MAGNET_CHART), POINTER :: P
     real(dp), POINTER ::L      !  MUST ALWAYS BE THERE
     real(dp),  DIMENSION(:), POINTER :: AN,BN         !Multipole component (OPTIONAL)
     !   ADD INTERNAL STUFF HERE AS POINTERS
     !           .........
     real(dp), POINTER ::INTERNAL           ! INTERNAL IS AN EXAMPLE
  END  TYPE USER2

  TYPE USER2P
     TYPE(MAGNET_CHART), POINTER :: P
     TYPE(REAL_8), POINTER ::L       !  MUST ALWAYS BE THERE
     TYPE(REAL_8),  DIMENSION(:), POINTER :: AN,BN         !Multipole component (OPTIONAL)
     !   ADD INTERNAL STUFF HERE AS POINTERS
     !           .........
     TYPE(REAL_8), POINTER ::INTERNAL        ! INTERNAL IS AN EXAMPLE
  END  TYPE USER2P

  INTERFACE TRACK
     MODULE PROCEDURE INTR
     MODULE PROCEDURE INTP
     MODULE PROCEDURE INTS
  END INTERFACE


  INTERFACE ALLOC
     MODULE PROCEDURE ALLOC_USER2
  END INTERFACE

  INTERFACE POINTERS_USER2
     MODULE PROCEDURE POINTERS_USER2R
     MODULE PROCEDURE POINTERS_USER2P
  END INTERFACE


  INTERFACE KILL
     MODULE PROCEDURE KILL_USER2
  END INTERFACE

  INTERFACE copy
     MODULE PROCEDURE copy_el_elp
     MODULE PROCEDURE copy_elp_el
     MODULE PROCEDURE copy_el_el
  END INTERFACE

  INTERFACE scale_user2
     MODULE PROCEDURE scale_user2R
     MODULE PROCEDURE scale_user2P
  END INTERFACE

  INTERFACE PRINT_USER
     MODULE PROCEDURE PRINT_
  END INTERFACE

  INTERFACE READ_USER
     MODULE PROCEDURE READ_
  END INTERFACE

  INTERFACE ASSIGNMENT (=)
     MODULE PROCEDURE ZEROr_USER2
     MODULE PROCEDURE ZEROp_USER2
  END INTERFACE

contains

  SUBROUTINE INTR(EL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    INTEGER IPAUSE,MYPAUSE
    TYPE(USER2),INTENT(IN):: EL

    WRITE(6,*) "USER2 NOT DEFINED "
    IPAUSE=MYPAUSE(111)


  END SUBROUTINE INTR






  SUBROUTINE INTP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    INTEGER IPAUSE,MYPAUSE
    TYPE(USER2P),INTENT(IN):: EL

    WRITE(6,*) "USER2P NOT DEFINED "
    IPAUSE=MYPAUSE(112)

  END SUBROUTINE INTP

  SUBROUTINE INTS(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    INTEGER IPAUSE,MYPAUSE
    TYPE(USER2P),INTENT(IN):: EL

    WRITE(6,*) "USER2P NOT DEFINED "
    IPAUSE=MYPAUSE(113)

  END SUBROUTINE INTS



  SUBROUTINE ZEROR_USER2(EL,I)
    IMPLICIT NONE
    TYPE(USER2), INTENT(inout)::EL
    INTEGER, INTENT(IN)::I
    IF(I==-1) THEN
       !  Set real(dp) variables to zero or whatever  if any
       !  IF POINTED ASSOCIATED DEASSOCIATE
       IF(ASSOCIATED(EL%INTERNAL))  THEN
          DEALLOCATE(EL%INTERNAL)
       ENDIF
    elseif(i==0)       then
       NULLIFY(EL%INTERNAL)
       ! nullifies pointers
       ! And also zeroes for security ordinary variables
    endif

  END SUBROUTINE ZEROR_USER2

  SUBROUTINE ZEROp_USER2(EL,I)
    IMPLICIT NONE
    TYPE(USER2P), INTENT(inout)::EL
    INTEGER, INTENT(IN)::I
    IF(I==-1) THEN
       !  Set real(dp) variables to zero or whatever  if any
       !  IF POINTED ASSOCIATED KILL AND DEASSOCIATE
       IF(ASSOCIATED(EL%INTERNAL))  THEN
          CALL KILL(EL)              ! FPP DEALLOCATION FIRST OBVIOUSLY
          DEALLOCATE(EL%INTERNAL)
       ENDIF
    elseif(i==0)       then
       NULLIFY(EL%INTERNAL)
       ! nullifies pointers
       ! And also zeroes for security ordinary variables
       !
    endif

  END SUBROUTINE ZEROp_USER2

  SUBROUTINE copy_el_elp(EL,ELP)
    IMPLICIT NONE
    TYPE(USER2), INTENT(in)::EL
    TYPE(USER2P), INTENT(inout)::ELP

    ELP%INTERNAL    =EL%INTERNAL
    !  COPY CODING HERE NO ALLOCATION OF POINTERS OR POLYMORPH NEEDED
    !  IF DONE CORRECTLY

  END SUBROUTINE copy_el_elp

  SUBROUTINE copy_elp_el(EL,ELP)
    IMPLICIT NONE
    TYPE(USER2P), INTENT(in)::EL
    TYPE(USER2), INTENT(inout)::ELP




    ELP%INTERNAL    =EL%INTERNAL
    !  COPY CODING HERE NO ALLOCATION OF POINTERS OR POLYMORPH NEEDED
    !  IF DONE CORRECTLY


  END SUBROUTINE copy_elp_el

  SUBROUTINE copy_el_el(EL,ELP)
    IMPLICIT NONE
    TYPE(USER2), INTENT(in)::EL
    TYPE(USER2), INTENT(inout)::ELP

    ELP%INTERNAL    =EL%INTERNAL
    !  COPY CODING HERE NO ALLOCATION OF POINTERS


  END SUBROUTINE copy_el_el



  SUBROUTINE POINTERS_user2R(EL)
    IMPLICIT NONE
    TYPE(USER2), INTENT(INOUT)::EL

    ALLOCATE(EL%INTERNAL)

    ! ALLOCATE INTERNAL POINTERS IF ANY

  END SUBROUTINE POINTERS_user2R

  SUBROUTINE POINTERS_user2P(EL)
    IMPLICIT NONE
    TYPE(USER2P), INTENT(INOUT)::EL

    ALLOCATE(EL%INTERNAL)
    ! ALLOCATE INTERNAL POINTERS IF ANY

  END SUBROUTINE POINTERS_user2P

  SUBROUTINE ALLOC_USER2(EL)
    IMPLICIT NONE
    TYPE(USER2P), INTENT(INOUT)::EL
    CALL ALLOC(EL%INTERNAL)
    ! ALLOC INTERNAL POLYMORPHS IF ANY
  END SUBROUTINE ALLOC_USER2


  SUBROUTINE KILL_USER2(EL)
    IMPLICIT NONE
    TYPE(USER2P), INTENT(INOUT)::EL

    CALL KILL(EL%INTERNAL)
    ! KILL INTERNAL POLYMORPHS IF ANY

  END SUBROUTINE KILL_USER2

  SUBROUTINE reset_U2(EL)
    IMPLICIT NONE
    TYPE(USER2P), INTENT(INOUT)::EL


    CALL resetpoly_R31(EL%INTERNAL)
    ! CALL resetpoly_R31 ON ALL THE INTERNAL POLYMORPHS

  END SUBROUTINE reset_U2

  SUBROUTINE PRINT_(EL,MF)
    IMPLICIT NONE
    TYPE(USER2), INTENT(INOUT)::EL
    INTEGER MF

    WRITE(MF,*) EL%INTERNAL
    ! CALL resetpoly_R31 ON ALL THE INTERNAL POLYMORPHS

  END SUBROUTINE PRINT_

  SUBROUTINE READ_(EL,MF)
    IMPLICIT NONE
    TYPE(USER2), INTENT(INOUT)::EL
    INTEGER MF

    READ(MF,*) EL%INTERNAL
    ! CALL resetpoly_R31 ON ALL THE INTERNAL POLYMORPHS

  END SUBROUTINE READ_

  SUBROUTINE  ELp_POL_USER2(S2,S1,DONEIT)
    implicit none
    type (POL_BLOCK),INTENT(IN):: S1
    TYPE(USER2p),INTENT(inOUT):: S2
    logical(lp),INTENT(inOUT)::  DONEIT

    ! ONE CAN LINK INTERNAL POLYMORPHS TO PART OF POL_BLOCK WHICH IS NOT USED
    ! HERE THE VARIABLE "INTERNAL" IS LINKED TO VOLT
    ! We also linked it to the pol_block2


    IF(S1%IVOLT>0) THEN
       s2%INTERNAL%I=S1%IVOLT+S1%NPARA
       s2%INTERNAL%S=S1%SVOLT
       s2%INTERNAL%KIND=3
       DONEIT=.TRUE.
       IF(S1%SET_TPSAFIT) THEN
          s2%INTERNAL%R=s2%INTERNAL%R+s2%INTERNAL%S*s1%TPSAFIT(S1%IVOLT)
       ENDIF
    ENDIF
    !  or try
    !             IF(S1%user2%Iinternal>0) THEN
    !                s2%INTERNAL%I=S1%user2%Iinternal+S1%NPARA
    !                s2%INTERNAL%S=S1%user2%Sinternal
    !                s2%INTERNAL%KIND=3
    !                DONEIT=.TRUE.
    !                IF(S1%SET_TPSAFIT) THEN
    !                   s2%INTERNAL%R=s2%INTERNAL%R+s2%INTERNAL%S*s1%TPSAFIT(S1%user2%Iinternal)
    !                ENDIF
    !             ENDIF


  end SUBROUTINE  ELp_POL_USER2

  SUBROUTINE  scale_user2R(S2,P0C_OLD,P0C_NEW)
    implicit none
    TYPE(USER2),INTENT(inOUT):: S2
    real(dp),INTENT(IN)::  P0C_OLD,P0C_NEW

    ! EXAMPLE

    S2%INTERNAL= S2%INTERNAL*P0C_OLD/P0C_NEW


  end SUBROUTINE  scale_user2R

  SUBROUTINE  scale_user2P(S2,P0C_OLD,P0C_NEW)
    implicit none
    TYPE(USER2p),INTENT(inOUT):: S2
    real(dp),INTENT(IN)::  P0C_OLD,P0C_NEW

    ! EXAMPLE

    S2%INTERNAL= S2%INTERNAL*P0C_OLD/P0C_NEW


  end SUBROUTINE  scale_user2P

end module USER_kind2
