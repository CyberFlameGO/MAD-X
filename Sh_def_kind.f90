!The Polymorphic Tracking Code
!Copyright (C) Etienne Forest and CERN

MODULE S_DEF_KIND
  USE S_def_all_kinds   ! not needed because of things below
  public
  PRIVATE DRIFTP,DRIFTS  !,DRIFT   ! ,DRIFTR
  PRIVATE SPARR,SPARP,SPARS !,SPAR
  PRIVATE CAVITYR,CAVITYP,CAVITYS !,CAVITY
  PRIVATE CAVER,CAVEP,CAVES
  PRIVATE KICKCAVR,KICKCAVP,KICKCAVS !,KICKCAV
  PRIVATE FRINGECAVR,FRINGECAVP,FRINGECAVS,FRINGECAV
  PRIVATE KICKTR,KICKTP,KICKTS
  PRIVATE MULTIPOLE_FRINGER,MULTIPOLE_FRINGEP,MULTIPOLE_FRINGES !,MULTIPOLE_FRINGE
  PRIVATE FRINGER,FRINGEP,FRINGES
  !  PRIVATE FRINGE_
  PRIVATE EDGER,EDGEP,EDGES !,EDGE
  PRIVATE KICKR,KICKP,KICKS !,KICK
  PRIVATE KICKEXR,KICKEXP,KICKEXS
  PRIVATE INTER,INTEP,INTES,INTE
  PRIVATE INTEEXR,INTEEXP,INTEEXS,INTE_strex
  PRIVATE SYMPINTR,SYMPINTP,SYMPINTS
  PRIVATE SYMPINTEXR,SYMPINTEXP,SYMPINTEXS
  PRIVATE KICK_SOLR,KICK_SOLP,KICK_SOLS !,KICK_SOL
  PRIVATE SOL_ROTR,SOL_ROTP,SOL_ROTS !,SOL_ROT
  PRIVATE INTESOLR,INTESOLP,INTESOLS,INTESOL
  PRIVATE FACER,FACEP,FACES !,FACE
  PRIVATE NEWFACER,NEWFACEP,NEWFACES
  PRIVATE EDGER_TRUE_PARALLEL,EDGEP_TRUE_PARALLEL,EDGES_TRUE_PARALLEL

  PRIVATE ZEROR_KTK,ZEROP_KTK,ZEROR_STREX,ZEROP_STREX,ZEROR_CAV4,ZEROP_CAV4
  PRIVATE ZEROR_KICKT3,ZEROP_KICKT3
  PRIVATE ALLOCKTK,KILLKTK
  PRIVATE GETMATR,GETMATD,GETMATS !,GETMAT
  PRIVATE PUSHKTKR,PUSHKTKD,PUSHKTKS !,PUSHKTK
  PRIVATE KICKKTKR,KICKKTKP,KICKKTKS !,KICKKTK
  PRIVATE INTKTKR,INTKTKD,INTKTKS,INTKTK
  PRIVATE SYMPINTKTKR,SYMPINTKTKD,SYMPINTKTKS

  PRIVATE KICKPATH6R,KICKPATH6P,KICKPATH6S
  PRIVATE EXP6R,EXP6D,EXPCOSY6   ! special for integrated exponential path length
  PRIVATE EXPR,EXPD,EXPCOSY

  PRIVATE ZEROR_TKT7,ZEROP_TKT7
  PRIVATE ALLOCTKT7,KILLTKT7
  PRIVATE GETMAT7R,GETMAT7D  !,GETMAT7
  PRIVATE PUSHTKT7R,PUSHTKT7D,PUSHTKT7S !,PUSHTKT7
  PRIVATE KICKTKT7R,KICKTKT7P,KICKTKT7S !,KICKTKT7
  PRIVATE KICKPATHR,KICKPAThD,KICKPATHS !,KICKPATH
  PRIVATE INTTKT7R,INTTKT7D,INTTKT7S,INTTKT7
  PRIVATE SYMPINTTKT7R,SYMPINTTKT7D,SYMPINTTKT7S
  PRIVATE SYMPINTSOLR,SYMPINTSOLP,SYMPINTSOLS
  PRIVATE GETMULB_SOLR,GETMULB_SOLP,GETMULB_SOL
  PRIVATE KICKMULR,KICKMULP,KICKMULS !,KICKMUL

  PRIVATE EXPR7,EXPD7,EXPCOSY7

  PRIVATE PUSH_NSMI_R,PUSH_NSMI_D,PUSH_NSMI_S
  PRIVATE PUSH_SSMI_R,PUSH_SSMI_D,PUSH_SSMI_S

  PRIVATE GETANBNR,GETANBNP,ZEROR_teapot,ZEROP_teapot,ALLOCTEAPOT,KILLTEAPOT
  PRIVATE SPROTR,SPROTP,SPROTS,SPROT
  PRIVATE SseCR,SseCP,SseCS,Ssec
  PRIVATE SSECH1R,SSECH1P,SSECH1S !,SSECH1
  PRIVATE SKICKR,SKICKP,SKICKS !,SKICK
  PRIVATE SINTER,SINTEP,SINTES,SINTE
  PRIVATE SSYMPINTR,SSYMPINTP,SSYMPINTS
  PRIVATE wedgeR,wedgeP,wedgeS !,wedge


  PRIVATE MONTR,MONTP,MONTS,ZEROr_mon,ZEROP_mon
  PRIVATE MONTIR,MONTIP,MONTIS
  PRIVATE ECOLLIMATORR,ECOLLIMATORP,ECOLLIMATORS
  PRIVATE RCOLLIMATORR,RCOLLIMATORP,RCOLLIMATORS
  PRIVATE RCOLLIMATORiR,RCOLLIMATORiP ,RCOLLIMATORiS !,RCOLLIMATORi
  PRIVATE ECOLLIMATORiR,ECOLLIMATORiP ,ECOLLIMATORiS !,RCOLLIMATORi
  PRIVATE ZEROr_ECOL,ZEROP_ECOL,ZEROr_RCOL,ZEROP_RCOL

  PRIVATE SEPR,SEPP,SEPS,SYMPSEPR,SYMPSEPP,SYMPSEPS !,SEPTTRACK
  !  PRIVATE IN,IN1,IN2
  INTEGER IN(4,4),IN1(10),IN2(10)
  PRIVATE EXPSOLR,EXPSOLD,EXPCOSSOL
  PRIVATE EXPSOL6R,EXPSOL6D,EXPCOSSOL6
  PRIVATE PUSHSOLR,PUSHSOLD,PUSHSOLS !,PUSHSOL
  PRIVATE GETMATSOLR,GETMATSOLP,GETMATSOLS !,GETMATSOL
  PRIVATE ALLOCSOL,KILLSOL,ZEROR_SOL,ZEROP_SOL
  PRIVATE INTSOLR,INTSOLP,INTSOLS
  PRIVATE SYMPINTSOLTR,SYMPINTSOLTP,SYMPINTSOLTS
  PRIVATE GETMULB_SOLTR,GETMULB_SOLTP
  PRIVATE KICKMULTR,KICKMULTP,KICKMULTS
  PRIVATE KICK_SOLTR,KICK_SOLTP,KICK_SOLTS
  PRIVATE KICKPATH6TR,KICKPATH6TP,KICKPATH6TS
  PRIVATE ZEROR_CAV_TRAV,ZEROP_CAV_TRAV
  PRIVATE MARTINR,MARTINP,MARTINS,ZERO_MARTIN

  PRIVATE copypancake_el_elp,copypancake_elp_el,copypancake_el_el
  PRIVATE POINTERS_pancakeR,POINTERS_pancakep
  PRIVATE ZEROr_PANCAKE,ZEROP_PANCAKE
  PRIVATE rk4_pancaker,rk4_pancakeP,rk4_pancakes
  PRIVATE FEVAL_pancaker,FEVAL_pancakeP,feval_PANCAkEs
  PRIVATE INTPANCAKER,INTPANCAKEP,INTPANCAKEs,conv_to_xpr,conv_to_xpp,conv_to_pxr
  private conv_to_pxp

  !  private DRIFT_pancaker,DRIFT_pancakep,KICKPATH_pancaker,KICKPATH_pancakep
  ! using x and x'
  private fxr,fxp,fxs,f_m
  PRIVATE feval       !,rk4_m
  !  FOR CAV_TRAV
  PRIVATE A_TRANSR,A_TRANSP,A_TRANS
  PRIVATE feval_CAVr,feval_CAVP,feval_CAV
  private  FRINGECAVR_TRAV,FRINGECAVP_TRAV,FRINGECAVS_TRAV !,FRINGECAV_TRAV
  private rk2_cavr,rk2_cavp !,rk2_cav
  private rk4_cavr,rk4_cavp !,rk4_cav
  private rk6_cavr,rk6_cavp !,rk6_cav
  PRIVATE DRIFT_INTER,DRIFT_INTEP,DRIFT_INTES   ! NEW DRIFTS CUTABLE
  INTEGER,PRIVATE :: NMAXI=10000
  logical(lp) :: SPEED=.TRUE.
  integer,TARGET :: HIGHEST_FRINGE=2
  logical(lp) ,TARGET :: OLD_IMPLEMENTATION_OF_SIXTRACK=.TRUE.
  real(dp), target :: phase0=-pi
  real(dp), target :: wedge_coeff(2)
  logical(lp), target :: MAD8_WEDGE=.TRUE.
  INTEGER , target :: CAVITY_TOTALPATH=1   !  default is fake
  logical(lp) :: bug_intentional=.true.
  ! stochastic radiation in straigth

  !include "def_all_kind.f90"
  ! New home for element and elementp

  INTERFACE TRACK
     !     MODULE PROCEDURE DRFTR   ! MID DEFINED AS 1/2 L
     !     MODULE PROCEDURE DRFTP   ! MID
     !     MODULE PROCEDURE DRFTS
     MODULE PROCEDURE DRIFT_INTER   ! MID DEFINED AS 1/2 L
     MODULE PROCEDURE DRIFT_INTEP   ! MID
     MODULE PROCEDURE DRIFT_INTES

     MODULE PROCEDURE SYMPINTR ! MID IN INTE  DKD2
     MODULE PROCEDURE SYMPINTP ! MID IN INTE
     MODULE PROCEDURE SYMPINTS
     MODULE PROCEDURE SYMPINTEXR ! MID IN INTE
     MODULE PROCEDURE SYMPINTEXP ! MID IN INTE
     MODULE PROCEDURE SYMPINTEXS
     MODULE PROCEDURE KICKTR    ! MID DEFINED /12 KICK
     MODULE PROCEDURE KICKTP    ! MID DEFINED /12 KICK
     MODULE PROCEDURE KICKTS
     ! CAVITY THICK/THIN ELEMENT
     MODULE PROCEDURE CAVER     ! MID DEFINED /12 KICK   ALSO IN CAVITYR AND  CAVITYP
     MODULE PROCEDURE CAVEP      ! MID DEFINED /12 KICK
     MODULE PROCEDURE CAVES
     MODULE PROCEDURE CAVER_TRAV     ! MID DEFINED /12 KICK   ALSO IN CAVITYR AND  CAVITYP
     MODULE PROCEDURE CAVEP_TRAV      ! MID DEFINED /12 KICK
     MODULE PROCEDURE CAVES_TRAV
     ! SOLENOID THICK ELEMENT
     MODULE PROCEDURE SYMPINTSOLR
     MODULE PROCEDURE SYMPINTSOLP
     MODULE PROCEDURE SYMPINTSOLS
     ! SLOW THICK ELEMENT    SIXTRACK
     MODULE PROCEDURE SYMPINTKTKR
     MODULE PROCEDURE SYMPINTKTKD
     MODULE PROCEDURE SYMPINTKTKS
     ! FAST THICK ELEMENT
     MODULE PROCEDURE SYMPINTTKT7R
     MODULE PROCEDURE SYMPINTTKT7D
     MODULE PROCEDURE SYMPINTTKT7S
     ! THE THIN NORMAL SMI
     MODULE PROCEDURE PUSH_NSMI_R
     MODULE PROCEDURE PUSH_NSMI_D
     MODULE PROCEDURE PUSH_NSMI_S
     ! THE THIN SKEW SMI
     MODULE PROCEDURE PUSH_SSMI_R
     MODULE PROCEDURE PUSH_SSMI_D
     MODULE PROCEDURE PUSH_SSMI_S
     ! SECTOR (TEAPOT)
     MODULE PROCEDURE SSYMPINTR
     MODULE PROCEDURE SSYMPINTP
     MODULE PROCEDURE SSYMPINTS
     ! MONITOR AND INSTRUMENT
     MODULE PROCEDURE MONTR
     MODULE PROCEDURE MONTP
     MODULE PROCEDURE MONTS
     ! COLLIMATORS
     MODULE PROCEDURE RCOLLIMATORR
     MODULE PROCEDURE RCOLLIMATORP
     MODULE PROCEDURE RCOLLIMATORS
     MODULE PROCEDURE ECOLLIMATORR
     MODULE PROCEDURE ECOLLIMATORP
     MODULE PROCEDURE ECOLLIMATORS
     ! ELECTROSTATIC SEPTUM
     MODULE PROCEDURE SYMPSEPR
     MODULE PROCEDURE SYMPSEPP
     MODULE PROCEDURE SYMPSEPS
     ! SOLENOID SIXTRACK
     MODULE PROCEDURE SYMPINTSOLTR
     MODULE PROCEDURE SYMPINTSOLTP
     MODULE PROCEDURE SYMPINTSOLTS
     ! TAYLOR MAP
     MODULE PROCEDURE MARTINR
     MODULE PROCEDURE MARTINP
     MODULE PROCEDURE MARTINS

     ! PANCAKE
     MODULE PROCEDURE INTPANCAKER
     MODULE PROCEDURE INTPANCAKEP
     MODULE PROCEDURE INTPANCAKES
  END INTERFACE

  INTERFACE DRIFT
     MODULE PROCEDURE DRIFTR
     MODULE PROCEDURE DRIFTP       ! USE TO CREATE OTHER ELEMENTS (INTEGRATION)
     MODULE PROCEDURE DRIFTS
  END INTERFACE


  !@  INTERFACE DRIFT_pancake
  !    MODULE PROCEDURE DRIFT_pancaker
  !    MODULE PROCEDURE DRIFT_pancakep
  ! END INTERFACE

  INTERFACE MONTI
     MODULE PROCEDURE MONTIR
     MODULE PROCEDURE MONTIP       ! USE TO CREATE OTHER ELEMENTS (INTEGRATION)
     MODULE PROCEDURE MONTIS
  END INTERFACE

  INTERFACE RCOLLIMATORi
     MODULE PROCEDURE RCOLLIMATORiR
     MODULE PROCEDURE RCOLLIMATORiP       ! USE TO CREATE OTHER ELEMENTS (INTEGRATION)
     MODULE PROCEDURE RCOLLIMATORiS
  END INTERFACE

  INTERFACE ECOLLIMATORi
     MODULE PROCEDURE ECOLLIMATORiR
     MODULE PROCEDURE ECOLLIMATORiP       ! USE TO CREATE OTHER ELEMENTS (INTEGRATION)
     MODULE PROCEDURE ECOLLIMATORiS
  END INTERFACE

  INTERFACE KICKCAV
     MODULE PROCEDURE KICKCAVR
     MODULE PROCEDURE KICKCAVP       ! USE TO CREATE OTHER ELEMENTS (INTEGRATION)
     MODULE PROCEDURE KICKCAVS
  END INTERFACE


  INTERFACE A_TRANS
     MODULE PROCEDURE A_TRANSR
     MODULE PROCEDURE A_TRANSP
  END INTERFACE

  INTERFACE feval_CAV
     MODULE PROCEDURE feval_CAVr
     MODULE PROCEDURE feval_CAVp
  END INTERFACE

  INTERFACE rk2_cav
     MODULE PROCEDURE rk2_cavr
     MODULE PROCEDURE rk2_cavp
  END INTERFACE

  INTERFACE rk4_cav
     MODULE PROCEDURE rk4_cavr
     MODULE PROCEDURE rk4_cavp
  END INTERFACE

  INTERFACE rk6_cav
     MODULE PROCEDURE rk6_cavr
     MODULE PROCEDURE rk6_cavp
  END INTERFACE

  INTERFACE FRINGECAV
     MODULE PROCEDURE FRINGECAVR
     MODULE PROCEDURE FRINGECAVP       ! CAVITY FRINGE FIELDS
     MODULE PROCEDURE FRINGECAVS
  END INTERFACE

  INTERFACE FRINGECAV_TRAV
     MODULE PROCEDURE FRINGECAVR_TRAV
     MODULE PROCEDURE FRINGECAVP_TRAV       ! CAVITY FRINGE FIELDS
     MODULE PROCEDURE FRINGECAVS_TRAV
  END INTERFACE


  INTERFACE CAVITY
     MODULE PROCEDURE CAVITYR
     MODULE PROCEDURE CAVITYP       ! USE TO CREATE OTHER ELEMENTS (INTEGRATION)
     MODULE PROCEDURE CAVITYS
  END INTERFACE

  INTERFACE MULTIPOLE_FRINGE
     MODULE PROCEDURE MULTIPOLE_FRINGER
     MODULE PROCEDURE MULTIPOLE_FRINGEP       ! USE TO CREATE OTHER ELEMENTS (INTEGRATION)
     MODULE PROCEDURE MULTIPOLE_FRINGES
  END INTERFACE

  !  INTERFACE HIGH_FRINGE
  !     MODULE PROCEDURE HIGH_FRINGER
  !     MODULE PROCEDURE HIGH_FRINGEP       ! USE TO CREATE OTHER ELEMENTS (INTEGRATION)
  !     MODULE PROCEDURE HIGH_FRINGES
  !  END INTERFACE

  INTERFACE FRINGE_
     MODULE PROCEDURE FRINGER
     MODULE PROCEDURE FRINGEP       ! USE TO CREATE OTHER ELEMENTS (INTEGRATION)
     MODULE PROCEDURE FRINGES       ! USE TO CREATE OTHER ELEMENTS (INTEGRATION)
  END INTERFACE

  !  INTERFACE FRINGE__MULTI
  !     MODULE PROCEDURE FRINGER
  !  END INTERFACE

  INTERFACE FACE
     MODULE PROCEDURE FACER
     MODULE PROCEDURE FACEP       ! H1 AND H2 OF MAD FOR EXACT = FALSE
     MODULE PROCEDURE FACES
     MODULE PROCEDURE NEWFACER
     MODULE PROCEDURE NEWFACEP    ! H1 AND H2 OF MAD FOR EXACT = TRUE
     MODULE PROCEDURE NEWFACES
  END INTERFACE

  !  INTERFACE FACE_MULTI
  !     MODULE PROCEDURE NEWFACER
  !  END INTERFACE


  INTERFACE EDGE
     MODULE PROCEDURE EDGER
     MODULE PROCEDURE EDGEP       ! USE TO CREATE OTHER ELEMENTS (INTEGRATION)
     MODULE PROCEDURE EDGES
  END INTERFACE

  INTERFACE EDGE_TRUE_PARALLEL
     MODULE PROCEDURE EDGER_TRUE_PARALLEL
     MODULE PROCEDURE EDGEP_TRUE_PARALLEL       ! USE TO CREATE OTHER ELEMENTS (INTEGRATION)
     MODULE PROCEDURE EDGES_TRUE_PARALLEL
  END INTERFACE




  INTERFACE KICK
     MODULE PROCEDURE KICKR   ! NOT EXACT
     MODULE PROCEDURE KICKP
     MODULE PROCEDURE KICKS
  END INTERFACE

  INTERFACE KICKEX
     MODULE PROCEDURE KICKEXR !  EXACT
     MODULE PROCEDURE KICKEXP
     MODULE PROCEDURE KICKEXS
  END INTERFACE



  !  INTERFACE KICK_multi
  !     MODULE PROCEDURE KICKR
  !     MODULE PROCEDURE KICKEXR !  EXACT
  !  END INTERFACE

  INTERFACE INTE
     MODULE PROCEDURE INTER   ! NOT EXACT !MID  dkd2
     MODULE PROCEDURE INTEP   ! MID
     MODULE PROCEDURE INTES
  END INTERFACE


  INTERFACE INTE_strex
     MODULE PROCEDURE INTEEXR ! EXACT
     MODULE PROCEDURE INTEEXP
     MODULE PROCEDURE INTEEXS
  END INTERFACE

  INTERFACE KICK_SOL
     MODULE PROCEDURE KICK_SOLR
     MODULE PROCEDURE KICK_SOLP
     MODULE PROCEDURE KICK_SOLS
     MODULE PROCEDURE KICK_SOLTR
     MODULE PROCEDURE KICK_SOLTP
     MODULE PROCEDURE KICK_SOLTS
  END INTERFACE

  INTERFACE GETMULB_SOL
     MODULE PROCEDURE GETMULB_SOLR
     MODULE PROCEDURE GETMULB_SOLP
     MODULE PROCEDURE GETMULB_SOLTR
     MODULE PROCEDURE GETMULB_SOLTP
  END INTERFACE

  INTERFACE KICKMUL
     MODULE PROCEDURE KICKMULR
     MODULE PROCEDURE KICKMULP
     MODULE PROCEDURE KICKMULS
     MODULE PROCEDURE KICKMULTR
     MODULE PROCEDURE KICKMULTP
     MODULE PROCEDURE KICKMULTS
  END INTERFACE

  INTERFACE SOL_ROT
     MODULE PROCEDURE SOL_ROTR
     MODULE PROCEDURE SOL_ROTP
     MODULE PROCEDURE SOL_ROTS
  END INTERFACE

  INTERFACE INTESOL
     MODULE PROCEDURE INTESOLR
     MODULE PROCEDURE INTESOLP
     MODULE PROCEDURE INTESOLS
     MODULE PROCEDURE INTSOLR
     MODULE PROCEDURE INTSOLP
     MODULE PROCEDURE INTSOLS
  END INTERFACE

  INTERFACE SEPTTRACK
     ! ELECTROSTATIC SEPTUM
     MODULE PROCEDURE SEPR
     MODULE PROCEDURE SEPP
     MODULE PROCEDURE SEPS
  END INTERFACE
!!!! *************************************************************** !!!!
!!!! *                    slow thick element                       * !!!!
!!!! *************************************************************** !!!!

  !INTERFACE EQUAL
  !MODULE PROCEDURE copy_TKTF_TKTFP                              !
  !MODULE PROCEDURE copy_KTKP_KTK                              !
  !MODULE PROCEDURE copy_KTK_KTK                        !
  !end  INTERFACE

  INTERFACE copy
     MODULE PROCEDURE copypancake_el_elp
     MODULE PROCEDURE copypancake_elp_el
     MODULE PROCEDURE copypancake_el_el
  END INTERFACE



  INTERFACE POINTERS_pancake
     MODULE PROCEDURE POINTERS_pancakeR
     MODULE PROCEDURE POINTERS_pancakeP
  END INTERFACE

  INTERFACE ASSIGNMENT (=)
     MODULE PROCEDURE ZERO_MARTIN
     MODULE PROCEDURE ZEROr_KTK                 ! need upgrade
     MODULE PROCEDURE ZEROP_KTK                  ! need upgrade
     MODULE PROCEDURE ZEROr_TKT7                 ! need upgrade
     MODULE PROCEDURE ZEROP_TKT7                  ! need upgrade
     MODULE PROCEDURE ZEROR_teapot
     MODULE PROCEDURE ZEROP_teapot
     MODULE PROCEDURE ZEROr_mon                 ! need upgrade
     MODULE PROCEDURE ZEROP_mon                  ! need upgrade
     MODULE PROCEDURE ZEROr_RCOL                 ! need upgrade
     MODULE PROCEDURE ZEROP_RCOL                 ! need upgrade
     MODULE PROCEDURE ZEROr_ECOL                ! need upgrade
     MODULE PROCEDURE ZEROP_ECOL                  ! need upgrade
     MODULE PROCEDURE ZEROR_STREX
     MODULE PROCEDURE ZEROP_STREX
     MODULE PROCEDURE ZEROR_CAV4
     MODULE PROCEDURE ZEROP_CAV4
     MODULE PROCEDURE ZEROR_CAV_TRAV
     MODULE PROCEDURE ZEROP_CAV_TRAV
     MODULE PROCEDURE ZEROR_SOL
     MODULE PROCEDURE ZEROP_SOL
     MODULE PROCEDURE ZEROR_KICKT3
     MODULE PROCEDURE ZEROP_KICKT3
     MODULE PROCEDURE ZEROr_PANCAKE                 ! need upgrade
     MODULE PROCEDURE ZEROP_PANCAKE                  ! need upgrade
  END INTERFACE


  INTERFACE ALLOC
     MODULE PROCEDURE ALLOCKTK
     MODULE PROCEDURE ALLOCTKT7
     MODULE PROCEDURE ALLOCTEAPOT
     MODULE PROCEDURE ALLOCSOL
  END INTERFACE

  INTERFACE KILL
     MODULE PROCEDURE KILLKTK
     MODULE PROCEDURE KILLTKT7
     MODULE PROCEDURE KILLTEAPOT
     MODULE PROCEDURE KILLSOL
  END INTERFACE

  INTERFACE EXPCOSY6
     MODULE PROCEDURE EXP6R
     MODULE PROCEDURE EXP6D
  END INTERFACE

  INTERFACE GETMAT
     MODULE PROCEDURE GETMATR
     MODULE PROCEDURE GETMATD
     MODULE PROCEDURE GETMATS
  END INTERFACE

  INTERFACE INTKTK
     MODULE PROCEDURE INTKTKR
     MODULE PROCEDURE INTKTKD
     MODULE PROCEDURE INTKTKS
  END INTERFACE

  INTERFACE PUSHKTK
     MODULE PROCEDURE PUSHKTKR
     MODULE PROCEDURE PUSHKTKD
     MODULE PROCEDURE PUSHKTKS
  END INTERFACE

  INTERFACE KICKKTK
     MODULE PROCEDURE KICKKTKR
     MODULE PROCEDURE KICKKTKP
     MODULE PROCEDURE KICKKTKS
  END INTERFACE

  INTERFACE EXPCOSY
     MODULE PROCEDURE EXPR
     MODULE PROCEDURE EXPD
  END INTERFACE

  INTERFACE EXPCOSSOL
     MODULE PROCEDURE EXPSOLR
     MODULE PROCEDURE EXPSOLD
  END INTERFACE

  INTERFACE EXPCOSSOL6
     MODULE PROCEDURE EXPSOL6R
     MODULE PROCEDURE EXPSOL6D
  END INTERFACE

  INTERFACE PUSHSOL
     MODULE PROCEDURE PUSHSOLR
     MODULE PROCEDURE PUSHSOLD
     MODULE PROCEDURE PUSHSOLS
  END INTERFACE

  INTERFACE GETMATSOL
     MODULE PROCEDURE GETMATSOLR
     MODULE PROCEDURE GETMATSOLP
     MODULE PROCEDURE GETMATSOLS
  END INTERFACE

!!!! *************************************************************** !!!!
!!!! *                    fast thick element                       * !!!!
!!!! *************************************************************** !!!!


  INTERFACE EXPCOSY7
     MODULE PROCEDURE EXPR7
     MODULE PROCEDURE EXPD7
  END INTERFACE


  INTERFACE GETMAT7
     MODULE PROCEDURE GETMAT7R
     MODULE PROCEDURE GETMAT7D
  END INTERFACE

  INTERFACE PUSHTKT7
     MODULE PROCEDURE PUSHTKT7R
     MODULE PROCEDURE PUSHTKT7D
     MODULE PROCEDURE PUSHTKT7S
  END INTERFACE

  INTERFACE KICKTKT7
     MODULE PROCEDURE KICKTKT7R
     MODULE PROCEDURE KICKTKT7P
     MODULE PROCEDURE KICKTKT7S
  END INTERFACE

  INTERFACE KICKPATH
     MODULE PROCEDURE KICKPATHR
     MODULE PROCEDURE KICKPATHD
     MODULE PROCEDURE KICKPATHS
     MODULE PROCEDURE KICKPATH6R
     MODULE PROCEDURE KICKPATH6P
     MODULE PROCEDURE KICKPATH6S
     MODULE PROCEDURE KICKPATH6TR
     MODULE PROCEDURE KICKPATH6TP
     MODULE PROCEDURE KICKPATH6TS
     !     MODULE PROCEDURE KICKPATH_pancaker
     !     MODULE PROCEDURE KICKPATH_pancakep
  END INTERFACE

  INTERFACE INTTKT7
     MODULE PROCEDURE INTTKT7R
     MODULE PROCEDURE INTTKT7D
     MODULE PROCEDURE INTTKT7S
  END INTERFACE

!!!! *************************************************************** !!!!
!!!! *           Beginning of the teapot element                   * !!!!
!!!! *************************************************************** !!!!

  INTERFACE GETANBN
     MODULE PROCEDURE GETANBNR
     MODULE PROCEDURE GETANBNP
  END INTERFACE

  INTERFACE SPROT
     MODULE PROCEDURE SPROTR
     MODULE PROCEDURE SPROTP       ! USE TO CREATE OTHER ELEMENTS (INTEGRATION)
     MODULE PROCEDURE SPROTS
  END INTERFACE

  INTERFACE Ssec
     MODULE PROCEDURE SsecR
     MODULE PROCEDURE SsecP       ! EXACT SECTOR SPLIT
     MODULE PROCEDURE SsecS
  END INTERFACE

  INTERFACE SSECH1
     MODULE PROCEDURE SSECH1R
     MODULE PROCEDURE SSECH1P       ! EXACT SECTOR SPLIT
     MODULE PROCEDURE SSECH1S
  END INTERFACE

  INTERFACE SPAR
     MODULE PROCEDURE SPARR
     MODULE PROCEDURE SPARP       ! EXACT PARALLEL FACE SPLIT
     MODULE PROCEDURE SPARS
  END INTERFACE

  INTERFACE SKICK
     MODULE PROCEDURE SKICKR
     MODULE PROCEDURE SKICKP       ! USE TO CREATE OTHER ELEMENTS (INTEGRATION)
     MODULE PROCEDURE SKICKS
  END INTERFACE

  INTERFACE SINTE
     MODULE PROCEDURE SINTER
     MODULE PROCEDURE SINTEP
     MODULE PROCEDURE SINTES
  END INTERFACE


  INTERFACE wedge
     MODULE PROCEDURE wedgeR
     MODULE PROCEDURE wedgeP       ! USE IN EXACT SECTOR BEND (INTEGRATION)
     MODULE PROCEDURE wedgeS
  END INTERFACE
  INTERFACE F_M
     MODULE PROCEDURE FXR
     MODULE PROCEDURE FXP
     MODULE PROCEDURE FXS
  END INTERFACE

  INTERFACE feval
     MODULE PROCEDURE FEVAL_pancaker
     MODULE PROCEDURE FEVAL_pancakeP
     MODULE PROCEDURE FEVAL_pancakes
  END INTERFACE

  INTERFACE conv_to_xp
     MODULE PROCEDURE conv_to_xpr
     MODULE PROCEDURE conv_to_xpp
  END INTERFACE
  INTERFACE conv_to_px
     MODULE PROCEDURE conv_to_pxr
     MODULE PROCEDURE conv_to_pxp
  END INTERFACE


  INTERFACE RK4_M
     MODULE PROCEDURE rk4_pancaker
     MODULE PROCEDURE rk4_pancakeP
     MODULE PROCEDURE rk4_pancakes
  END INTERFACE



contains

  SUBROUTINE DRIFT_INTER(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: MID
    TYPE(DRIFT1),INTENT(IN):: EL
    real(dp) DH,DD
    INTEGER I
    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    SELECT CASE(EL%P%METHOD)
    CASE(2,4,6)
       DH=EL%L/EL%P%NST
       DD=EL%P%LD/EL%P%NST

       DO I=1,EL%P%NST
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO

    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

  END SUBROUTINE DRIFT_INTER





  SUBROUTINE DRIFT_INTEP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: MID
    TYPE(DRIFT1P),INTENT(IN):: EL
    TYPE(REAL_8) DH
    real(dp) DD
    INTEGER I

    ! IF(PRESENT(MID)) CALL XMID(MID,X,0)

    SELECT CASE(EL%P%METHOD)
    CASE(2,4,6)
       CALL ALLOC(DH)
       DH=EL%L/EL%P%NST
       DD=EL%P%LD/EL%P%NST

       DO I=1,EL%P%NST
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
       CALL KILL(DH)

    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

  END SUBROUTINE DRIFT_INTEP


  SUBROUTINE DRIFT_INTES(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(DRIFT1P),INTENT(IN):: EL
    TYPE(REAL_8) DH
    real(dp) DD
    INTEGER I

    SELECT CASE(EL%P%METHOD)
    CASE(2,4,6)
       CALL ALLOC(DH)
       DH=EL%L/EL%P%NST
       DD=EL%P%LD/EL%P%NST

       DO I=1,EL%P%NST
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
       ENDDO
       CALL KILL(DH)


    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

  END SUBROUTINE DRIFT_INTES

  SUBROUTINE CAVER(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: MID
    TYPE(CAV4),INTENT(INOUT):: EL
    real(dp) D,DH,DD
    real(dp) D1,D2,DK1,DK2
    real(dp) DD1,DD2
    real(dp) DF(4),DK(4),DDF(4)
    INTEGER I,J,TOTALPATH

    EL%DELTA_E=x(5)

    IF(EL%THIN) THEN
       CALL CAVITY(EL,X,MID)
       EL%DELTA_E=(X(5)-EL%DELTA_E)*EL%P%P0C
       RETURN
    ENDIF
    TOTALPATH=EL%P%TOTALPATH
    EL%P%TOTALPATH=CAVITY_TOTALPATH

    IF(EL%P%FRINGE) CALL FRINGECAV(EL,1,X)

    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    SELECT CASE(EL%P%METHOD)
    CASE(2)
       DH=EL%L/two/EL%P%NST
       D=EL%L/EL%P%NST
       DD=EL%P%LD/two/EL%P%NST

       DO I=1,EL%P%NST
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICKCAV (EL,D,X)
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
    CASE(4)
       D1=EL%L*FD1/EL%P%NST
       D2=EL%L*FD2/EL%P%NST
       DD1=EL%P%LD*FD1/EL%P%NST
       DD2=EL%P%LD*FD2/EL%P%NST
       DK1=EL%L*FK1/EL%P%NST
       DK2=EL%L*FK2/EL%P%NST

       DO I=1,EL%P%NST
          CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICKCAV (EL,DK1,X)
          CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICKCAV (EL,DK2,X)

          CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICKCAV (EL,DK1,X)
          CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO

    CASE(6)
       DO I =1,4
          DF(I)=EL%L*YOSD(I)/EL%P%NST
          DDF(I)=EL%P%LD*YOSD(I)/EL%P%NST
          DK(I)=EL%L*YOSK(I)/EL%P%NST
       ENDDO

       DO I=1,EL%P%NST
          DO J=4,2,-1
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICKCAV (EL,DK(J),X)
          ENDDO
          CALL DRIFT(DF(1),DDF(1),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICKCAV (EL,DK(1),X)

          CALL DRIFT(DF(1),DDF(1),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          DO J=2,4
             CALL KICKCAV(EL,DK(J),X)
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          ENDDO
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO


    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

    IF(EL%P%FRINGE) CALL FRINGECAV(EL,-1,X)

    EL%P%TOTALPATH=TOTALPATH

    if(EL%P%TIME) then
       X(6)=X(6)-(CAVITY_TOTALPATH-EL%P%TOTALPATH)*EL%P%LD/EL%P%BETA0
    else
       X(6)=X(6)-(CAVITY_TOTALPATH-EL%P%TOTALPATH)*EL%P%LD
    endif

    EL%DELTA_E=(X(5)-EL%DELTA_E)*EL%P%P0C

  END SUBROUTINE CAVER

  SUBROUTINE CAVEP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: MID
    TYPE(CAV4P),INTENT(INOUT):: EL
    TYPE(REAL_8) D,DH
    real(dp) DD
    TYPE(REAL_8) D1,D2,DK1,DK2
    real(dp) DD1,DD2
    TYPE(REAL_8) DF(4),DK(4)
    real(dp) DDF(4)
    INTEGER I,J,TOTALPATH

    EL%DELTA_E=x(5)
    IF(EL%THIN) THEN
       CALL CAVITY(EL,X)
       EL%DELTA_E=(X(5)-EL%DELTA_E)*EL%P%P0C
       RETURN
    ENDIF

    TOTALPATH=EL%P%TOTALPATH
    EL%P%TOTALPATH=CAVITY_TOTALPATH


    IF(EL%P%FRINGE) CALL FRINGECAV(EL,1,X)
    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    SELECT CASE(EL%P%METHOD)
    CASE(2)
       CALL ALLOC(DH)
       CALL ALLOC(D)
       DH=EL%L/two/EL%P%NST
       D=EL%L/EL%P%NST
       DD=EL%P%LD/two/EL%P%NST

       DO I=1,EL%P%NST
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICKCAV (EL,D,X)
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
       CALL KILL(DH)
       CALL KILL(D)
    CASE(4)
       CALL ALLOC(D1)
       CALL ALLOC(D2)
       CALL ALLOC(DK1)
       CALL ALLOC(DK2)
       D1=EL%L*FD1/EL%P%NST
       D2=EL%L*FD2/EL%P%NST
       DD1=EL%P%LD*FD1/EL%P%NST
       DD2=EL%P%LD*FD2/EL%P%NST
       DK1=EL%L*FK1/EL%P%NST
       DK2=EL%L*FK2/EL%P%NST

       DO I=1,EL%P%NST
          CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICKCAV (EL,DK1,X)
          CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICKCAV (EL,DK2,X)
          CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICKCAV (EL,DK1,X)
          CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
       CALL KILL(D1)
       CALL KILL(D2)
       CALL KILL(DK1)
       CALL KILL(DK2)
    CASE(6)
       CALL ALLOC(DF,4)
       CALL ALLOC(DK,4)
       DO I =1,4
          DF(I)=EL%L*YOSD(I)/EL%P%NST
          DDF(I)=EL%P%LD*YOSD(I)/EL%P%NST
          DK(I)=EL%L*YOSK(I)/EL%P%NST
       ENDDO

       DO I=1,EL%P%NST
          DO J=4,2,-1
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICKCAV (EL,DK(J),X)
          ENDDO
          CALL DRIFT(DF(1),DDF(1),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICKCAV (EL,DK(1),X)
          CALL DRIFT(DF(1),DDF(1),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          DO J=2,4
             CALL KICKCAV (EL,DK(J),X)
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          ENDDO
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
       CALL KILL(DF,4)
       CALL KILL(DK,4)


    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

    IF(EL%P%FRINGE) CALL FRINGECAV(EL,-1,X)

    EL%P%TOTALPATH=TOTALPATH

    if(EL%P%TIME) then
       X(6)=X(6)-(CAVITY_TOTALPATH-EL%P%TOTALPATH)*EL%P%LD/EL%P%BETA0
    else
       X(6)=X(6)-(CAVITY_TOTALPATH-EL%P%TOTALPATH)*EL%P%LD
    endif
    EL%DELTA_E=(X(5)-EL%DELTA_E)*EL%P%P0C

  END SUBROUTINE CAVEP


  SUBROUTINE CAVES(EL,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(CAV4P),INTENT(INOUT):: EL
    TYPE(REAL_8) X(6)

    CALL ALLOC(X,6)

    X=Y
    CALL TRACK(EL,X)
    Y=X

    CALL KILL(X,6)


  END SUBROUTINE CAVES


  SUBROUTINE CAVITYR(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: MID
    TYPE(CAV4),INTENT(INOUT):: EL

    IF(EL%P%NOCAVITY) RETURN
    IF(PRESENT(MID)) CALL XMID(MID,X,0)
    !    EL%DELTA_E=x(5)
    x(5)=x(5)-HALF*EL%P%DIR*EL%P%CHARGE*EL%volt*c_1d_3*SIN(twopi*EL%freq*x(6)/CLIGHT+EL%PHAS+phase0)/EL%P%P0C

    IF(PRESENT(MID)) CALL XMID(MID,X,1)
    x(5)=x(5)-HALF*EL%P%DIR*EL%P%CHARGE*EL%volt*c_1d_3*SIN(twopi*EL%freq*x(6)/CLIGHT+EL%PHAS+phase0)/EL%P%P0C
    !    EL%DELTA_E=(X(5)-EL%DELTA_E)*EL%P%P0C
    IF(PRESENT(MID)) CALL XMID(MID,X,1)

  END SUBROUTINE CAVITYR

  SUBROUTINE CAVITYP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: MID
    TYPE(CAV4P),INTENT(INOUT):: EL

    IF(EL%P%NOCAVITY) RETURN
    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)
    !    EL%DELTA_E=x(5)
    x(5)=x(5)-HALF*EL%P%DIR*EL%P%CHARGE*EL%volt*c_1d_3*SIN(twopi*EL%freq*x(6)/CLIGHT+EL%PHAS+phase0)/EL%P%P0C
    !    IF(PRESENT(MID)) CALL XMID(MID,X,1)
    x(5)=x(5)-HALF*EL%P%DIR*EL%P%CHARGE*EL%volt*c_1d_3*SIN(twopi*EL%freq*x(6)/CLIGHT+EL%PHAS+phase0)/EL%P%P0C
    !    EL%DELTA_E=(X(5)-EL%DELTA_E)*EL%P%P0C
    !    IF(PRESENT(MID)) CALL XMID(MID,X,1)

  END SUBROUTINE CAVITYP


  SUBROUTINE CAVITYS(EL,Y)
    IMPLICIT NONE
    TYPE(REAL_8)  X(6)
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(CAV4P),INTENT(INOUT):: EL

    IF(EL%P%NOCAVITY) RETURN
    CALL ALLOC(X,6)
    X=Y
    !    EL%DELTA_E=x(5)
    !x(5)=x(5)-EL%volt*SIN(EL%freq*x(6)+EL%PHAS+phase0)/EL%P%P0C
    x(5)=x(5)-EL%P%DIR*EL%P%CHARGE*EL%volt*c_1d_3*SIN(twopi*EL%freq*x(6)/CLIGHT+EL%PHAS+phase0)/EL%P%P0C
    !    EL%DELTA_E=(X(5)-EL%DELTA_E)*EL%P%P0C
    Y=X
    CALL KILL(X,6)
  END SUBROUTINE CAVITYS



  SUBROUTINE FRINGECAVR(EL,I,X)
    IMPLICIT NONE
    REAL(DP),INTENT(INOUT):: X(6)
    TYPE(CAV4),INTENT(INOUT):: EL
    integer, intent(in) :: i
    REAL(DP) C1,S1,V,O

    IF(EL%P%NOCAVITY) RETURN

    IF(I==1.AND.EL%P%KILL_ENT_FRINGE) RETURN
    IF(I==-1.AND.EL%P%KILL_EXI_FRINGE) RETURN


    O=EL%freq*twopi/CLIGHT
    C1=COS(O*(x(6))+EL%PHAS+phase0)
    S1=SIN(O*(x(6))+EL%PHAS+phase0)
    V=I*EL%P%CHARGE*EL%volt*c_1d_3/EL%P%P0C



    X(2)=X(2)+V*S1*X(1)
    X(4)=X(4)+V*S1*X(3)
    x(5)=x(5)-HALF*(X(1)**2+X(3)**2)*V*C1*O



  END SUBROUTINE FRINGECAVR

  SUBROUTINE FRINGECAVP(EL,I,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(CAV4P),INTENT(INOUT):: EL
    integer, intent(in) :: i
    TYPE(REAL_8) C1,S1,V,O,F

    IF(EL%P%NOCAVITY) RETURN

    IF(I==1.AND.EL%P%KILL_ENT_FRINGE) RETURN
    IF(I==-1.AND.EL%P%KILL_EXI_FRINGE) RETURN

    CALL ALLOC(C1,S1,V,O,F)

    O=EL%freq*twopi/CLIGHT
    C1=COS(O*(x(6))+EL%PHAS+phase0)
    S1=SIN(O*(x(6))+EL%PHAS+phase0)
    V=I*EL%P%CHARGE*EL%volt*c_1d_3/EL%P%P0C



    X(2)=X(2)+V*S1*X(1)
    X(4)=X(4)+V*S1*X(3)
    x(5)=x(5)-HALF*(X(1)**2+X(3)**2)*V*C1*O

    CALL KILL(C1,S1,V,O,F)

  END SUBROUTINE FRINGECAVP

  SUBROUTINE FRINGECAVS(EL,I,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(REAL_8)  X(6)
    TYPE(CAV4P),INTENT(INOUT):: EL
    integer, intent(in) :: i

    CALL ALLOC(X)
    X=Y
    CALL FRINGECAV(EL,I,X)
    Y=X

    CALL KILL(X)
  END SUBROUTINE FRINGECAVS

  SUBROUTINE KICKCAVR(EL,YL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    real(dp),INTENT(INOUT):: YL
    TYPE(CAV4),INTENT(INOUT):: EL
    real(dp) DF,R2,F,DR2,O,VL
    INTEGER I

    IF(EL%P%NOCAVITY) RETURN

    O=twopi*EL%freq/CLIGHT
    VL=EL%P%DIR*EL%P%CHARGE*YL*EL%volt*c_1d_3/EL%P%P0C

    DF=ZERO
    F=ONE
    R2=ONE

    DO I=1,EL%N_BESSEL
       R2=-R2*O**2/FOUR/(I+1)**2
       DR2=R2*I
       DF=DF+DR2*2
       R2=R2*(X(1)**2+X(3)**2)
       F=F+R2
    ENDDO

    !    EL%DELTA_E=x(5)

    IF(EL%N_BESSEL>0) THEN
       X(2)=X(2)-X(1)*DF*VL*COS(O*X(6)+EL%PHAS+phase0)/O
       X(4)=X(4)-X(3)*DF*VL*COS(O*X(6)+EL%PHAS+phase0)/O
    ENDIF


    x(5)=x(5)-F*VL*SIN(O*x(6)+EL%PHAS+phase0)

    !    EL%DELTA_E=(X(5)-EL%DELTA_E)*EL%P%P0C


  END SUBROUTINE KICKCAVR

  SUBROUTINE KICKCAVP(EL,YL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6),YL
    TYPE(CAV4P),INTENT(INOUT):: EL
    TYPE(REAL_8) DF,R2,F,DR2,O,VL
    INTEGER I

    IF(EL%P%NOCAVITY) RETURN

    CALL ALLOC(DF,R2,F,DR2,O,VL)

    O=twopi*EL%freq/CLIGHT
    VL=EL%P%DIR*EL%P%CHARGE*YL*EL%volt*c_1d_3/EL%P%P0C

    DF=ZERO
    F=ONE
    R2=ONE

    DO I=1,EL%N_BESSEL
       R2=-R2*O**2/FOUR/(I+1)**2
       DR2=R2*I
       DF=DF+DR2*2
       R2=R2*(X(1)**2+X(3)**2)
       F=F+R2
    ENDDO

    !    EL%DELTA_E=x(5)

    IF(EL%N_BESSEL>0) THEN
       X(2)=X(2)-X(1)*DF*VL*COS(O*X(6)+EL%PHAS+phase0)/O
       X(4)=X(4)-X(3)*DF*VL*COS(O*X(6)+EL%PHAS+phase0)/O
    ENDIF


    x(5)=x(5)-F*VL*SIN(O*x(6)+EL%PHAS+phase0)

    !    EL%DELTA_E=(X(5)-EL%DELTA_E)*EL%P%P0C

    CALL KILL(DF,R2,F,DR2,O,VL)

  END SUBROUTINE KICKCAVP


  SUBROUTINE KICKCAVS(EL,YL,Y)
    IMPLICIT NONE
    TYPE(REAL_8)  X(6)
    TYPE(REAL_8),INTENT(INOUT):: YL
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(CAV4P),INTENT(INOUT):: EL

    CALL ALLOC(X,6)
    X=Y
    CALL KICKCAV(EL,YL,X)
    Y=X
    CALL KILL(X,6)

  END SUBROUTINE KICKCAVS



  ! STUFF NEEDED FOR INTEGRATION
  SUBROUTINE DRIFTR(L,LD,b,T,EXACT,CTIME,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    real(dp),INTENT(IN):: L
    real(dp), INTENT(IN):: LD
    INTEGER,INTENT(IN):: T
    real(dp) PZ,b
    logical(lp) EXACT,CTIME


    IF(EXACT) THEN
       if(CTIME) then
          PZ=ROOT(one+two*X(5)/b+x(5)**2-X(2)**2-X(4)**2)
          X(1)=X(1)+L*X(2)/PZ
          X(3)=X(3)+L*X(4)/PZ
          X(6)=X(6)+L*(one/b+X(5))/PZ-(1-T)*LD/b
       else
          PZ=ROOT((one+X(5))**2-X(2)**2-X(4)**2)
          X(1)=X(1)+L*X(2)/PZ
          X(3)=X(3)+L*X(4)/PZ
          X(6)=X(6)+L*(one+X(5))/PZ-(1-T)*LD
       endif
    ELSE
       if(CTIME) then
          PZ=ROOT(one+two*X(5)/b+x(5)**2)
          X(1)=X(1)+L*X(2)/pz
          X(3)=X(3)+L*X(4)/pz
          ! bug found by Schmidt totalpath=false time=true
          !          X(6)=X(6)+((X(2)*X(2)+X(4)*X(4))/two/pz**2+T)*(one/b+x(5))*L/pz
          X(6)=X(6)+((X(2)*X(2)+X(4)*X(4))/two/pz**2+one)*(one/b+x(5))*L/pz
          X(6)=X(6)-(1-T)*L/B
       else
          X(1)=X(1)+L*X(2)/(one+X(5))
          X(3)=X(3)+L*X(4)/(one+X(5))
          X(6)=X(6)+(L/(one+X(5)))*(X(2)*X(2)+X(4)*X(4))/two/(one+X(5))+T*L
       endif
    ENDIF

  END SUBROUTINE DRIFTR

  SUBROUTINE DRIFTP(L,LD,b,T,EXACT,ctime,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(REAL_8),INTENT(IN):: L
    real(dp), INTENT(IN):: LD
    INTEGER,INTENT(IN):: T
    TYPE(REAL_8) PZ
    logical(lp) EXACT,ctime
    real(dp) b

    IF(EXACT) THEN
       CALL ALLOC(PZ)
       if(ctime) then
          PZ=SQRT(one+two*X(5)/b+x(5)**2-X(2)**2-X(4)**2)
          X(1)=X(1)+L*X(2)/PZ
          X(3)=X(3)+L*X(4)/PZ
          X(6)=X(6)+L*(one/b+X(5))/PZ-(1-T)*LD/b
       else
          PZ=SQRT((one+X(5))**2-X(2)**2-X(4)**2)
          X(1)=X(1)+L*X(2)/PZ
          X(3)=X(3)+L*X(4)/PZ
          X(6)=X(6)+L*(one+X(5))/PZ-(1-T)*LD
       endif
       CALL KILL(PZ)
    ELSE
       if(ctime) then
          CALL ALLOC(PZ)
          PZ=SQRT(one+two*X(5)/b+x(5)**2)
          X(1)=X(1)+L*X(2)/pz
          X(3)=X(3)+L*X(4)/pz
          ! bug found by Schmidt totalpath=false time=true
          !          X(6)=X(6)+((X(2)*X(2)+X(4)*X(4))/two/pz**2+T)*(one/b+x(5))*L/pz
          X(6)=X(6)+((X(2)*X(2)+X(4)*X(4))/two/pz**2+one)*(one/b+x(5))*L/pz
          X(6)=X(6)-(1-T)*L/B
          CALL KILL(PZ)
       else
          X(1)=X(1)+L*X(2)/(one+X(5))
          X(3)=X(3)+L*X(4)/(one+X(5))
          X(6)=X(6)+(L/(one+X(5)))*(X(2)*X(2)+X(4)*X(4))/two/(one+X(5))+T*L
       endif
    ENDIF

  END SUBROUTINE DRIFTP

  SUBROUTINE DRIFTS(L,LD,b,T,EXACT,ctime,Y)
    IMPLICIT NONE
    TYPE(REAL_8)   X(6)
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(REAL_8),INTENT(IN):: L
    real(dp), INTENT(IN):: LD
    INTEGER,INTENT(IN):: T
    TYPE(REAL_8) PZ
    logical(lp) EXACT,ctime
    real(dp) b
    CALL ALLOC(X,6)
    X=Y
    IF(EXACT) THEN
       CALL ALLOC(PZ)
       if(ctime) then
          PZ=SQRT(one+two*X(5)/b+x(5)**2-X(2)**2-X(4)**2)
          X(1)=X(1)+L*X(2)/PZ
          X(3)=X(3)+L*X(4)/PZ
          X(6)=X(6)+L*(one/b+X(5))/PZ-(1-T)*LD/b
       else
          PZ=SQRT((one+X(5))**2-X(2)**2-X(4)**2)
          X(1)=X(1)+L*X(2)/PZ
          X(3)=X(3)+L*X(4)/PZ
          X(6)=X(6)+L*(one+X(5))/PZ-(1-T)*LD
       endif
       CALL KILL(PZ)
    ELSE
       if(ctime) then
          CALL ALLOC(PZ)
          PZ=SQRT(one+two*X(5)/b+x(5)**2)
          X(1)=X(1)+L*X(2)/pz
          X(3)=X(3)+L*X(4)/pz
          ! bug found by Schmidt totalpath=false time=true
          !          X(6)=X(6)+((X(2)*X(2)+X(4)*X(4))/two/pz**2+T)*(one/b+x(5))*L/pz
          X(6)=X(6)+((X(2)*X(2)+X(4)*X(4))/two/pz**2+one)*(one/b+x(5))*L/pz
          X(6)=X(6)-(1-T)*L/B
          CALL KILL(PZ)
       else
          X(1)=X(1)+L*X(2)/(one+X(5))
          X(3)=X(3)+L*X(4)/(one+X(5))
          X(6)=X(6)+(L/(one+X(5)))*(X(2)*X(2)+X(4)*X(4))/two/(one+X(5))+T*L
       endif
    ENDIF
    Y=X
    CALL KILL(X,6)

  END SUBROUTINE DRIFTS

  SUBROUTINE KICKTR(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: MID
    TYPE(KICKT3),INTENT(IN):: EL
    real(dp) X1,X3,BBYTW,BBXTW,BBYTWT,pz
    INTEGER J



    X1=X(1)
    X3=X(3)

    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF

    IF(PRESENT(MID)) THEN
       CALL XMID(MID,X,0)
       if(EL%P%TIME) then
          PZ=SQRT(one+two*X(5)/EL%P%BETA0+x(5)**2)
          X(2)=X(2)-EL%thin_h_foc*x1*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_h_angle*(PZ-one)*HALF  ! highly illegal additions by frs
          X(4)=X(4)-EL%thin_v_foc*x3*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_v_angle*(PZ-one)*HALF  ! highly illegal additions by frs
          X(6)=X(6)+EL%P%DIR*EL%P%CHARGE*(EL%thin_h_angle*x1+EL%thin_v_angle*x3)*(one/EL%P%BETA0+x(5))/pz*HALF
       else
          X(2)=X(2)-EL%thin_h_foc*x1*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_h_angle*x(5)*HALF  ! highly illegal additions by frs
          X(4)=X(4)-EL%thin_v_foc*x3*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_v_angle*x(5)*HALF  ! highly illegal additions by frs
          X(6)=X(6)+EL%P%DIR*EL%P%CHARGE*(EL%thin_h_angle*x1+EL%thin_v_angle*x3)*HALF
       endif
       X(2)=X(2)-EL%P%DIR*EL%P%CHARGE*BBYTW*HALF
       X(4)=X(4)+EL%P%DIR*EL%P%CHARGE*BBXTW*HALF

       CALL XMID(MID,X,1)

       if(EL%P%TIME) then
          PZ=SQRT(one+two*X(5)/EL%P%BETA0+x(5)**2)
          X(2)=X(2)-EL%thin_h_foc*x1*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_h_angle*(PZ-one)*HALF  ! highly illegal additions by frs
          X(4)=X(4)-EL%thin_v_foc*x3*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_v_angle*(PZ-one)*HALF  ! highly illegal additions by frs
          X(6)=X(6)+EL%P%DIR*EL%P%CHARGE*(EL%thin_h_angle*x1+EL%thin_v_angle*x3)*(one/EL%P%BETA0+x(5))/pz*HALF
       else
          X(2)=X(2)-EL%thin_h_foc*x1*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_h_angle*x(5)*HALF  ! highly illegal additions by frs
          X(4)=X(4)-EL%thin_v_foc*x3*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_v_angle*x(5)*HALF  ! highly illegal additions by frs
          X(6)=X(6)+EL%P%DIR*EL%P%CHARGE*(EL%thin_h_angle*x1+EL%thin_v_angle*x3)*HALF
       endif
       X(2)=X(2)-EL%P%DIR*EL%P%CHARGE*BBYTW*HALF
       X(4)=X(4)+EL%P%DIR*EL%P%CHARGE*BBXTW*HALF
       CALL XMID(MID,X,1)
    ELSE
       if(EL%P%TIME) then
          PZ=SQRT(one+two*X(5)/EL%P%BETA0+x(5)**2)
          X(2)=X(2)-EL%thin_h_foc*x1+EL%P%DIR*EL%P%CHARGE*EL%thin_h_angle*(PZ-one)  ! highly illegal additions by frs
          X(4)=X(4)-EL%thin_v_foc*x3+EL%P%DIR*EL%P%CHARGE*EL%thin_v_angle*(PZ-one)  ! highly illegal additions by frs
          X(6)=X(6)+EL%P%DIR*EL%P%CHARGE*(EL%thin_h_angle*x1+EL%thin_v_angle*x3)*(one/EL%P%BETA0+x(5))/pz
       else
          X(2)=X(2)-EL%thin_h_foc*x1+EL%P%DIR*EL%P%CHARGE*EL%thin_h_angle*x(5)  ! highly illegal additions by frs
          X(4)=X(4)-EL%thin_v_foc*x3+EL%P%DIR*EL%P%CHARGE*EL%thin_v_angle*x(5)  ! highly illegal additions by frs
          X(6)=X(6)+EL%P%DIR*EL%P%CHARGE*(EL%thin_h_angle*x1+EL%thin_v_angle*x3)
       endif

       X(2)=X(2)-EL%P%DIR*EL%P%CHARGE*BBYTW     ! BACKWARDS
       X(4)=X(4)+EL%P%DIR*EL%P%CHARGE*BBXTW     ! BACKWARDS
    ENDIF




  END SUBROUTINE KICKTR

  SUBROUTINE KICKTP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: MID
    TYPE(KICKT3P),INTENT(IN):: EL
    TYPE(REAL_8) X1,X3,BBYTW,BBXTW,BBYTWT
    TYPE(REAL_8) pz
    INTEGER J
    CALL ALLOC(X1)
    CALL ALLOC(X3)
    CALL ALLOC(BBYTW)
    CALL ALLOC(BBXTW)
    CALL ALLOC(BBYTWT)


    X1=X(1)
    X3=X(3)


    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF

    !    IF(PRESENT(MID)) THEN
    !       CALL XMID(MID,X,0)
    !       if(EL%P%TIME) then
    !          call alloc(pz)
    !          PZ=SQRT(one+two*X(5)/EL%P%BETA0+x(5)**2)
    !          X(2)=X(2)-EL%thin_h_foc*x1*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_h_angle*(PZ-one)*HALF  ! highly illegal additions by frs
    !          X(4)=X(4)-EL%thin_v_foc*x3*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_v_angle*(PZ-one)*HALF  ! highly illegal additions by frs
    !          X(6)=X(6)+EL%P%DIR*EL%P%CHARGE*(EL%thin_h_angle*x1+EL%thin_v_angle*x3)*(one/EL%P%BETA0+x(5))/pz*HALF
    !          call kill(pz)
    !       else
    !          X(2)=X(2)-EL%thin_h_foc*x1*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_h_angle*x(5)*HALF  ! highly illegal additions by frs
    !          X(4)=X(4)-EL%thin_v_foc*x3*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_v_angle*x(5)*HALF  ! highly illegal additions by frs
    !          X(6)=X(6)+EL%P%DIR*EL%P%CHARGE*(EL%thin_h_angle*x1+EL%thin_v_angle*x3)*HALF
    !       endif
    !      X(2)=X(2)-EL%P%DIR*EL%P%CHARGE*BBYTW*HALF
    !       X(4)=X(4)+EL%P%DIR*EL%P%CHARGE*BBXTW*HALF
    !
    !!       CALL XMID(MID,X,1)
    !
    !       if(EL%P%TIME) then
    !          call alloc(pz)
    !          PZ=SQRT(one+two*X(5)/EL%P%BETA0+x(5)**2)
    !          X(2)=X(2)-EL%thin_h_foc*x1*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_h_angle*(PZ-one)*HALF  ! highly illegal additions by frs
    !          X(4)=X(4)-EL%thin_v_foc*x3*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_v_angle*(PZ-one)*HALF  ! highly illegal additions by frs
    !          X(6)=X(6)+EL%P%DIR*EL%P%CHARGE*(EL%thin_h_angle*x1+EL%thin_v_angle*x3)*(one/EL%P%BETA0+x(5))/pz*HALF
    !          call kill(pz)
    !       else
    !          X(2)=X(2)-EL%thin_h_foc*x1*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_h_angle*x(5)*HALF  ! highly illegal additions by frs
    !          X(4)=X(4)-EL%thin_v_foc*x3*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_v_angle*x(5)*HALF  ! highly illegal additions by frs
    !          X(6)=X(6)+EL%P%DIR*EL%P%CHARGE*(EL%thin_h_angle*x1+EL%thin_v_angle*x3)*HALF
    !       endif
    !       X(2)=X(2)-EL%P%DIR*EL%P%CHARGE*BBYTW*HALF
    !       X(4)=X(4)+EL%P%DIR*EL%P%CHARGE*BBXTW*HALF
    !!       CALL XMID(MID,X,1)
    !    ELSE
    if(EL%P%TIME) then
       call alloc(pz)
       PZ=SQRT(one+two*X(5)/EL%P%BETA0+x(5)**2)
       X(2)=X(2)-EL%thin_h_foc*x1+EL%P%DIR*EL%P%CHARGE*EL%thin_h_angle*(PZ-one)  ! highly illegal additions by frs
       X(4)=X(4)-EL%thin_v_foc*x3+EL%P%DIR*EL%P%CHARGE*EL%thin_v_angle*(PZ-one)  ! highly illegal additions by frs
       X(6)=X(6)+EL%P%DIR*EL%P%CHARGE*(EL%thin_h_angle*x1+EL%thin_v_angle*x3)*(one/EL%P%BETA0+x(5))/pz
       call kill(pz)
    else
       X(2)=X(2)-EL%thin_h_foc*x1+EL%P%DIR*EL%P%CHARGE*EL%thin_h_angle*x(5)  ! highly illegal additions by frs
       X(4)=X(4)-EL%thin_v_foc*x3+EL%P%DIR*EL%P%CHARGE*EL%thin_v_angle*x(5)  ! highly illegal additions by frs
       X(6)=X(6)+EL%P%DIR*EL%P%CHARGE*(EL%thin_h_angle*x1+EL%thin_v_angle*x3)
    endif

    X(2)=X(2)-EL%P%DIR*EL%P%CHARGE*BBYTW     ! BACKWARDS
    X(4)=X(4)+EL%P%DIR*EL%P%CHARGE*BBXTW     ! BACKWARDS
    !    ENDIF




    CALL KILL(X1)
    CALL KILL(X3)
    CALL KILL(BBYTW)
    CALL KILL(BBXTW)
    CALL KILL(BBYTWT)

  END SUBROUTINE KICKTP

  SUBROUTINE KICKTS(EL,Y)
    IMPLICIT NONE
    TYPE(REAL_8)  X(6)
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(KICKT3P),INTENT(IN):: EL
    TYPE(REAL_8) X1,X3,BBYTW,BBXTW,BBYTWT
    TYPE(REAL_8) pz
    INTEGER J
    CALL ALLOC(X1)
    CALL ALLOC(X3)
    CALL ALLOC(BBYTW)
    CALL ALLOC(BBXTW)
    CALL ALLOC(BBYTWT)
    CALL ALLOC(X,6)

    X=Y

    X1=X(1)
    X3=X(3)

    if(EL%P%TIME) then
       call alloc(pz)
       PZ=SQRT(one+two*X(5)/EL%P%BETA0+x(5)**2)
       X(2)=X(2)-EL%thin_h_foc*x1*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_h_angle*(PZ-one)  ! highly illegal additions by frs
       X(4)=X(4)-EL%thin_v_foc*x3*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_v_angle*(PZ-one)  ! highly illegal additions by frs
       X(6)=X(6)+EL%P%DIR*EL%P%CHARGE*(EL%thin_h_angle*x1+EL%thin_v_angle*x3)*(one/EL%P%BETA0+x(5))/pz
       call kill(pz)
    else
       X(2)=X(2)-EL%thin_h_foc*x1*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_h_angle*x(5)  ! highly illegal additions by frs
       X(4)=X(4)-EL%thin_v_foc*x3*HALF +EL%P%DIR*EL%P%CHARGE*EL%thin_v_angle*x(5)  ! highly illegal additions by frs
       X(6)=X(6)+EL%P%DIR*EL%P%CHARGE*(EL%thin_h_angle*x1+EL%thin_v_angle*x3)
    endif

    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF

    X(2)=X(2)-EL%P%DIR*EL%P%CHARGE*BBYTW     ! BACKWARDS
    X(4)=X(4)+EL%P%DIR*EL%P%CHARGE*BBXTW     ! BACKWARDS

    Y=X

    CALL KILL(X,6)
    CALL KILL(X1)
    CALL KILL(X3)
    CALL KILL(BBYTW)
    CALL KILL(BBXTW)
    CALL KILL(BBYTWT)

  END SUBROUTINE KICKTS




  SUBROUTINE MULTIPOLE_FRINGER(EL,AN,BN,K,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    real(dp),INTENT(IN),dimension(:)::AN,BN
    TYPE(MAGNET_CHART),INTENT(IN):: EL
    INTEGER, INTENT(IN) :: K
    real(dp) A,B,C,D,DEL,X2
    INTEGER I,J
    real(dp) RX,IX,DRX,DIX,U,V,DU,DV,NF
    real(dp) DUX,DUY,DVX,DVY,FX_X,FX_Y,FY_X,FY_Y,FX,FY

    IF(EL%NMUL<=1) RETURN

    IF(K==1.AND.EL%KILL_ENT_FRINGE) RETURN
    IF(K==2.AND.EL%KILL_EXI_FRINGE) RETURN


    IF(K==1) THEN
       I= EL%CHARGE
    ELSE
       I=-EL%CHARGE
    ENDIF

    FX=ZERO
    FY=ZERO
    FX_X=ZERO
    FX_Y=ZERO
    FY_X=ZERO
    FY_Y=ZERO

    RX=ONE
    IX=ZERO

    !   RX=X(1)
    !   IX=X(3)

    DO J=1,MIN(EL%NMUL,HIGHEST_FRINGE)
       DRX=  RX
       DIX=  IX
       RX =  DRX*X(1)-DIX*X(3)
       IX =  DRX*X(3)+DIX*X(1)    ! COMPUTING (X+IY)**J

       IF(J==1.AND.EL%BEND_FRINGE) THEN
          U =     -  AN(J)*IX
          V =     +  AN(J)*RX
          DU =    -  AN(J)*DIX
          DV =    +  AN(J)*DRX
       ELSE
          U =   BN(J)*RX   -  AN(J)*IX
          V =   BN(J)*IX   +  AN(J)*RX
          DU =  BN(J)*DRX  -  AN(J)*DIX
          DV =  BN(J)*DIX  +  AN(J)*DRX
       ENDIF

       U  = (-I/FOUR/(J+1))*U
       V  = (-I/FOUR/(J+1))*V
       DU = (-I/FOUR/(J+1))*DU
       DV = (-I/FOUR/(J+1))*DV

       DUX = J*DU
       DVX = J*DV
       DUY =-J*DV
       DVY = J*DU

       NF= REAL(J+2,kind=DP)/ REAL(J,kind=DP)

       FX=FX+( U*X(1) + NF*V*X(3))
       FY=FY+( U*X(3) - NF*V*X(1))

       FX_X=FX_X+ (DUX*X(1)+U+NF*X(3)*DVX)
       FX_Y=FX_Y+ (DUY*X(1)+NF*V+NF*X(3)*DVY)

       FY_X=FY_X+ (DUX*X(3)-NF*V-NF*X(1)*DVX)
       FY_Y=FY_Y+ (DUY*X(3)+U-NF*X(1)*DVY)

    ENDDO

    if(EL%TIME) then
       del=one/ROOT(one+two*X(5)/el%beta0+x(5)**2)
    else
       DEL=one/(one+X(5))
    endif




    A=one-FX_X*DEL
    B=-FY_X*DEL
    D=one-FY_Y*DEL
    C=-FX_Y*DEL

    X(1)=X(1)-FX*DEL
    X2=(D*X(2)-B*X(4))/(A*D-B*C)
    X(4)=(A*X(4)-C*X(2))/(A*D-B*C)
    X(2)=X2
    X(3)=X(3)-FY*DEL
    if(EL%TIME) then
       X(6)=X(6)-(one/el%beta0+x(5))*(X(2)*FX+X(4)*FY)*DEL**3
    else
       X(6)=X(6)-(X(2)*FX+X(4)*FY)*DEL**2
    endif
    !    CALL CHECK_STABILITY(X)
    call check_root_drift(el,X)
  END SUBROUTINE MULTIPOLE_FRINGER

  SUBROUTINE MULTIPOLE_FRINGEP(EL,AN,BN,K,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(REAL_8),INTENT(IN),dimension(:)::AN,BN
    TYPE(MAGNET_CHART),INTENT(IN):: EL
    INTEGER, INTENT(IN) :: K
    INTEGER I,J
    TYPE(REAL_8) A,B,C,D,DEL,X2
    TYPE(REAL_8) RX,IX,DRX,DIX,U,V,DU,DV
    TYPE(REAL_8) DUX,DUY,DVX,DVY,FX_X,FX_Y,FY_X,FY_Y,FX,FY
    REAL(DP) NF



    IF(EL%NMUL<=1) RETURN

    IF(K==1.AND.EL%KILL_ENT_FRINGE) RETURN
    IF(K==2.AND.EL%KILL_EXI_FRINGE) RETURN

    CALL ALLOC(DUX,DUY,DVX,DVY,FX_X,FX_Y,FY_X,FY_Y,FX,FY)
    CALL ALLOC(RX,IX,DRX,DIX,U,V,DU,DV)
    CALL ALLOC(A,B,C,D,DEL,X2)

    IF(K==1) THEN
       I= EL%CHARGE
    ELSE
       I=-EL%CHARGE
    ENDIF

    FX=ZERO
    FY=ZERO
    FX_X=ZERO
    FX_Y=ZERO
    FY_X=ZERO
    FY_Y=ZERO
    RX=ONE
    IX=ZERO

    !   RX=X(1)
    !   IX=X(3)

    DO J=1,MIN(EL%NMUL,HIGHEST_FRINGE)
       DRX=  RX
       DIX=  IX
       RX =  DRX*X(1)-DIX*X(3)
       IX =  DRX*X(3)+DIX*X(1)    ! COMPUTING (X+IY)**J

       IF(J==1.AND.EL%BEND_FRINGE) THEN
          U =     -  AN(J)*IX
          V =     +  AN(J)*RX
          DU =    -  AN(J)*DIX
          DV =    +  AN(J)*DRX
       ELSE
          U =   BN(J)*RX   -  AN(J)*IX
          V =   BN(J)*IX   +  AN(J)*RX
          DU =  BN(J)*DRX  -  AN(J)*DIX
          DV =  BN(J)*DIX  +  AN(J)*DRX
       ENDIF

       U  = (-I/FOUR/(J+1))*U
       V  = (-I/FOUR/(J+1))*V
       DU = (-I/FOUR/(J+1))*DU
       DV = (-I/FOUR/(J+1))*DV

       DUX = J*DU
       DVX = J*DV
       DUY =-J*DV
       DVY = J*DU

       NF= REAL(J+2,kind=DP)/ REAL(J,kind=DP)

       FX=FX+( U*X(1) + NF*V*X(3))
       FY=FY+( U*X(3) - NF*V*X(1))

       FX_X=FX_X+ (DUX*X(1)+U+NF*X(3)*DVX)
       FX_Y=FX_Y+ (DUY*X(1)+NF*V+NF*X(3)*DVY)

       FY_X=FY_X+ (DUX*X(3)-NF*V-NF*X(1)*DVX)
       FY_Y=FY_Y+ (DUY*X(3)+U-NF*X(1)*DVY)

    ENDDO

    if(EL%TIME) then
       del=one/SQRT(one+two*X(5)/el%beta0+x(5)**2)
    else
       DEL=one/(one+X(5))
    endif




    A=one-FX_X*DEL
    B=-FY_X*DEL
    D=one-FY_Y*DEL
    C=-FX_Y*DEL

    X(1)=X(1)-FX*DEL
    X2=(D*X(2)-B*X(4))/(A*D-B*C)
    X(4)=(A*X(4)-C*X(2))/(A*D-B*C)
    X(2)=X2
    X(3)=X(3)-FY*DEL
    if(EL%TIME) then
       X(6)=X(6)-(one/el%beta0+x(5))*(X(2)*FX+X(4)*FY)*DEL**3
    else
       X(6)=X(6)-(X(2)*FX+X(4)*FY)*DEL**2
    endif

    CALL KILL(DUX,DUY,DVX,DVY,FX_X,FX_Y,FY_X,FY_Y,FX,FY)
    CALL KILL(RX,IX,DRX,DIX,U,V,DU,DV)
    CALL KILL(A,B,C,D,DEL,X2)


  END SUBROUTINE MULTIPOLE_FRINGEP

  SUBROUTINE MULTIPOLE_FRINGES(EL,AN,BN,K,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(REAL_8),INTENT(IN),dimension(:)::AN,BN
    TYPE(MAGNET_CHART),INTENT(IN):: EL
    INTEGER, INTENT(IN) :: K
    TYPE(REAL_8)  X(6)

    CALL ALLOC(X,6)
    X=Y
    CALL MULTIPOLE_FRINGE(EL,AN,BN,K,X)
    Y=X
    CALL KILL(X,6)

  END SUBROUTINE MULTIPOLE_FRINGES


  SUBROUTINE NEWFACER(EL,BN,H,X)
    IMPLICIT NONE
    TYPE(MAGNET_CHART),INTENT(IN):: EL
    real(dp),INTENT(INOUT):: X(6)
    real(dp),INTENT(IN)::H
    real(dp),INTENT(IN),dimension(:)::BN
    real(dp) XI,PM,DXI_PX,DXI_DDEL

    IF(EL%DIR==1) THEN   ! NOT IMPORTANT; JUST TO INSURE REVERSAL SYMMETRY
       ! HORIZONTAL WEDGE
       X(2)=X(2)+(EL%DIR*EL%CHARGE*BN(1)*H/TWO)*X(1)**2
    ENDIF

    IF(EL%TIME) THEN
       PM=ROOT(ONE+TWO*X(5)/el%beta0+x(5)**2-X(2)**2)
       XI=EL%DIR*EL%CHARGE*ROOT(ONE+TWO*X(5)/el%beta0+x(5)**2)*BN(1)*H/PM**2
       DXI_PX=TWO*X(2)/PM**2 * XI
       DXI_DDEL=-TWO*(ONE+X(5))/PM**2 * XI
    ELSE
       PM=ROOT((ONE+X(5))**2-X(2)**2)
       XI=EL%DIR*EL%CHARGE*(ONE+X(5))*BN(1)*H/PM**2
       DXI_PX=TWO*X(2)/PM**2 * XI
       DXI_DDEL=-TWO*(ONE/EL%BETA0+X(5))/PM**2 * XI
    ENDIF

    X(1)=X(1)/(ONE-DXI_PX*X(3)**2)
    X(2)=X(2)-XI*X(3)**2
    X(4)=X(4)-TWO*XI*X(1)*X(3)
    X(6)=X(6)-DXI_DDEL*X(1)*X(3)**2

    IF(EL%DIR==-1) THEN   ! NOT IMPORTANT; JUST TO INSURE REVERSAL SYMMETRY
       ! HORIZONTAL WEDGE
       X(2)=X(2)+(EL%DIR*EL%CHARGE*BN(1)*H/TWO)*X(1)**2
    ENDIF
    !    CALL check_stability(X)
    call check_root_drift(el,X)
  END SUBROUTINE NEWFACER

  SUBROUTINE NEWFACEP(EL,BN,H,X)
    IMPLICIT NONE
    TYPE(MAGNET_CHART),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(REAL_8),INTENT(IN)::H
    TYPE(REAL_8),INTENT(IN),dimension(:)::BN
    TYPE(REAL_8) XI,PM,DXI_PX,DXI_DDEL

    CALL ALLOC(XI,PM,DXI_PX,DXI_DDEL)

    IF(EL%DIR==1) THEN   ! NOT IMPORTANT; JUST TO INSURE REVERSAL SYMMETRY
       ! HORIZONTAL WEDGE
       X(2)=X(2)+(EL%DIR*EL%CHARGE*BN(1)*H/TWO)*X(1)**2
    ENDIF

    IF(EL%TIME) THEN
       PM=SQRT(ONE+TWO*X(5)/el%beta0+x(5)**2-X(2)**2)
       XI=EL%DIR*EL%CHARGE* SQRT(ONE+TWO*X(5)/el%beta0+x(5)**2)*BN(1)*H/PM**2
       DXI_PX=TWO*X(2)/PM**2 * XI
       DXI_DDEL=-TWO*(ONE+X(5))/PM**2 * XI
    ELSE
       PM=SQRT((ONE+X(5))**2-X(2)**2)
       XI=EL%DIR*EL%CHARGE*(ONE+X(5))*BN(1)*H/PM**2
       DXI_PX=TWO*X(2)/PM**2 * XI
       DXI_DDEL=-TWO*(ONE/EL%BETA0+X(5))/PM**2 * XI
    ENDIF

    X(1)=X(1)/(ONE-DXI_PX*X(3)**2)
    X(2)=X(2)-XI*X(3)**2
    X(4)=X(4)-TWO*XI*X(1)*X(3)
    X(6)=X(6)-DXI_DDEL*X(1)*X(3)**2

    IF(EL%DIR==-1) THEN   ! NOT IMPORTANT; JUST TO INSURE REVERSAL SYMMETRY
       ! HORIZONTAL WEDGE
       X(2)=X(2)+(EL%DIR*EL%CHARGE*BN(1)*H/TWO)*X(1)**2
    ENDIF

    CALL KILL(XI,PM,DXI_PX,DXI_DDEL)


  END SUBROUTINE NEWFACEP

  SUBROUTINE NEWFACES(EL,BN,H,Y)
    IMPLICIT NONE
    TYPE(MAGNET_CHART),INTENT(IN):: EL
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(REAL_8),INTENT(IN)::H
    TYPE(REAL_8),INTENT(IN),dimension(:)::BN
    TYPE(REAL_8)  X(6)
    TYPE(REAL_8) XI,PM,DXI_PX,DXI_DDEL,PZ

    CALL ALLOC(XI,PM,DXI_PX,DXI_DDEL,PZ)
    CALL ALLOC(X,6)

    X=Y

    IF(EL%DIR==1) THEN   ! NOT IMPORTANT; JUST TO INSURE REVERSAL SYMMETRY
       ! HORIZONTAL WEDGE
       X(2)=X(2)+(EL%DIR*EL%CHARGE*BN(1)*H/TWO)*X(1)**2
    ENDIF

    IF(EL%TIME) THEN
       PZ=SQRT(ONE+TWO*X(5)/el%beta0+x(5)**2-X(2)**2)
       XI=EL%DIR*EL%CHARGE*SQRT(ONE+TWO*X(5)/el%beta0+x(5)**2)*BN(1)*H/PM**2
       DXI_PX=TWO*X(2)/PM**2 * XI
       DXI_DDEL=-TWO*(ONE+X(5))/PM**2 * XI
    ELSE
       PM=SQRT((ONE+X(5))**2-X(2)**2)
       XI=EL%DIR*EL%CHARGE*(ONE+X(5))*BN(1)*H/PM**2
       DXI_PX=TWO*X(2)/PM**2 * XI
       DXI_DDEL=-TWO*(ONE/EL%BETA0+X(5))/PM**2 * XI
    ENDIF

    X(1)=X(1)/(ONE-DXI_PX*X(3)**2)
    X(2)=X(2)-XI*X(3)**2
    X(4)=X(4)-TWO*XI*X(1)*X(3)
    X(6)=X(6)-DXI_DDEL*X(1)*X(3)**2

    IF(EL%DIR==-1) THEN   ! NOT IMPORTANT; JUST TO INSURE REVERSAL SYMMETRY
       ! HORIZONTAL WEDGE
       X(2)=X(2)+(EL%DIR*EL%CHARGE*BN(1)*H/TWO)*X(1)**2
    ENDIF

    Y=X

    CALL KILL(XI,PM,DXI_PX,DXI_DDEL,PZ)
    CALL KILL(X,6)

  END SUBROUTINE NEWFACES



  SUBROUTINE FACER(DIR,BN,H,E,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    real(dp),INTENT(IN)::H,E
    real(dp),INTENT(IN),dimension(:)::BN
    INTEGER,INTENT(IN):: DIR
    real(dp) C

    C=one/COS(E)**3

    X(2)=X(2)+(DIR*BN(1)*H/two)*X(1)**2
    X(2)=X(2)-(DIR*BN(1)*H*C/two)*X(3)**2
    X(4)=X(4)-(DIR*BN(1)*H*C)*X(1)*X(3)

  END SUBROUTINE FACER

  SUBROUTINE FACEP(DIR,BN,H,E,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(REAL_8),INTENT(IN)::H
    TYPE(REAL_8),INTENT(IN),dimension(:)::BN
    real(dp),INTENT(IN):: E
    INTEGER,INTENT(IN):: DIR
    real(dp) C

    C=one/COS(E)**3

    X(2)=X(2)+(DIR*BN(1)*H/two)*X(1)**2
    X(2)=X(2)-(DIR*BN(1)*H*C/two)*X(3)**2
    X(4)=X(4)-(DIR*BN(1)*H*C)*X(1)*X(3)

  END SUBROUTINE FACEP


  SUBROUTINE FACES(DIR,BN,H,E,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(REAL_8) X(6)
    TYPE(REAL_8),INTENT(IN)::H
    TYPE(REAL_8),INTENT(IN),dimension(:)::BN
    INTEGER,INTENT(IN):: DIR
    real(dp),INTENT(IN):: E
    real(dp) C


    CALL ALLOC(X)
    X=Y
    C=one/COS(E)**3

    X(2)=X(2)+(DIR*BN(1)*H/two)*X(1)**2
    X(2)=X(2)-(DIR*BN(1)*H*C/two)*X(3)**2
    X(4)=X(4)-(DIR*BN(1)*H*C)*X(1)*X(3)
    Y=X
    CALL KILL(X)

  END SUBROUTINE FACES


  SUBROUTINE FRINGER(EL,BN,FINT,HGAP,K,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    real(dp),INTENT(IN)::FINT,HGAP
    real(dp),INTENT(IN),dimension(:)::BN
    TYPE(MAGNET_CHART),INTENT(IN):: EL
    INTEGER, INTENT(IN) :: K
    real(dp) PZ,XP,YP,TIME_FAC
    real(dp) D(3,3),FI(3),FI0,B,co1,co2
    integer i


    !    if((.not.el%exact)) then
    !     write(6,*) " Fringer should be called in exact magnets only "
    !     stop 101
    !    endif

    IF(.not.EL%BEND_FRINGE) RETURN
    IF(K==1.AND.EL%KILL_ENT_FRINGE) RETURN
    IF(K==2.AND.EL%KILL_EXI_FRINGE) RETURN


    IF(K==1) THEN
       B=EL%CHARGE*BN(1)
    ELSE
       B=-EL%CHARGE*BN(1)
    ENDIF


    if(EL%TIME) then
       PZ=ROOT(one+two*X(5)/el%beta0+x(5)**2-X(2)**2-X(4)**2)
       TIME_FAC=ONE/el%beta0+X(5)
    else
       PZ=ROOT((one+X(5))**2-X(2)**2-X(4)**2)
       TIME_FAC=ONE+X(5)
    endif
    XP=X(2)/PZ ; YP=X(4)/PZ;

    D(1,1)=(ONE+XP**2)/PZ
    D(2,1)=XP*YP/PZ
    D(3,1)=-XP
    D(1,2)=XP*YP/PZ
    D(2,2)=(ONE+YP**2)/PZ
    D(3,2)=-YP
    D(1,3)=-TIME_FAC*XP/PZ**2
    D(2,3)=-TIME_FAC*YP/PZ**2
    D(3,3)= TIME_FAC/PZ

    !    FI0=(B*XP/(one+yp**2)-B2* ( ONE + XP**2*(TWO+YP**2) )/PZ)
    !    FI0= arctan((XP/(one+yp**2)))    !-B*FINT*HGAP*two*( ONE + XP**2*(TWO+YP**2) )   *PZ
    FI0= ATAN((XP/(one+yp**2)))-B*FINT*HGAP*two*( ONE + XP**2*(TWO+YP**2) )*PZ
    CO2=B/COS(FI0)**2
    CO1=CO2/(ONE+(XP/(one+yp**2))**2 )

    FI(1)=CO1/(one+yp**2)-CO2*B*FINT*HGAP*two*( TWO*XP*(TWO+YP**2)*PZ )
    FI(2)=-CO1*TWO*XP*YP/(one+yp**2)**2-CO2*B*FINT*HGAP*two*( TWO*XP**2*YP)*PZ
    FI(3)=-CO2*B*FINT*HGAP*two*( ONE + XP**2*(TWO+YP**2) )

    FI0=B*TAN(FI0)


    !       X(4)=X(4)-TAN(EL%EDGE(I)-EL%DIR*EL%CHARGE*two*FINT*HGAP*(ONE+SIN(EL%EDGE(I))**2)*BN(1)/COS(EL%EDGE(I))) &
    !       & *EL%DIR*EL%CHARGE*BN(1)*X(3)   ! SECTOR WEDGE (PROT) + FRINGE

    B=ZERO
    DO i=1,3
       B=FI(I)*D(I,2)+B
    ENDDO
    X(3)=TWO*X(3)/(ONE+ sqrt(ONE-TWO*B*X(3)) )
    X(4)=X(4)-FI0*X(3)

    B=ZERO
    DO i=1,3
       B=FI(I)*D(I,1)+B
    ENDDO
    X(1)=X(1)+HALF*B*X(3)**2

    B=ZERO
    DO i=1,3
       B=FI(I)*D(I,3)+B
    ENDDO
    X(6)=X(6)-HALF*B*X(3)**2
    !    CALL check_stability(X)
    call check_root_drift(el,X)
  END SUBROUTINE FRINGER


  SUBROUTINE FRINGEP(EL,BN,FINT,HGAP,K,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(REAL_8),INTENT(IN)::FINT,HGAP
    TYPE(REAL_8),INTENT(IN),dimension(:)::BN
    TYPE(MAGNET_CHART),INTENT(IN):: EL
    INTEGER, INTENT(IN) :: K
    TYPE(REAL_8) PZ,XP,YP,TIME_FAC,FI0,B
    TYPE(REAL_8) D(3,3),FI(3),CO1,CO2
    integer i,J
    ! etienne

    !    if((.not.el%exact)) then
    !     write(6,*) " Fringep should be called in exact magnets only "
    !     stop 102
    !    endif


    IF((.not.EL%BEND_FRINGE).or.(.not.el%exact)) RETURN
    IF(K==1.AND.EL%KILL_ENT_FRINGE) RETURN
    IF(K==2.AND.EL%KILL_EXI_FRINGE) RETURN

    CALL ALLOC(PZ,XP,YP,TIME_FAC,FI0,B,CO1,CO2)
    DO I=1,3
       CALL ALLOC(FI(I))
       DO J=1,3
          CALL ALLOC(D(I,J))
       ENDDO
    ENDDO

    IF(K==1) THEN
       B=EL%CHARGE*BN(1)
    ELSE
       B=-EL%CHARGE*BN(1)
    ENDIF




    if(EL%TIME) then
       PZ=sqrt(one+two*X(5)/el%beta0+x(5)**2-X(2)**2-X(4)**2)
       TIME_FAC=ONE/el%beta0+X(5)
    else
       PZ=sqrt((one+X(5))**2-X(2)**2-X(4)**2)
       TIME_FAC=ONE+X(5)
    endif
    XP=X(2)/PZ ; YP=X(4)/PZ;

    D(1,1)=(ONE+XP**2)/PZ
    D(2,1)=XP*YP/PZ
    D(3,1)=-XP
    D(1,2)=XP*YP/PZ
    D(2,2)=(ONE+YP**2)/PZ
    D(3,2)=-YP
    D(1,3)=-TIME_FAC*XP/PZ**2
    D(2,3)=-TIME_FAC*YP/PZ**2
    D(3,3)= TIME_FAC/PZ

    !    FI0=(B*XP/(one+yp**2)-B2* ( ONE + XP**2*(TWO+YP**2) )/PZ)
    FI0= ATAN((XP/(one+yp**2)))-B*FINT*HGAP*two*( ONE + XP**2*(TWO+YP**2) )*PZ
    CO2=B/COS(FI0)**2
    CO1=CO2/(ONE+(XP/(one+yp**2))**2 )

    FI(1)=CO1/(one+yp**2)-CO2*B*FINT*HGAP*two*( TWO*XP*(TWO+YP**2)*PZ )
    FI(2)=-CO1*TWO*XP*YP/(one+yp**2)**2-CO2*B*FINT*HGAP*two*( TWO*XP**2*YP)*PZ
    FI(3)=-CO2*B*FINT*HGAP*two*( ONE + XP**2*(TWO+YP**2) )

    FI0=B*TAN(FI0)


    !       X(4)=X(4)-TAN(EL%EDGE(I)-EL%DIR*EL%CHARGE*two*FINT*HGAP*(ONE+SIN(EL%EDGE(I))**2)*BN(1)/COS(EL%EDGE(I))) &
    !       & *EL%DIR*EL%CHARGE*BN(1)*X(3)   ! SECTOR WEDGE (PROT) + FRINGE

    B=ZERO
    DO i=1,3
       B=FI(I)*D(I,2)+B
    ENDDO
    X(3)=TWO*X(3)/(ONE+ sqrt(ONE-TWO*B*X(3)) )
    X(4)=X(4)-FI0*X(3)

    B=ZERO
    DO i=1,3
       B=FI(I)*D(I,1)+B
    ENDDO
    X(1)=X(1)+HALF*B*X(3)**2

    B=ZERO
    DO i=1,3
       B=FI(I)*D(I,3)+B
    ENDDO
    X(6)=X(6)-HALF*B*X(3)**2


    CALL KILL(PZ,XP,YP,TIME_FAC,FI0,B,CO1,CO2)
    DO I=1,3
       CALL KILL(FI(I))
       DO J=1,3
          CALL KILL(D(I,J))
       ENDDO
    ENDDO

  END SUBROUTINE FRINGEP

  SUBROUTINE FRINGES(EL,BN,FINT,HGAP,K,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(REAL_8)  X(6)
    TYPE(REAL_8),INTENT(IN)::FINT,HGAP
    TYPE(REAL_8),INTENT(IN),dimension(:)::BN
    TYPE(MAGNET_CHART),INTENT(IN):: EL
    INTEGER, INTENT(IN) :: K


    CALL ALLOC(X,6)
    X=Y
    CALL FRINGE_(EL,BN,FINT,HGAP,K,X)
    Y=X
    CALL KILL(X,6)

  END SUBROUTINE FRINGES

  SUBROUTINE EDGER_TRUE_PARALLEL(EL,BN,H1,H2,FINT,HGAP,I,X)
    IMPLICIT NONE
    logical(lp) :: doneitt=.true.
    real(dp),INTENT(INOUT):: X(6)
    real(dp),INTENT(IN)::FINT,HGAP,H1,H2
    real(dp),INTENT(IN),dimension(:)::BN
    TYPE(MAGNET_CHART),INTENT(IN):: EL
    INTEGER, INTENT(IN) :: I

    IF(EL%EXACT) THEN
       IF(EL%DIR==1) THEN
          IF(I==1) then                !doubling entrance angle if first half  (1/2 magnet for designer)
             call ROT_XZ(EL%EDGE(1),X,EL%BETA0,DONEITT,EL%TIME)
             CALL FACE(EL,BN,H1,X)
          endif
          CALL FRINGE_(EL,BN,FINT,HGAP,I,X)
          IF(I==2) then                !doubling exit angle if second half
             CALL FACE(EL,BN,H2,X)
             x(1)=x(1)+EL%LC*SIN((EL%EDGE(2)-EL%EDGE(1))*half)
             call ROT_XZ(EL%EDGE(2),X,EL%BETA0,DONEITT,EL%TIME)
          endif
       ELSE
          IF(I==2) then                !doubling exit angle if second half
             call ROT_XZ(EL%EDGE(2),X,EL%BETA0,DONEITT,EL%TIME)
             x(1)=x(1)+EL%DIR*EL%LC*SIN((EL%EDGE(2)-EL%EDGE(1))*half)
             CALL FACE(EL,BN,H2,X)
          endif
          CALL FRINGE_(EL,BN,FINT,HGAP,I,X)
          IF(I==1) then                !doubling entrance angle if first half  (1/2 magnet for designer)
             CALL FACE(EL,BN,H1,X)
             call ROT_XZ(EL%EDGE(1),X,EL%BETA0,DONEITT,EL%TIME)
          endif
       ENDIF

    ELSE
       WRITE(6,*) "ERROR 777"
       STOP 777
    ENDIF

  END SUBROUTINE EDGER_TRUE_PARALLEL

  SUBROUTINE EDGEP_TRUE_PARALLEL(EL,BN,H1,H2,FINT,HGAP,I,X)
    IMPLICIT NONE
    logical(lp) :: doneitt=.true.
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(REAL_8),INTENT(IN)::FINT,HGAP,H1,H2
    TYPE(REAL_8),INTENT(IN),dimension(:)::BN
    TYPE(MAGNET_CHART),INTENT(IN):: EL
    INTEGER, INTENT(IN) :: I
    IF(EL%EXACT) THEN
       IF(EL%DIR==1) THEN
          IF(I==1) then                !doubling entrance angle if first half  (1/2 magnet for designer)
             call ROT_XZ(EL%EDGE(1),X,EL%BETA0,DONEITT,EL%TIME)
             CALL FACE(EL,BN,H1,X)
          endif
          CALL FRINGE_(EL,BN,FINT,HGAP,I,X)
          IF(I==2) then                !doubling exit angle if second half
             CALL FACE(EL,BN,H2,X)
             x(1)=x(1)+EL%LC*SIN((EL%EDGE(2)-EL%EDGE(1))*half)
             call ROT_XZ(EL%EDGE(2),X,EL%BETA0,DONEITT,EL%TIME)
          endif
       ELSE
          IF(I==2) then                !doubling exit angle if second half
             call ROT_XZ(EL%EDGE(2),X,EL%BETA0,DONEITT,EL%TIME)
             x(1)=x(1)+EL%DIR*EL%LC*SIN((EL%EDGE(2)-EL%EDGE(1))*half)
             CALL FACE(EL,BN,H2,X)
          endif
          CALL FRINGE_(EL,BN,FINT,HGAP,I,X)
          IF(I==1) then                !doubling entrance angle if first half  (1/2 magnet for designer)
             CALL FACE(EL,BN,H1,X)
             call ROT_XZ(EL%EDGE(1),X,EL%BETA0,DONEITT,EL%TIME)
          endif
       ENDIF
    ELSE
       WRITE(6,*) "ERROR 778"
       STOP 778

    ENDIF


  END SUBROUTINE EDGEP_TRUE_PARALLEL

  SUBROUTINE EDGES_TRUE_PARALLEL(EL,BN,H1,H2,FINT,HGAP,I,Y)
    IMPLICIT NONE
    TYPE(REAL_8) X(6)
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(REAL_8),INTENT(IN)::FINT,HGAP,H1,H2
    TYPE(REAL_8),INTENT(IN),dimension(:)::BN
    TYPE(MAGNET_CHART),INTENT(IN):: EL
    INTEGER, INTENT(IN) :: I

    CALL ALLOC(X,6)


    X=Y
    CALL EDGE_TRUE_PARALLEL(EL,BN,H1,H2,FINT,HGAP,I,X)
    Y=X

    CALL KILL(X,6)

  END SUBROUTINE EDGES_TRUE_PARALLEL



  SUBROUTINE EDGER(EL,BN,H1,H2,FINT,HGAP,I,X)
    IMPLICIT NONE
    logical(lp) :: doneitt=.true.
    real(dp),INTENT(INOUT):: X(6)
    real(dp),INTENT(IN)::FINT,HGAP,H1,H2
    real(dp),INTENT(IN),dimension(:)::BN
    TYPE(MAGNET_CHART),INTENT(IN):: EL
    INTEGER, INTENT(IN) :: I

    IF(EL%EXACT) THEN
       IF(EL%DIR==1) THEN
          IF(I==1) then                !doubling entrance angle if first half  (1/2 magnet for designer)
             call ROT_XZ(EL%EDGE(1),X,EL%BETA0,DONEITT,EL%TIME)
             CALL FACE(EL,BN,H1,X)
          endif
          CALL FRINGE_(EL,BN,FINT,HGAP,I,X)
          IF(I==2) then                !doubling exit angle if second half
             CALL FACE(EL,BN,H2,X)
             x(1)=x(1)+EL%LC*SIN((EL%EDGE(2)-EL%EDGE(1))*half)
             call ROT_XZ(EL%EDGE(2),X,EL%BETA0,DONEITT,EL%TIME)
          endif
       ELSE
          IF(I==2) then                !doubling exit angle if second half
             call ROT_XZ(EL%EDGE(2),X,EL%BETA0,DONEITT,EL%TIME)
             x(1)=x(1)+EL%DIR*EL%LC*SIN((EL%EDGE(2)-EL%EDGE(1))*half)
             CALL FACE(EL,BN,H2,X)
          endif
          CALL FRINGE_(EL,BN,FINT,HGAP,I,X)
          IF(I==1) then                !doubling entrance angle if first half  (1/2 magnet for designer)
             CALL FACE(EL,BN,H1,X)
             call ROT_XZ(EL%EDGE(1),X,EL%BETA0,DONEITT,EL%TIME)
          endif
       ENDIF
    ELSE

       IF(EL%DIR==1) THEN
          IF(I==2) CALL FACE(EL%DIR*EL%CHARGE,BN,H2,EL%EDGE(2),X)
       ELSE
          IF(I==1) CALL FACE(EL%DIR*EL%CHARGE,BN,H1,EL%EDGE(1),X)
       ENDIF

       X(2)=X(2)+TAN(EL%EDGE(I))*EL%DIR*EL%CHARGE*BN(1)*X(1)   ! SECTOR WEDGE

       IF(.NOT.((I==1.AND.EL%KILL_ENT_FRINGE).OR.(I==2.AND.EL%KILL_EXI_FRINGE))) THEN

          X(4)=X(4)-TAN(EL%EDGE(I)-EL%DIR*EL%CHARGE*two*FINT*HGAP*(ONE+SIN(EL%EDGE(I))**2)*BN(1)/COS(EL%EDGE(I))) &
               & *EL%DIR*EL%CHARGE*BN(1)*X(3)   ! SECTOR WEDGE (PROT) + FRINGE
       ENDIF

       IF(EL%DIR==1) THEN
          IF(I==1) CALL FACE(EL%DIR*EL%CHARGE,BN,H1,EL%EDGE(1),X)
       ELSE
          IF(I==2) CALL FACE(EL%DIR*EL%CHARGE,BN,H2,EL%EDGE(2),X)
       ENDIF



    ENDIF

  END SUBROUTINE EDGER

  SUBROUTINE EDGEP(EL,BN,H1,H2,FINT,HGAP,I,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(REAL_8),INTENT(IN)::FINT,HGAP,H1,H2
    TYPE(REAL_8),INTENT(IN),dimension(:)::BN
    TYPE(MAGNET_CHART),INTENT(IN):: EL
    INTEGER, INTENT(IN) :: I
    IF(EL%EXACT) THEN
       IF(EL%DIR==1) THEN
          IF(I==1) then                !doubling entrance angle if first half  (1/2 magnet for designer)
             !   call ROT_XZ(EL%EDGE(1),X,EL%BETA0,DONEITT,EL%TIME)       !DONE IN TRUE_PARALLEL ROUTINE!!!!!
             CALL FACE(EL,BN,H1,X)
          endif
          CALL FRINGE_(EL,BN,FINT,HGAP,I,X)
          IF(I==2) then                !doubling exit angle if second half
             CALL FACE(EL,BN,H2,X)
             !   x(1)=x(1)+EL%LC*SIN((EL%EDGE(2)-EL%EDGE(1))*half)
             !   call ROT_XZ(EL%EDGE(2),X,EL%BETA0,DONEITT,EL%TIME)
          endif
       ELSE
          IF(I==2) then                !doubling exit angle if second half
             !   call ROT_XZ(EL%EDGE(2),X,EL%BETA0,DONEITT,EL%TIME)
             !   x(1)=x(1)+EL%DIR*EL%LC*SIN((EL%EDGE(2)-EL%EDGE(1))*half)
             CALL FACE(EL,BN,H2,X)
          endif
          CALL FRINGE_(EL,BN,FINT,HGAP,I,X)
          IF(I==1) then                !doubling entrance angle if first half  (1/2 magnet for designer)
             CALL FACE(EL,BN,H1,X)
             !   call ROT_XZ(EL%EDGE(1),X,EL%BETA0,DONEITT,EL%TIME)
          endif
       ENDIF
    ELSE

       IF(EL%DIR==1) THEN
          IF(I==2) CALL FACE(EL%DIR*EL%CHARGE,BN,H2,EL%EDGE(2),X)
       ELSE
          IF(I==1) CALL FACE(EL%DIR*EL%CHARGE,BN,H1,EL%EDGE(1),X)
       ENDIF

       X(2)=X(2)+TAN(EL%EDGE(I))*EL%DIR*EL%CHARGE*BN(1)*X(1)   ! SECTOR WEDGE

       IF(.NOT.((I==1.AND.EL%KILL_ENT_FRINGE).OR.(I==2.AND.EL%KILL_EXI_FRINGE))) THEN
          X(4)=X(4)-TAN(EL%EDGE(I)-EL%DIR*EL%CHARGE*two*FINT*HGAP*(ONE+SIN(EL%EDGE(I))**2)*BN(1)/COS(EL%EDGE(I))) &
               & *EL%DIR*EL%CHARGE*BN(1)*X(3)   ! SECTOR WEDGE (PROT) + FRINGE
       ENDIF

       IF(EL%DIR==1) THEN
          IF(I==1) CALL FACE(EL%DIR*EL%CHARGE,BN,H1,EL%EDGE(1),X)
       ELSE
          IF(I==2) CALL FACE(EL%DIR*EL%CHARGE,BN,H2,EL%EDGE(2),X)
       ENDIF



    ENDIF


  END SUBROUTINE EDGEP

  SUBROUTINE EDGES(EL,BN,H1,H2,FINT,HGAP,I,Y)
    IMPLICIT NONE
    TYPE(REAL_8) X(6)
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(REAL_8),INTENT(IN)::FINT,HGAP,H1,H2
    TYPE(REAL_8),INTENT(IN),dimension(:)::BN
    TYPE(MAGNET_CHART),INTENT(IN):: EL
    INTEGER, INTENT(IN) :: I

    CALL ALLOC(X,6)


    X=Y
    CALL EDGE(EL,BN,H1,H2,FINT,HGAP,I,X)
    Y=X

    CALL KILL(X,6)

  END SUBROUTINE EDGES



  SUBROUTINE KICKR(EL,YL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(DKD2),INTENT(IN):: EL
    real(dp),INTENT(IN):: YL
    real(dp) X1,X3,X5,BBYTW,BBXTW,BBYTWT,B(3),B2
    INTEGER J,DIR
    DIR=EL%P%DIR*EL%P%CHARGE

    X1=X(1)
    X3=X(3)

    if(EL%P%TIME) then
       X5=ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
    else
       X5=X(5)
    endif

    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF


    IF(EL%P%EXACT) THEN
       IF(EL%P%RADIATION) THEN
          B(1)=BBXTW
          B(2)=BBYTW
          B(3)=zero
          CALL B2PERP(EL%P,B,X,X5,B2)
          X(5)=X(5)-CRADF(EL%P)*(one+X(5))**3*B2*YL/ROOT((one+X(5))**2-X(2)**2-X(4)**2)
          if(EL%P%TIME) then
             X(2)=X(2)*ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
             X(4)=X(4)*ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          else
             X(2)=X(2)*(one+X(5))/(one+X5)
             X(4)=X(4)*(one+X(5))/(one+X5)
          endif
       ENDIF
       X(2)=X(2)-YL*DIR*BBYTW
       X(4)=X(4)+YL*DIR*BBXTW
    ELSE
       IF(EL%P%RADIATION) THEN
          B(1)=BBXTW
          B(2)=BBYTW !+EL%BN(1)  !
          B(3)=zero
          CALL B2PERP(EL%P,B,X,X5,B2)
          X(5)=X(5)-CRADF(EL%P)*(one+X(5))**2*B2*(one+X1*EL%P%B0+half*(X(2)**2+X(4)**2)/(one+X(5))**2)*YL
          if(EL%P%TIME) then
             X(2)=X(2)*ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
             X(4)=X(4)*ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          else
             X(2)=X(2)*(one+X(5))/(one+X5)
             X(4)=X(4)*(one+X(5))/(one+X5)
          endif
       ENDIF
       X(2)=X(2)-YL*(DIR*BBYTW-EL%P%B0-(X5-X1*DIR*EL%BN(1))*EL%P%B0)
       X(4)=X(4)+YL* DIR*BBXTW

       if(EL%P%TIME) then
          X(6)=X(6)+YL*EL%P%B0*X1*(one/EL%P%beta0+x(5))/(one+X5)
       else
          X(6)=X(6)+YL*EL%P%B0*X1
       endif
    ENDIF

  END SUBROUTINE KICKR

  SUBROUTINE KICKP(EL,YL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(DKD2P),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) X1,X3,X5,BBYTW,BBXTW,BBYTWT,B(3),B2
    INTEGER J,DIR


    CALL ALLOC(X1)
    CALL ALLOC(X3)
    CALL ALLOC(X5)
    CALL ALLOC(BBYTW)
    CALL ALLOC(BBXTW)
    CALL ALLOC(BBYTWT)

    DIR=EL%P%DIR*EL%P%CHARGE
    X1=X(1)
    X3=X(3)

    if(EL%P%TIME) then
       X5=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
    else
       X5=X(5)
    endif

    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF


    IF(EL%P%EXACT) THEN
       IF(EL%P%RADIATION) THEN
          CALL ALLOC(B,3)
          CALL ALLOC(B2)
          B(1)=BBXTW
          B(2)=BBYTW
          B(3)=zero
          CALL B2PERP(EL%P,B,X,X5,B2)
          X(5)=X(5)-CRADF(EL%P)*(one+X(5))**3*B2*YL/SQRT((one+X(5))**2-X(2)**2-X(4)**2)
          if(EL%P%TIME) then
             X(2)=X(2)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
             X(4)=X(4)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          else
             X(2)=X(2)*(one+X(5))/(one+X5)
             X(4)=X(4)*(one+X(5))/(one+X5)
          endif
          CALL KILL(B,3)
          CALL KILL(B2)
       ENDIF
       X(2)=X(2)-YL*DIR*BBYTW
       X(4)=X(4)+YL*DIR*BBXTW
    ELSE
       IF(EL%P%RADIATION) THEN
          CALL ALLOC(B,3)
          CALL ALLOC(B2)
          B(1)=BBXTW
          B(2)=BBYTW !+EL%BN(1)  !
          B(3)=zero
          CALL B2PERP(EL%P,B,X,X5,B2)
          X(5)=X(5)-CRADF(EL%P)*(one+X(5))**2*B2*(one+X1*EL%P%B0+half*(X(2)**2+X(4)**2)/(one+X(5))**2)*YL
          if(EL%P%TIME) then
             X(2)=X(2)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
             X(4)=X(4)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          else
             X(2)=X(2)*(one+X(5))/(one+X5)
             X(4)=X(4)*(one+X(5))/(one+X5)
          endif
          CALL KILL(B,3)
          CALL KILL(B2)
       ENDIF
       X(2)=X(2)-YL*(DIR*BBYTW-EL%P%B0-(X5-X1*DIR*EL%BN(1))*EL%P%B0)
       X(4)=X(4)+YL* DIR*BBXTW

       if(EL%P%TIME) then
          X(6)=X(6)+YL*EL%P%B0*X1*(one/EL%P%beta0+x(5))/(one+X5)
       else
          X(6)=X(6)+YL*EL%P%B0*X1
       endif
    ENDIF


    CALL KILL(X1)
    CALL KILL(X3)
    CALL KILL(X5)
    CALL KILL(BBYTW)
    CALL KILL(BBXTW)
    CALL KILL(BBYTWT)

  END SUBROUTINE KICKP

  SUBROUTINE KICKS(EL,YL,Y)
    IMPLICIT NONE
    TYPE(REAL_8) X(6),XR(6)
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(DAMAP) XP,ID,DISP,XT
    TYPE(DKD2P),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) X1,X3,X5,BBYTW,BBXTW,BBYTWT,B(3),B2,DENF
    real(dp) B20,B30,BF, v(6) !,R1,R2,DEN0
    logical(lp) done_stoch
    INTEGER I,J,DIR

    CALL ALLOC(X1)
    CALL ALLOC(X3)
    CALL ALLOC(X5)
    CALL ALLOC(denf)
    CALL ALLOC(BBYTW)
    CALL ALLOC(BBXTW)
    CALL ALLOC(BBYTWT)
    CALL ALLOC(X)
    CALL ALLOC(XR)
    CALL ALLOC(XP)
    CALL ALLOC(ID)
    CALL ALLOC(DISP)
    CALL ALLOC(XT)
    CALL ALLOC(B2)
    CALL ALLOC(B,3)


    DIR=EL%P%DIR*EL%P%CHARGE

    X=Y
    X1=X(1)
    X3=X(3)
    if(EL%P%TIME) then
       X5=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
    else
       X5=X(5)
    endif


    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF

    XP=X
    XR=X
    IF(EL%P%EXACT) THEN
       XP%V(2)=X(2)/SQRT((one+x5)**2-X(2)**2-X(4)**2)
       XP%V(4)=X(4)/SQRT((one+x5)**2-X(2)**2-X(4)**2)
       IF(EL%P%RADIATION) THEN
          B(1)=BBXTW
          B(2)=BBYTW
          B(3)=zero
          CALL B2PERP(EL%P,B,X,X5,B2)
          X(5)=X(5)-CRADF(EL%P)*(one+X(5))**3*B2*YL/SQRT((one+X(5))**2-X(2)**2-X(4)**2)

          if(EL%P%TIME) then
             X(2)=X(2)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
             X(4)=X(4)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          else
             X(2)=X(2)*(one+X(5))/(one+X5)
             X(4)=X(4)*(one+X(5))/(one+X5)
          endif

       ENDIF
       X(2)=X(2)-YL*DIR*BBYTW
       X(4)=X(4)+YL*DIR*BBXTW
    ELSE
       XP%V(2)=X(2)/(one+x5)
       XP%V(4)=X(4)/(one+x5)
       IF(EL%P%RADIATION) THEN
          B(1)=BBXTW
          B(2)=BBYTW  !+EL%BN(1)
          B(3)=zero
          CALL B2PERP(EL%P,B,X,X5,B2)
          X(5)=X(5)-CRADF(EL%P)*(one+X(5))**2*B2*(one+X1*EL%P%B0+half*(X(2)**2+X(4)**2)/(one+X(5))**2)*YL

          if(EL%P%TIME) then
             X(2)=X(2)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
             X(4)=X(4)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          else
             X(2)=X(2)*(one+X(5))/(one+X5)
             X(4)=X(4)*(one+X(5))/(one+X5)
          endif


       ENDIF
       X(2)=X(2)-YL*(DIR*BBYTW-EL%P%B0-(X5-X1*DIR*EL%BN(1))*EL%P%B0)
       X(4)=X(4)+YL* DIR*BBXTW
       if(EL%P%TIME) then
          X(6)=X(6)+YL*EL%P%B0*X1*(one/EL%P%beta0+x(5))/(one+X5)
       else
          X(6)=X(6)+YL*EL%P%B0*X1
       endif
    ENDIF

    done_stoch=.false.
    if(EL%P%B0==zero.and.stoch_in_rec) then

       if(EL%P%EXACT) then
          denf=(one+xR(5))**5/SQRT((one+XR(5))**2-XR(2)**2-XR(4)**2)
       else
          denf=(one+xr(5))**4*(one+xr(1)*EL%P%B0+half*(xr(2)**2+xr(4)**2)/(one+xr(5))**2)
       endif
       b20=b2
       b30=b20**c_1_5
       bf=cflucf(el%p)*b30
       denf=denf*bf*yl
       done_stoch=.true.
    elseif(EL%P%B0/=zero)   then
       done_stoch=.true.
    endif

    if(done_stoch) then

       if(EL%P%B0/=zero) then
          !
          if(knob) then
             v=xr
             DISP=xp*id
             id=1
             DISP=ID-DISP
             XP=DISP*XP

             id=0
             XT=XR
             DISP=XT*ID
             ID=1
             DISP=ID-DISP
             XT=DISP*XT
             xr=xt+V
             CALL B2PERP(EL%P,B,Xr,X5,B2)

             if(EL%P%EXACT) then
                denf=(one+xR(5))**5/SQRT((one+XR(5))**2-XR(2)**2-XR(4)**2)
             else
                denf=(one+xr(5))**4*(one+xr(1)*EL%P%B0+half*(xr(2)**2+xr(4)**2)/(one+xr(5))**2)
             endif
             denf=DENF*cflucf(el%p)*yl*b2**c_1_5
          else
             CALL B2PERP(EL%P,B,Xr,X5,B2)
             if(EL%P%EXACT) then
                denf=(one+xR(5))**5/SQRT((one+XR(5))**2-XR(2)**2-XR(4)**2)
             else
                denf=(one+xr(5))**4*(one+xr(1)*EL%P%B0+half*(xr(2)**2+xr(4)**2)/(one+xr(5))**2)
             endif
             b20=b2
             b30=b20**c_1_5
             bf=cflucf(el%p)*b30
             denf=denf*bf*yl
          endif
       endif

       xp=xp**(-1)
       do i=1,6
          do j=1,6
             X1=(xp%v(i)).par.'000010'
             X3=(xp%v(j)).par.'000010'
             denf=denf.par.'000000'
             y(I)%E(J)=y(I)%E(J)+denf*x1*x3
          enddo
       enddo
    endif


    Y=X
    CALL KILL(B2)
    CALL KILL(B,3)
    CALL KILL(XP)
    CALL KILL(ID)
    CALL KILL(DISP)
    CALL KILL(XT)
    CALL KILL(X)
    CALL KILL(XR)
    CALL KILL(X1)
    CALL KILL(X3)
    CALL KILL(X5)
    CALL KILL(BBYTW)
    CALL KILL(BBXTW)
    CALL KILL(BBYTWT)
    CALL KILL(denf)

  END SUBROUTINE KICKS


  SUBROUTINE INTER(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: MID
    TYPE(DKD2),INTENT(IN):: EL
    real(dp) D,DH,DD
    real(dp) D1,D2,DK1,DK2
    real(dp) DD1,DD2
    real(dp) DF(4),DK(4),DDF(4)
    INTEGER I,J
    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    SELECT CASE(EL%P%METHOD)
    CASE(2)
       DH=EL%L/two/EL%P%NST
       D=EL%L/EL%P%NST
       DD=EL%P%LD/two/EL%P%NST

       DO I=1,EL%P%NST
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICK (EL,D,X)

          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
    CASE(4)
       D1=EL%L*FD1/EL%P%NST
       D2=EL%L*FD2/EL%P%NST
       DD1=EL%P%LD*FD1/EL%P%NST
       DD2=EL%P%LD*FD2/EL%P%NST
       DK1=EL%L*FK1/EL%P%NST
       DK2=EL%L*FK2/EL%P%NST

       DO I=1,EL%P%NST
          CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICK (EL,DK1,X)
          CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICK (EL,DK2,X)

          CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICK (EL,DK1,X)
          CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO

    CASE(6)
       DO I =1,4
          DF(I)=EL%L*YOSD(I)/EL%P%NST
          DDF(I)=EL%P%LD*YOSD(I)/EL%P%NST
          DK(I)=EL%L*YOSK(I)/EL%P%NST
       ENDDO

       DO I=1,EL%P%NST
          DO J=4,2,-1
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICK (EL,DK(J),X)
          ENDDO
          CALL DRIFT(DF(1),DDF(1),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICK (EL,DK(1),X)

          CALL DRIFT(DF(1),DDF(1),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          DO J=2,4
             CALL KICK (EL,DK(J),X)
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          ENDDO
          IF(PRESENT(MID)) CALL XMID(MID,X,I)

       ENDDO



    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

  END SUBROUTINE INTER





  SUBROUTINE INTEP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: MID
    TYPE(DKD2P),INTENT(IN):: EL
    TYPE(REAL_8) D,DH
    real(dp) DD
    TYPE(REAL_8) D1,D2,DK1,DK2
    real(dp) DD1,DD2
    TYPE(REAL_8) DF(4),DK(4)
    real(dp) DDF(4)
    INTEGER I,J

    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    SELECT CASE(EL%P%METHOD)
    CASE(2)
       CALL ALLOC(DH)
       CALL ALLOC(D)
       DH=EL%L/two/EL%P%NST
       D=EL%L/EL%P%NST
       DD=EL%P%LD/two/EL%P%NST

       DO I=1,EL%P%NST
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICK (EL,D,X)
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
       CALL KILL(DH)
       CALL KILL(D)
    CASE(4)
       CALL ALLOC(D1)
       CALL ALLOC(D2)
       CALL ALLOC(DK1)
       CALL ALLOC(DK2)
       D1=EL%L*FD1/EL%P%NST
       D2=EL%L*FD2/EL%P%NST
       DD1=EL%P%LD*FD1/EL%P%NST
       DD2=EL%P%LD*FD2/EL%P%NST
       DK1=EL%L*FK1/EL%P%NST
       DK2=EL%L*FK2/EL%P%NST

       DO I=1,EL%P%NST
          CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICK (EL,DK1,X)
          CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICK (EL,DK2,X)
          CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICK (EL,DK1,X)
          CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
       CALL KILL(D1)
       CALL KILL(D2)
       CALL KILL(DK1)
       CALL KILL(DK2)
    CASE(6)
       CALL ALLOC(DF,4)
       CALL ALLOC(DK,4)
       DO I =1,4
          DF(I)=EL%L*YOSD(I)/EL%P%NST
          DDF(I)=EL%P%LD*YOSD(I)/EL%P%NST
          DK(I)=EL%L*YOSK(I)/EL%P%NST
       ENDDO

       DO I=1,EL%P%NST
          DO J=4,2,-1
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICK (EL,DK(J),X)
          ENDDO
          CALL DRIFT(DF(1),DDF(1),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICK (EL,DK(1),X)
          CALL DRIFT(DF(1),DDF(1),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          DO J=2,4
             CALL KICK (EL,DK(J),X)
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          ENDDO
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)

       ENDDO
       CALL KILL(DF,4)
       CALL KILL(DK,4)



    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

  END SUBROUTINE INTEP


  SUBROUTINE INTES(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(DKD2P),INTENT(IN):: EL
    TYPE(REAL_8) D,DH
    real(dp) DD
    TYPE(REAL_8) D1,D2,DK1,DK2
    real(dp) DD1,DD2
    TYPE(REAL_8) DF(4),DK(4)
    real(dp) DDF(4)
    INTEGER I,J

    SELECT CASE(EL%P%METHOD)
    CASE(2)
       CALL ALLOC(DH)
       CALL ALLOC(D)
       DH=EL%L/two/EL%P%NST
       D=EL%L/EL%P%NST
       DD=EL%P%LD/two/EL%P%NST

       DO I=1,EL%P%NST
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICK (EL,D,X)
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
       ENDDO
       CALL KILL(DH)
       CALL KILL(D)
    CASE(4)
       CALL ALLOC(D1)
       CALL ALLOC(D2)
       CALL ALLOC(DK1)
       CALL ALLOC(DK2)
       D1=EL%L*FD1/EL%P%NST
       D2=EL%L*FD2/EL%P%NST
       DD1=EL%P%LD*FD1/EL%P%NST
       DD2=EL%P%LD*FD2/EL%P%NST
       DK1=EL%L*FK1/EL%P%NST
       DK2=EL%L*FK2/EL%P%NST

       DO I=1,EL%P%NST
          CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICK (EL,DK1,X)
          CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICK (EL,DK2,X)
          CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICK (EL,DK1,X)
          CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
       ENDDO
       CALL KILL(D1)
       CALL KILL(D2)
       CALL KILL(DK1)
       CALL KILL(DK2)
    CASE(6)
       CALL ALLOC(DF,4)
       CALL ALLOC(DK,4)
       DO I =1,4
          DF(I)=EL%L*YOSD(I)/EL%P%NST
          DDF(I)=EL%P%LD*YOSD(I)/EL%P%NST
          DK(I)=EL%L*YOSK(I)/EL%P%NST
       ENDDO

       DO I=1,EL%P%NST
          DO J=4,2,-1
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICK (EL,DK(J),X)
          ENDDO
          CALL DRIFT(DF(1),DDF(1),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL KICK (EL,DK(1),X)
          CALL DRIFT(DF(1),DDF(1),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          DO J=2,4
             CALL KICK (EL,DK(J),X)
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          ENDDO
       ENDDO
       CALL KILL(DF,4)
       CALL KILL(DK,4)



    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

  END SUBROUTINE INTES

  SUBROUTINE SYMPINTR(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(DKD2),INTENT(IN):: EL
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: MID

    if(EL%P%DIR==1) THEN
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL INTE(EL,X,MID)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
    ELSE
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL INTE(EL,X,MID)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
    ENDIF


  END SUBROUTINE SYMPINTR

  SUBROUTINE SYMPINTP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(DKD2P),INTENT(IN):: EL
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: MID

    if(EL%P%DIR==1) THEN
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL INTE(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
    ELSE
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL INTE(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
    ENDIF

  END SUBROUTINE SYMPINTP

  SUBROUTINE SYMPINTS(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(DKD2P),INTENT(IN):: EL

    if(EL%P%DIR==1) THEN
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL INTE(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
    ELSE
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL INTE(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
    ENDIF

  END SUBROUTINE SYMPINTS


  ! Solenoid Stuff

  SUBROUTINE KICK_SOLR(EL,YL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(SOL5),INTENT(IN):: EL
    real(dp),INTENT(IN):: YL
    real(dp)  X_MEC(6),B(3),B2,X5

    ! NO EXACT EL%EXACT
    if(EL%P%TIME) then
       x5=ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
    else
       x5=X(5)
    endif


    IF(EL%P%RADIATION) THEN
       X_MEC=zero
       X_MEC(2)=X(2)+EL%B_SOL*EL%P%CHARGE*X(3)/two
       X_MEC(4)=X(4)-EL%B_SOL*EL%P%CHARGE*X(1)/two
       X_MEC(5)=X(5)
       CALL GETMULB_SOL(EL,B,X)
       CALL B2PERP(EL%P,B,X_MEC,X5,B2)
       X5=X(5)
       X(5)=X(5)-CRADF(EL%P)*(one+X(5))**2*B2*(one+half*(X_MEC(2)**2+X_MEC(4)**2)/(one+X(5))**2)*YL
       X(2)=X_MEC(2)*(one+X(5))/(one+X5)-EL%B_SOL*EL%P%CHARGE*X(3)/two
       X(4)=X_MEC(4)*(one+X(5))/(one+X5)+EL%B_SOL*EL%P%CHARGE*X(1)/two
    ENDIF
    if(EL%P%TIME) then
       x5=ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)
       X(2)=X(2)-YL*(EL%B_SOL)**2*X(1)/four/x5
       X(4)=X(4)-YL*(EL%B_SOL)**2*X(3)/four/x5
       X(6)=X(6)+(one/EL%P%beta0+x(5))*YL*(EL%B_SOL)**2*(X(1)**2+X(3)**2)/eight/x5**3
    else
       X(2)=X(2)-YL*(EL%B_SOL)**2*X(1)/four/(one+X(5))
       X(4)=X(4)-YL*(EL%B_SOL)**2*X(3)/four/(one+X(5))
       X(6)=X(6)+YL*(EL%B_SOL)**2*(X(1)**2+X(3)**2)/eight/(one+X(5))**2
    endif


  END SUBROUTINE KICK_SOLR

  SUBROUTINE KICK_SOLP(EL,YL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(SOL5P),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8)  X_MEC(6),B(3),B2,X5

    CALL ALLOC(X5)
    ! NO EXACT EL%EXACT
    if(EL%P%TIME) then
       x5=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
    else
       x5=X(5)
    endif

    IF(EL%P%RADIATION) THEN
       CALL ALLOC(X_MEC,6)
       CALL ALLOC(B,3)
       CALL ALLOC(B2)
       X_MEC(2)=X(2)+EL%B_SOL*EL%P%CHARGE*X(3)/two
       X_MEC(4)=X(4)-EL%B_SOL*EL%P%CHARGE*X(1)/two
       X_MEC(5)=X(5)
       CALL GETMULB_SOL(EL,B,X)
       CALL B2PERP(EL%P,B,X_MEC,X5,B2)
       X5=X(5)
       X(5)=X(5)-CRADF(EL%P)*(one+X(5))**2*B2*(one+half*(X_MEC(2)**2+X_MEC(4)**2)/(one+X(5))**2)*YL
       X(2)=X_MEC(2)*(one+X(5))/(one+X5)-EL%B_SOL*EL%P%CHARGE*X(3)/two
       X(4)=X_MEC(4)*(one+X(5))/(one+X5)+EL%B_SOL*EL%P%CHARGE*X(1)/two
       CALL KILL(X_MEC,6)
       CALL KILL(B,3)
       CALL KILL(B2)
    ENDIF
    if(EL%P%TIME) then
       x5=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)
       X(2)=X(2)-YL*(EL%B_SOL)**2*X(1)/four/x5
       X(4)=X(4)-YL*(EL%B_SOL)**2*X(3)/four/x5
       X(6)=X(6)+(one/EL%P%beta0+x(5))*YL*(EL%B_SOL)**2*(X(1)**2+X(3)**2)/eight/x5**3
    else
       X(2)=X(2)-YL*(EL%B_SOL)**2*X(1)/four/(one+X(5))
       X(4)=X(4)-YL*(EL%B_SOL)**2*X(3)/four/(one+X(5))
       X(6)=X(6)+YL*(EL%B_SOL)**2*(X(1)**2+X(3)**2)/eight/(one+X(5))**2
    endif
    CALL KILL(X5)
  END SUBROUTINE KICK_SOLP

  SUBROUTINE KICK_SOLS(EL,YL,Y)
    IMPLICIT NONE
    TYPE(REAL_8) X(6),XR(6)
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(DAMAP) XP,ID,DISP,XT
    TYPE(SOL5P),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8)  X_MEC(6),B(3),B2,X5,x1,x3,DENF

    logical(lp) done_stoch
    real(dp) B20,B30,BF, v(6) !,R1,R2,DEN0
    INTEGER I,J
    ! NO EXACT EL%EXACT
    CALL ALLOC(X)
    CALL ALLOC(XR)
    CALL ALLOC(XP)
    CALL ALLOC(DISP)
    CALL ALLOC(XT)
    CALL ALLOC(ID)
    CALL ALLOC(X_MEC)
    CALL ALLOC(B,3)
    CALL ALLOC(B2)
    CALL ALLOC(X5)
    CALL ALLOC(X1)
    CALL ALLOC(X3)
    CALL ALLOC(denf)
    if(EL%P%TIME) then
       x5=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
    else
       x5=X(5)
    endif
    X=Y
    XP=X
    XR=X
    X_MEC=X
    X_MEC(2)=X(2)+EL%B_SOL*EL%P%CHARGE*X(3)/two
    X_MEC(4)=X(4)-EL%B_SOL*EL%P%CHARGE*X(1)/two
    X_MEC(5)=X(5)
    IF(EL%P%RADIATION) THEN
       XP%V(2)=X_MEC(2)/(one+X5)
       XP%V(4)=X_MEC(4)/(one+X5)
       CALL GETMULB_SOL(EL,B,X)
       CALL B2PERP(EL%P,B,X_MEC,X5,B2)
       X5=X(5)
       X(5)=X(5)-CRADF(EL%P)*(one+X(5))**2*B2*(one+half*(X_MEC(2)**2+X_MEC(4)**2)/(one+X(5))**2)*YL
       X(2)=X_MEC(2)*(one+X(5))/(one+X5)-EL%B_SOL*EL%P%CHARGE*X(3)/two
       X(4)=X_MEC(4)*(one+X(5))/(one+X5)+EL%B_SOL*EL%P%CHARGE*X(1)/two
    ENDIF

    done_stoch=.false.
    if(EL%P%B0==zero.and.stoch_in_rec) then
       denf=(one+xR(5))**4*(one+half*(X_MEC(2)**2+X_MEC(4)**2)/(one+XR(5))**2)
       b20=b2
       b30=b20**c_1_5
       bf=cflucf(el%p)*b30
       denf=denf*bf*yl
       done_stoch=.true.
    elseif(EL%P%B0/=zero)   then
       done_stoch=.true.
    endif

    if(done_stoch) then

       if(EL%P%B0/=zero) then
          !
          if(knob) then
             v=X_MEC

             DISP=xp*id
             id=1
             DISP=ID-DISP
             XP=DISP*XP

             id=0
             XT=X_MEC
             DISP=XT*ID
             ID=1
             DISP=ID-DISP
             XT=DISP*XT
             xr=xt+V
             CALL B2PERP(EL%P,B,xr,X5,B2)
             denf=(one+xr(5))**4*(one+xr(1)*EL%P%B0+half*(xr(2)**2+xr(4)**2)/(one+xr(5))**2)
             denf=DENF*cflucf(el%p)*yl*b2**c_1_5
          else
             CALL B2PERP(EL%P,B,X_MEC,X5,B2)
             denf=(one+xR(5))**4*(one+half*(X_MEC(2)**2+X_MEC(4)**2)/(one+XR(5))**2)
             b20=b2
             b30=b20**c_1_5
             bf=cflucf(el%p)*b30
             denf=denf*bf*yl
          endif
       endif

       xp=xp**(-1)
       do i=1,6
          do j=1,6
             X1=(xp%v(i)).par.'000010'
             X3=(xp%v(j)).par.'000010'
             denf=denf.par.'000000'
             y(I)%E(J)=y(I)%E(J)+denf*x1*x3
          enddo
       enddo
    endif


    if(EL%P%TIME) then
       x5=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)
       X(2)=X(2)-YL*(EL%B_SOL)**2*X(1)/four/x5
       X(4)=X(4)-YL*(EL%B_SOL)**2*X(3)/four/x5
       X(6)=X(6)+(one/EL%P%beta0+x(5))*YL*(EL%B_SOL)**2*(X(1)**2+X(3)**2)/eight/x5**3
    else
       X(2)=X(2)-YL*(EL%B_SOL)**2*X(1)/four/(one+X(5))
       X(4)=X(4)-YL*(EL%B_SOL)**2*X(3)/four/(one+X(5))
       X(6)=X(6)+YL*(EL%B_SOL)**2*(X(1)**2+X(3)**2)/eight/(one+X(5))**2
    endif
    Y=X
    CALL KILL(XT)
    CALL KILL(DISP)
    CALL KILL(XR)
    CALL KILL(ID)
    CALL KILL(X_MEC)
    CALL KILL(B,3)
    CALL KILL(B2)
    CALL KILL(X1)
    CALL KILL(X3)
    CALL KILL(denf)
    CALL KILL(X5)
    CALL KILL(XP)
    CALL KILL(X)
  END SUBROUTINE KICK_SOLS

  SUBROUTINE GETMULB_SOLR(EL,B,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6),B(3)
    TYPE(SOL5),INTENT(IN):: EL
    real(dp) X1,X3,BBYTW,BBXTW,BBYTWT
    INTEGER J

    X1=X(1)
    X3=X(3)

    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF
    B(1)=BBXTW;B(2)=BBYTW;B(3)=EL%B_SOL;
  END SUBROUTINE GETMULB_SOLR

  SUBROUTINE GETMULB_SOLP(EL,B,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6),B(3)
    TYPE(SOL5P),INTENT(IN):: EL
    TYPE(REAL_8) X1,X3,BBYTW,BBXTW,BBYTWT
    INTEGER J
    CALL ALLOC(X1,X3,BBYTW,BBXTW,BBYTWT)
    X1=X(1)
    X3=X(3)

    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF
    B(1)=BBXTW;B(2)=BBYTW;B(3)=EL%B_SOL;

    CALL KILL(X1,X3,BBYTW,BBXTW,BBYTWT)

  END SUBROUTINE GETMULB_SOLP

  SUBROUTINE KICKMULR(EL,YL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(SOL5),INTENT(IN):: EL
    real(dp),INTENT(IN):: YL
    real(dp) B(3)

    CALL GETMULB_SOL(EL,B,X)

    X(2)=X(2)-YL*EL%P%DIR*EL%P%CHARGE*B(2)
    X(4)=X(4)+YL*EL%P%DIR*EL%P%CHARGE*B(1)

  END SUBROUTINE KICKMULR

  SUBROUTINE KICKMULP(EL,YL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(SOL5P),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) B(3)

    CALL ALLOC(B,3)

    CALL GETMULB_SOL(EL,B,X)

    X(2)=X(2)-YL*EL%P%DIR*EL%P%CHARGE*B(2)
    X(4)=X(4)+YL*EL%P%DIR*EL%P%CHARGE*B(1)

    CALL KILL(B,3)

  END SUBROUTINE KICKMULP

  SUBROUTINE KICKMULS(EL,YL,Y)
    IMPLICIT NONE
    TYPE(REAL_8) X(6)
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(SOL5P),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL

    CALL ALLOC(X,6);

    X=Y
    CALL KICKMUL(EL,YL,X)
    Y=X

    CALL KILL(X,6);

  END SUBROUTINE KICKMULS




  SUBROUTINE SOL_ROTR(EL,YL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(SOL5),INTENT(IN):: EL
    real(dp),INTENT(IN):: YL
    real(dp) myCOS,mySIN,ANG,XT(6)
    INTEGER I

    !    if(bug_intentional) then
    !      Write(6,*) " this PTC version has an intentional bug in SOL5 "
    !      Write(6,*) " Look for bug_intentional to remove it  "
    !      Write(6,*) " this PTC version has an intentional bug in SOL5 "
    !      Write(6,*) " Look for bug_intentional to remove it  "
    !      Write(6,*) " this PTC version has an intentional bug in SOL5 "
    !      Write(6,*) " Look for bug_intentional to remove it  "
    !      Write(6,*) " this PTC version has an intentional bug in SOL5 "
    !      Write(6,*) " Look for bug_intentional to remove it  "
    !      Write(6,*) " this PTC version has an intentional bug in SOL5 "
    !      Write(6,*) " Look for bug_intentional to remove it  "
    !      Write(6,*) " this PTC version has an intentional bug in SOL5 "
    !      Write(6,*) " Look for bug_intentional to remove it  "
    !      bug_intentional=.false.
    !    endif
    if(EL%P%TIME) then   ! bug 2006.1.8
       ANG=YL*EL%B_SOL*EL%P%CHARGE/two/root(one+two*X(5)/EL%P%beta0+x(5)**2)
       !       ANG=YL*EL%B_SOL*EL%P%dir*EL%P%CHARGE/two/root(one+two*X(5)/EL%P%beta0+x(5)**2) ! bug_intentional
    else
       ANG=YL*EL%B_SOL*EL%P%CHARGE/two/(one+X(5))
       !       ANG=YL*EL%B_SOL*EL%P%dir*EL%P%CHARGE/two/(one+X(5))   ! bug_intentional
    endif
    myCOS=COS(ANG)
    mySIN=SIN(ANG)
    ! NO EXACT EL%EXACT

    XT(1)=myCOS*X(1)+mySIN*X(3)
    XT(2)=myCOS*X(2)+mySIN*X(4)
    XT(3)=myCOS*X(3)-mySIN*X(1)
    XT(4)=myCOS*X(4)-mySIN*X(2)

    if(EL%P%TIME) then
       X(6)=X(6)+ANG*(one/EL%P%beta0+x(5))*(X(3)*X(2)-X(1)*X(4))/(one+two*X(5)/EL%P%beta0+x(5)**2)
    else
       X(6)=X(6)+ANG*(X(3)*X(2)-X(1)*X(4))/(one+X(5))
    endif
    DO I=1,4
       X(I)=XT(I)
    ENDDO

  END SUBROUTINE SOL_ROTR

  SUBROUTINE SOL_ROTP(EL,YL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(SOL5P),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) myCOS,mySIN,ANG,XT(6)
    INTEGER I

    CALL ALLOC(myCOS)
    CALL ALLOC(mySIN)
    CALL ALLOC(ANG)
    CALL ALLOC(XT,6)
    if(EL%P%TIME) then   ! bug 2006.1.8
       ANG=YL*EL%B_SOL*EL%P%CHARGE/two/sqrt(one+two*X(5)/EL%P%beta0+x(5)**2)
       !       ANG=YL*EL%B_SOL*EL%P%dir*EL%P%CHARGE/two/sqrt(one+two*X(5)/EL%P%beta0+x(5)**2) ! bug_intentional
    else
       ANG=YL*EL%B_SOL*EL%P%CHARGE/two/(one+X(5))
       !       ANG=YL*EL%B_SOL*EL%P%dir*EL%P%CHARGE/two/(one+X(5))   ! bug_intentional
    endif
    myCOS=COS(ANG)
    mySIN=SIN(ANG)
    ! NO EXACT EL%EXACT

    XT(1)=myCOS*X(1)+mySIN*X(3)
    XT(2)=myCOS*X(2)+mySIN*X(4)
    XT(3)=myCOS*X(3)-mySIN*X(1)
    XT(4)=myCOS*X(4)-mySIN*X(2)

    if(EL%P%TIME) then
       X(6)=X(6)+ANG*(one/EL%P%beta0+x(5))*(X(3)*X(2)-X(1)*X(4))/(one+two*X(5)/EL%P%beta0+x(5)**2)
    else
       X(6)=X(6)+ANG*(X(3)*X(2)-X(1)*X(4))/(one+X(5))
    endif
    DO I=1,4
       X(I)=XT(I)
    ENDDO
    CALL KILL(myCOS)
    CALL KILL(mySIN)
    CALL KILL(ANG)
    CALL KILL(XT,6)
  END SUBROUTINE SOL_ROTP

  SUBROUTINE SOL_ROTS(EL,YL,Y)
    IMPLICIT NONE
    TYPE(REAL_8) X(6)
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(SOL5P),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) myCOS,mySIN,ANG,XT(6)
    INTEGER I

    CALL ALLOC(myCOS)
    CALL ALLOC(mySIN)
    CALL ALLOC(ANG)
    CALL ALLOC(XT,6)
    CALL ALLOC(X,6)
    X=Y
    if(EL%P%TIME) then   ! bug 2006.1.8
       ANG=YL*EL%B_SOL*EL%P%CHARGE/two/sqrt(one+two*X(5)/EL%P%beta0+x(5)**2)
       !       ANG=YL*EL%B_SOL*EL%P%dir*EL%P%CHARGE/two/sqrt(one+two*X(5)/EL%P%beta0+x(5)**2) ! bug_intentional
    else
       ANG=YL*EL%B_SOL*EL%P%CHARGE/two/(one+X(5))
       !       ANG=YL*EL%B_SOL*EL%P%dir*EL%P%CHARGE/two/(one+X(5))   ! bug_intentional
    endif
    myCOS=COS(ANG)
    mySIN=SIN(ANG)
    ! NO EXACT EL%EXACT

    XT(1)=myCOS*X(1)+mySIN*X(3)
    XT(2)=myCOS*X(2)+mySIN*X(4)
    XT(3)=myCOS*X(3)-mySIN*X(1)
    XT(4)=myCOS*X(4)-mySIN*X(2)


    if(EL%P%TIME) then
       X(6)=X(6)+ANG*(one/EL%P%beta0+x(5))*(X(3)*X(2)-X(1)*X(4))/(one+two*X(5)/EL%P%beta0+x(5)**2)
    else
       X(6)=X(6)+ANG*(X(3)*X(2)-X(1)*X(4))/(one+X(5))
    endif
    DO I=1,4
       X(I)=XT(I)
    ENDDO
    Y=X
    CALL KILL(X,6)
    CALL KILL(myCOS)
    CALL KILL(mySIN)
    CALL KILL(ANG)
    CALL KILL(XT,6)
  END SUBROUTINE SOL_ROTS

  SUBROUTINE INTESOLR(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: mid
    TYPE(SOL5),INTENT(IN):: EL
    real(dp) D,DH,DD
    real(dp) D1,D2,DK1,DK2,D2H
    real(dp) dd1,dd2,DK(4),DF(4),DDF(4)
    INTEGER I,J


    IF(PRESENT(MID)) CALL XMID(MID,X,0)


    SELECT CASE(EL%P%METHOD)
    CASE(2)
       DH=EL%L/two/EL%P%NST
       D=EL%L/EL%P%NST
       DD=(EL%P%LD)/two/EL%P%NST


       DO I=1,EL%P%NST
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL SOL_ROT (EL,DH,X)
          CALL KICK_SOL(EL,DH,X)
          CALL KICKMUL(EL,D,X)

          CALL KICK_SOL(EL,DH,X)
          CALL SOL_ROT (EL,DH,X)
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO

    CASE(4)

       D=EL%L/EL%P%NST
       D1=D*FD1
       D2=D*FD2
       DK1=D*FK1
       DK2=D*FK2
       D2H=DK2/two
       DD1=(EL%P%LD)/EL%P%NST*FD1
       DD2=(EL%P%LD)/EL%P%NST*FD2

       DO I=1,EL%P%NST
          CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL SOL_ROT (EL,D1,X)
          CALL KICK_SOL(EL,D1,X)
          CALL KICKMUL(EL,DK1,X)

          CALL KICK_SOL(EL,D1,X)
          CALL SOL_ROT (EL,D1,X)
          CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL SOL_ROT (EL,D2H,X)
          CALL KICK_SOL(EL,D2H,X)
          CALL KICKMUL(EL,DK2,X)
          CALL KICK_SOL(EL,D2H,X)
          CALL SOL_ROT (EL,D2H,X)
          CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL SOL_ROT (EL,D1,X)
          CALL KICK_SOL(EL,D1,X)
          CALL KICKMUL(EL,DK1,X)
          CALL KICK_SOL(EL,D1,X)
          CALL SOL_ROT (EL,D1,X)
          CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO

    CASE(6)
       DO I =1,4
          DK(I)=EL%L*YOSK(I)/EL%P%NST
          DF(I)=DK(I)/two
          DDF(I)=EL%P%LD*YOSK(I)/two/EL%P%NST
       ENDDO
       DO I=1,EL%P%NST
          DO J=4,1,-1
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL SOL_ROT (EL,DF(J),X)
             CALL KICK_SOL(EL,DF(J),X)
             CALL KICKMUL(EL,DK(J),X)
             CALL KICK_SOL(EL,DF(J),X)
             CALL SOL_ROT (EL,DF(J),X)
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          ENDDO

          DO J=2,4
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL SOL_ROT (EL,DF(J),X)
             CALL KICK_SOL(EL,DF(J),X)
             CALL KICKMUL(EL,DK(J),X)
             CALL KICK_SOL(EL,DF(J),X)
             CALL SOL_ROT (EL,DF(J),X)
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          ENDDO
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT



  END SUBROUTINE INTESOLR

  SUBROUTINE INTESOLP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(SOL5P),INTENT(IN):: EL
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: mid
    TYPE(REAL_8) D,DH,D1,D2,D2H,DK1,DK2,DK(4),DF(4)
    real(dp) DD
    real(dp) DD1,DD2,DDF(4)
    INTEGER I,J

    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    SELECT CASE(EL%P%METHOD)
    CASE(2)
       CALL ALLOC(D,DH)
       DH=EL%L/two/EL%P%NST
       D=EL%L/EL%P%NST
       DD=(EL%P%LD)/two/EL%P%NST

       DO I=1,EL%P%NST
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL SOL_ROT (EL,DH,X)
          CALL KICK_SOL(EL,DH,X)
          CALL KICKMUL(EL,D,X)
          CALL KICK_SOL(EL,DH,X)
          CALL SOL_ROT (EL,DH,X)
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO

       CALL KILL(D,DH)
    CASE(4)
       CALL ALLOC(D1,D2,D2H,DK1,DK2)

       D=EL%L/EL%P%NST
       D1=D*FD1
       D2=D*FD2
       DK1=D*FK1
       DK2=D*FK2
       D2H=DK2/two
       DD1=(EL%P%LD)/EL%P%NST*FD1
       DD2=(EL%P%LD)/EL%P%NST*FD2

       DO I=1,EL%P%NST
          CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL SOL_ROT (EL,D1,X)
          CALL KICK_SOL(EL,D1,X)
          CALL KICKMUL(EL,DK1,X)
          CALL KICK_SOL(EL,D1,X)
          CALL SOL_ROT (EL,D1,X)
          CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL SOL_ROT (EL,D2H,X)
          CALL KICK_SOL(EL,D2H,X)
          CALL KICKMUL(EL,DK2,X)
          CALL KICK_SOL(EL,D2H,X)
          CALL SOL_ROT (EL,D2H,X)
          CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL SOL_ROT (EL,D1,X)
          CALL KICK_SOL(EL,D1,X)
          CALL KICKMUL(EL,DK1,X)
          CALL KICK_SOL(EL,D1,X)
          CALL SOL_ROT (EL,D1,X)
          CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
       CALL KILL(D1,D2,D2H,DK1,DK2)
    CASE(6)
       CALL ALLOC(DK,4)
       CALL ALLOC(DF,4)
       DO I =1,4
          DK(I)=EL%L*YOSK(I)/EL%P%NST
          DF(I)=DK(I)/two
          DDF(I)=EL%P%LD*YOSK(I)/two/EL%P%NST
       ENDDO
       DO I=1,EL%P%NST
          DO J=4,1,-1
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL SOL_ROT (EL,DF(J),X)
             CALL KICK_SOL(EL,DF(J),X)
             CALL KICKMUL(EL,DK(J),X)
             CALL KICK_SOL(EL,DF(J),X)
             CALL SOL_ROT (EL,DF(J),X)
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          ENDDO
          DO J=2,4
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL SOL_ROT (EL,DF(J),X)
             CALL KICK_SOL(EL,DF(J),X)
             CALL KICKMUL(EL,DK(J),X)
             CALL KICK_SOL(EL,DF(J),X)
             CALL SOL_ROT (EL,DF(J),X)
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          ENDDO
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
       CALL KILL(DK,4)
       CALL KILL(DF,4)

    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT


  END SUBROUTINE INTESOLP

  SUBROUTINE INTESOLS(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(SOL5P),INTENT(IN):: EL
    TYPE(REAL_8) D,DH,D1,D2,D2H,DK1,DK2,DK(4),DF(4)
    real(dp) DD
    real(dp) DD1,DD2,DDF(4)
    INTEGER I,J

    SELECT CASE(EL%P%METHOD)
    CASE(2)
       CALL ALLOC(D,DH)
       DH=EL%L/two/EL%P%NST
       D=EL%L/EL%P%NST
       DD=(EL%P%LD)/two/EL%P%NST

       DO I=1,EL%P%NST
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL SOL_ROT (EL,DH,X)
          CALL KICK_SOL(EL,DH,X)
          CALL KICKMUL(EL,D,X)
          CALL KICK_SOL(EL,DH,X)
          CALL SOL_ROT (EL,DH,X)
          CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
       ENDDO

       CALL KILL(D,DH)
    CASE(4)
       CALL ALLOC(D1,D2,D2H,DK1,DK2)

       D=EL%L/EL%P%NST
       D1=D*FD1
       D2=D*FD2
       DK1=D*FK1
       DK2=D*FK2
       D2H=DK2/two
       DD1=(EL%P%LD)/EL%P%NST*FD1
       DD2=(EL%P%LD)/EL%P%NST*FD2

       DO I=1,EL%P%NST
          CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL SOL_ROT (EL,D1,X)
          CALL KICK_SOL(EL,D1,X)
          CALL KICKMUL(EL,DK1,X)
          CALL KICK_SOL(EL,D1,X)
          CALL SOL_ROT (EL,D1,X)
          CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL SOL_ROT (EL,D2H,X)
          CALL KICK_SOL(EL,D2H,X)
          CALL KICKMUL(EL,DK2,X)
          CALL KICK_SOL(EL,D2H,X)
          CALL SOL_ROT (EL,D2H,X)
          CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          CALL SOL_ROT (EL,D1,X)
          CALL KICK_SOL(EL,D1,X)
          CALL KICKMUL(EL,DK1,X)
          CALL KICK_SOL(EL,D1,X)
          CALL SOL_ROT (EL,D1,X)
          CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
       ENDDO
       CALL KILL(D1,D2,D2H,DK1,DK2)
    CASE(6)
       CALL ALLOC(DK,4)
       CALL ALLOC(DF,4)
       DO I =1,4
          DK(I)=EL%L*YOSK(I)/EL%P%NST
          DF(I)=DK(I)/two
          DDF(I)=EL%P%LD*YOSK(I)/two/EL%P%NST
       ENDDO
       DO I=1,EL%P%NST
          DO J=4,1,-1
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL SOL_ROT (EL,DF(J),X)
             CALL KICK_SOL(EL,DF(J),X)
             CALL KICKMUL(EL,DK(J),X)
             CALL KICK_SOL(EL,DF(J),X)
             CALL SOL_ROT (EL,DF(J),X)
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          ENDDO
          DO J=2,4
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL SOL_ROT (EL,DF(J),X)
             CALL KICK_SOL(EL,DF(J),X)
             CALL KICKMUL(EL,DK(J),X)
             CALL KICK_SOL(EL,DF(J),X)
             CALL SOL_ROT (EL,DF(J),X)
             CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          ENDDO
       ENDDO
       CALL KILL(DK,4)
       CALL KILL(DF,4)

    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

  END SUBROUTINE INTESOLS

  SUBROUTINE SYMPINTSOLR(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(SOL5),INTENT(INOUT):: EL
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: mid

    IF(EL%P%DIR==1) THEN
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)                    ! Added May 31st 2004
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL INTESOL(EL,X,MID)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)                    ! Added May 31st 2004
    ELSE
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)                    ! Added May 31st 2004
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL INTESOL(EL,X,MID)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)                    ! Added May 31st 2004
    ENDIF

  END SUBROUTINE SYMPINTSOLR

  SUBROUTINE SYMPINTSOLP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(SOL5P),INTENT(INOUT):: EL
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: mid

    IF(EL%P%DIR==1) THEN
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)                    ! Added May 31st 2004
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL INTESOL(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)                    ! Added May 31st 2004
    ELSE
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)                    ! Added May 31st 2004
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL INTESOL(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)                    ! Added May 31st 2004
    ENDIF

  END SUBROUTINE SYMPINTSOLP

  SUBROUTINE SYMPINTSOLS(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(SOL5P),INTENT(INOUT):: EL

    IF(EL%P%DIR==1) THEN
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)                    ! Added May 31st 2004
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL INTESOL(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)                    ! Added May 31st 2004
    ELSE
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)                    ! Added May 31st 2004
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL INTESOL(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)                    ! Added May 31st 2004
    ENDIF

  END SUBROUTINE SYMPINTSOLS

!!!! *************************************************************** !!!!
!!!! *           Beginning of the slow thick element               * !!!!
!!!! *************************************************************** !!!!

  SUBROUTINE SET_IN
    IMPLICIT NONE
    INTEGER I,J,K
    IN=0
    IN1=0
    IN2=0
    K=0
    DO I=1,4
       DO J=I,4
          K=K+1
          IN(I,J)=K;
          IN(J,I)=K
          IN1(K)=I;IN2(K)=J;
       ENDDO
    ENDDO
  END SUBROUTINE SET_IN

  SUBROUTINE GETMATSOLR(EL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(SOLT),INTENT(INOUT):: EL
    real(dp) H(4,4),HL(10,10),V(10),W(10)
    real(dp) DH,X5,BH
    INTEGER I,J,DIR,CHARGE

    DIR=EL%P%DIR*EL%P%CHARGE
    CHARGE=EL%P%CHARGE

    IF(EL%P%METHOD==2.AND.OLD_IMPLEMENTATION_OF_SIXTRACK) THEN
       DH=EL%L/EL%P%NST
    ELSE
       IF(EL%P%METHOD/=6) THEN
          DH=EL%L/EL%P%NST/two
       ELSE
          DH=EL%L/EL%P%NST/four
       ENDIF
    ENDIF


    BH=CHARGE*EL%B_SOL/two


    IF(EL%P%TIME) THEN
       X5=ROOT(one+two*X(5)/el%P%beta0+x(5)**2)-1
    ELSE
       X5=X(5)
    ENDIF
    H(1,1)=zero; H(1,2)=one/(one+X5); H(1,3)=BH/(one+X5);  H(1,4)=zero;

    H(2,1)=(-DIR*EL%BN(2)-BH**2*H(1,2)); H(2,2)=zero; H(2,3)=zero; H(2,4)=BH*H(1,2);

    H(3,1)=-H(1,3);H(3,2)=zero;H(3,3)=zero;H(3,4)=H(1,2);
    H(4,1)=zero;H(4,2)=-BH*H(1,2);H(4,3)=(DIR*EL%BN(2)-BH**2*H(1,2));H(4,4)=zero;
    DO I=1,4
       DO J=1,4
          H(I,J)=DH*H(I,J)
       ENDDO
    ENDDO
    CALL EXPCOSSOL(H,EL%MAT)
    DO I=1,10
       V(I)=zero
       DO J=1,10
          HL(I,J)=zero
       ENDDO
    ENDDO

    DO I=1,10
       do J=1,4
          HL(IN(J,IN2(I)),I)= H(IN1(I),J) + HL(IN(J,IN2(I)),I)
          HL(IN(J,IN1(I)),I)= H(IN2(I),J) + HL(IN(J,IN1(I)),I)
       ENDDO
    ENDDO
    H(1,1)=DH/(one+X5)**2/two
    V(IN(1,1))=H(1,1)*BH**2
    V(IN(3,3))=H(1,1)*BH**2
    V(IN(2,2))=H(1,1)
    V(IN(4,4))=H(1,1)
    V(IN(2,3))=two*H(1,1)*BH
    V(IN(1,4))=-two*H(1,1)*BH
    CALL EXPCOSSOL6(HL,V,W)
    do i=1,10
       EL%LXY(I)=W(I)
    enddo

    IF(EL%P%TIME) THEN         ! SPECIAL TIME FACTOR
       X5=(one/EL%P%beta0+X(5))/(one+X5)     ! dDELTA/dE
       do i=1,10
          EL%LXY(I)=X5*EL%LXY(I)
       enddo
       EL%LXY(0)=DH*X5-(1-EL%P%TOTALPATH)*DH/EL%P%beta0
    ELSE
       EL%LXY(0)=EL%P%TOTALPATH*DH
    ENDIF

  END SUBROUTINE GETMATSOLR

  SUBROUTINE GETMATSOLP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(SOLTP),INTENT(INOUT):: EL
    TYPE(REAL_8) H(4,4),HL(10,10),V(10),W(10)
    TYPE(REAL_8) DH,X5,BH
    INTEGER I,J,DIR,CHARGE

    DO I=1,4
       DO J=1,4
          CALL ALLOC(H(I,J));
       ENDDO
    ENDDO
    CALL ALLOC(DH);CALL ALLOC(X5);CALL ALLOC(BH);

    DIR=EL%P%DIR*EL%P%CHARGE
    CHARGE=EL%P%CHARGE

    IF(EL%P%METHOD==2.AND.OLD_IMPLEMENTATION_OF_SIXTRACK) THEN
       DH=EL%L/EL%P%NST
    ELSE
       IF(EL%P%METHOD/=6) THEN
          DH=EL%L/EL%P%NST/two
       ELSE
          DH=EL%L/EL%P%NST/four
       ENDIF
    ENDIF
    BH=CHARGE*EL%B_SOL/two


    IF(EL%P%TIME) THEN
       X5=SQRT(one+two*X(5)/el%P%beta0+x(5)**2)-1
    ELSE
       X5=X(5)
    ENDIF

    H(1,1)=zero; H(1,2)=one/(one+X5); H(1,3)=BH/(one+X5);  H(1,4)=zero;

    H(2,1)=(-DIR*EL%BN(2)-BH**2*H(1,2));H(2,2)=zero;H(2,3)=zero;H(2,4)=BH*H(1,2);

    H(3,1)=-H(1,3);H(3,2)=zero;H(3,3)=zero;H(3,4)=H(1,2);
    H(4,1)=zero;H(4,2)=-BH*H(1,2);H(4,3)=(DIR*EL%BN(2)-BH**2*H(1,2));H(4,4)=zero;
    DO I=1,4
       DO J=1,4
          H(I,J)=DH*H(I,J)
       ENDDO
    ENDDO
    CALL EXPCOSSOL(H,EL%MAT)
    DO I=1,10
       CALL ALLOC(V(I));CALL ALLOC(W(I))
       DO J=1,10
          CALL ALLOC(HL(I,J))
       ENDDO
    ENDDO

    DO I=1,10
       do J=1,4
          HL(IN(J,IN2(I)),I)= H(IN1(I),J) + HL(IN(J,IN2(I)),I)
          HL(IN(J,IN1(I)),I)= H(IN2(I),J) + HL(IN(J,IN1(I)),I)
       ENDDO
    ENDDO
    H(1,1)=DH/(one+X5)**2/two
    V(IN(1,1))=H(1,1)*BH**2
    V(IN(3,3))=H(1,1)*BH**2
    V(IN(2,2))=H(1,1)
    V(IN(4,4))=H(1,1)
    V(IN(2,3))=two*H(1,1)*BH
    V(IN(1,4))=-two*H(1,1)*BH
    CALL EXPCOSSOL6(HL,V,W)
    do i=1,10
       EL%LXY(I)=W(I)
    enddo

    IF(EL%P%TIME) THEN         ! SPECIAL TIME FACTOR
       X5=(one/EL%P%beta0+X(5))/(one+X5)     ! dDELTA/dE
       do i=1,10
          EL%LXY(I)=X5*EL%LXY(I)
       enddo
       EL%LXY(0)=DH*X5-(1-EL%P%TOTALPATH)*DH/EL%P%beta0
    ELSE
       EL%LXY(0)=EL%P%TOTALPATH*DH
    ENDIF

    DO I=1,4
       DO J=1,4
          CALL KILL(H(I,J));
       ENDDO
    ENDDO
    CALL KILL(DH);CALL KILL(X5);CALL KILL(BH);
    DO I=1,10
       CALL KILL(V(I));CALL KILL(W(I))
       DO J=1,10
          CALL KILL(HL(I,J))
       ENDDO
    ENDDO

  END SUBROUTINE GETMATSOLP


  SUBROUTINE GETMATSOLS(EL,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(SOLTP),INTENT(INOUT):: EL
    TYPE(REAL_8) X(6)

    CALL ALLOC(X)
    X=Y

    CALL GETMATSOL(EL,X)

    Y=X
    CALL KILL(X)

  END SUBROUTINE GETMATSOLS


  SUBROUTINE EXPSOLR(H,MATOUT)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: H(4,4),MATOUT(4,4)
    real(dp) AD(4,4),TEMP(4,4)
    real(dp) NORM,NORM0,NORMAT,NORMAT0
    logical(lp) FIRST
    INTEGER I,J,K,N

    DO I=1,4
       DO J=1,4
          MATOUT(I,J)=zero
          AD(I,J)=zero
          TEMP(I,J)=zero
       ENDDO
       MATOUT(I,I)=one
       AD(I,I)=one
    ENDDO
    FIRST=.TRUE.
    NORM=c_1d6
    NORMAT=c_2d5
    DO N=1,NMAXI
       !  COMPUTING H**N/N!
       DO I=1,4
          DO J=1,4
             DO K=1,4
                TEMP(I,K)=H(I,J)*AD(J,K)+TEMP(I,K)
             ENDDO
          ENDDO
       ENDDO
       NORM0=NORM
       NORMAT0=NORMAT
       !  ADDING TO MATOUT
       NORM=zero
       NORMAT=zero
       DO I=1,4   !2
          DO J=1,4
             AD(I,J)=TEMP(I,J)/N
             MATOUT(I,J)=MATOUT(I,J)+AD(I,J)
             !              NORMAT=NORMAT+ABS(MATOUT(I,J))
             TEMP(I,J)=zero
          ENDDO
       ENDDO
       NORMAT=NORMAT+ABS(MATOUT(1,2))  ! problems with pure Quads
       NORMAT=NORMAT+ABS(MATOUT(3,3))  ! problems with pure Quads
       NORM=ABS(NORMAT-NORMAT0)


       IF(FIRST) THEN
          IF(NORM<EPS_DEF_KIND) THEN
             FIRST=.FALSE.
          ENDIF
       ELSE
          IF(NORM>=NORM0) GOTO 100
       ENDIF

    ENDDO

    w_p=0
    w_p%nc=1
    w_p%fc='(1(1X,A72))'
    write(w_p%c(1),'(A31,1X,I4,1X,A11)') " EXPSOLR FAILED TO CONVERGE IN ",NMAXI," ITERATIONS"
    call write_e(0)
100 CONTINUE

  END SUBROUTINE EXPSOLR

  SUBROUTINE EXPSOLD(H,MATOUT)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: H(4,4),MATOUT(4,4)
    TYPE(REAL_8) AD(4,4),TEMP(4,4)
    real(dp) NORM,NORM0,NORMAT,NORMAT0
    logical(lp) FIRST
    INTEGER I,J,K,N

    DO I=1,4
       DO J=1,4
          MATOUT(I,J)=zero
       ENDDO
       MATOUT(I,I)=one
    ENDDO
    DO I=1,4
       DO J=1,4
          CALL ALLOC(AD(I,J))
          CALL ALLOC(TEMP(I,J))
       ENDDO
       AD(I,I)=one
    ENDDO

    FIRST=.TRUE.
    NORM=c_1d6
    NORMAT=c_2d5
    DO N=1,NMAXI
       !  COMPUTING H**N/N!
       DO I=1,4
          DO J=1,4
             DO K=1,4
                TEMP(I,K)=H(I,J)*AD(J,K)+TEMP(I,K)
             ENDDO
          ENDDO
       ENDDO
       NORM0=NORM
       NORMAT0=NORMAT
       !  ADDING TO MATOUT
       NORM=zero
       NORMAT=zero
       DO I=1,4   !2
          DO J=1,4
             AD(I,J)=TEMP(I,J)/N
             MATOUT(I,J)=MATOUT(I,J)+AD(I,J)
             !              NORMAT=NORMAT+ABS(MATOUT(I,J))
             TEMP(I,J)=zero
          ENDDO
       ENDDO
       NORMAT=NORMAT+ABS(MATOUT(1,2))  ! problems with pure Quads
       NORMAT=NORMAT+ABS(MATOUT(3,3))  ! problems with pure Quads
       NORM=ABS(NORMAT-NORMAT0)


       IF(FIRST) THEN
          IF(NORM<EPS_DEF_KIND) THEN
             FIRST=.FALSE.
          ENDIF
       ELSE
          IF(NORM>=NORM0) GOTO 100
       ENDIF

    ENDDO

    w_p=0
    w_p%nc=1
    w_p%fc='(1(1X,A72))'
    write(w_p%c(1),'(A31,1X,I4,1X,A11)') " EXPSOLR FAILED TO CONVERGE IN ",NMAXI," ITERATIONS"
    call write_e(0)

100 CONTINUE

    DO I=1,4
       DO J=1,4
          CALL KILL(AD(I,J))
          CALL KILL(TEMP(I,J))
       ENDDO
    ENDDO

  END SUBROUTINE EXPSOLD

  SUBROUTINE EXPSOL6R(H,V,MATOUT)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: H(10,10),V(10),MATOUT(10)
    real(dp) AD(10),TEMP(10)
    real(dp) NORM,NORM0,NORMAT,NORMAT0
    logical(lp) FIRST
    INTEGER I,J,N

    DO I=1,10
       MATOUT(I)=V(I)
       AD(I)=V(I)
       TEMP(I)=zero
    ENDDO
    FIRST=.TRUE.
    NORM=c_1d6
    NORMAT=c_2d5
    DO N=1,NMAXI
       !  COMPUTING H**N/N!
       DO I=1,10
          DO J=1,10
             TEMP(I)=H(I,J)*AD(J)+TEMP(I)
          ENDDO
       ENDDO
       NORM0=NORM
       NORMAT0=NORMAT
       !  ADDING TO MATOUT
       NORM=zero
       NORMAT=zero
       DO I=1,10   !2
          AD(I)=TEMP(I)/(N+1)
          MATOUT(I)=MATOUT(I)+AD(I)
          NORMAT=NORMAT+ABS(MATOUT(I))
          TEMP(I)=zero
       ENDDO
       NORM=ABS(NORMAT-NORMAT0)

       IF(FIRST) THEN
          IF(NORM<EPS_DEF_KIND) THEN
             FIRST=.FALSE.
          ENDIF
       ELSE
          IF(NORM>=NORM0) GOTO 100
       ENDIF


    ENDDO

    w_p=0
    w_p%nc=1
    w_p%fc='(1(1X,A72))'
    write(w_p%c(1),'(A31,1X,I4,1X,A11)') " EXPSOLR FAILED TO CONVERGE IN ",NMAXI," ITERATIONS"
    call write_e(0)

100 CONTINUE

  END SUBROUTINE EXPSOL6R

  SUBROUTINE EXPSOL6D(H,V,MATOUT)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: H(10,10),V(10),MATOUT(10)
    TYPE(REAL_8) AD(10),TEMP(10)
    real(dp) NORM,NORM0,NORMAT,NORMAT0
    logical(lp) FIRST
    INTEGER I,J,N
    CALL ALLOC(AD,10)
    CALL ALLOC(TEMP,10)
    DO I=1,10
       MATOUT(I)=V(I)
       AD(I)=V(I)
    ENDDO
    FIRST=.TRUE.
    NORM=c_1d6
    NORMAT=c_2d5
    DO N=1,NMAXI
       !  COMPUTING H**N/N!
       DO I=1,10
          DO J=1,10
             TEMP(I)=H(I,J)*AD(J)+TEMP(I)
          ENDDO
       ENDDO
       NORM0=NORM
       NORMAT0=NORMAT
       !  ADDING TO MATOUT
       NORM=zero
       NORMAT=zero
       DO I=1,10   !2
          AD(I)=TEMP(I)/(N+1)
          MATOUT(I)=MATOUT(I)+AD(I)
          NORMAT=NORMAT+ABS(MATOUT(I))
          TEMP(I)=zero
       ENDDO
       NORM=ABS(NORMAT-NORMAT0)


       IF(FIRST) THEN
          IF(NORM<EPS_DEF_KIND) THEN
             FIRST=.FALSE.
          ENDIF
       ELSE
          IF(NORM>=NORM0) GOTO 100
       ENDIF


    ENDDO

    w_p=0
    w_p%nc=1
    w_p%fc='(1(1X,A72))'
    write(w_p%c(1),'(A31,1X,I4,1X,A11)') " EXPSOLR FAILED TO CONVERGE IN ",NMAXI," ITERATIONS"
    call write_e(0)

100 CONTINUE
    CALL KILL(AD,10)
    CALL KILL(TEMP,10)

  END SUBROUTINE EXPSOL6D


  SUBROUTINE PUSHSOLR(EL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(SOLT),INTENT(IN):: EL
    real(dp) T(6)
    INTEGER I,J

    DO I=1,6
       T(I)=zero
    ENDDO
    DO I=1,4
       DO J=1,4
          T(I)=EL%MAT(I,J)*X(J)+T(I)
       ENDDO
    ENDDO

    T(6)=X(6)+EL%LXY(0)
    DO I=1,10
       T(6)=T(6)+EL%LXY(I)*X(IN1(I))*X(IN2(I))
    ENDDO

    X(1)=T(1);X(2)=T(2);X(3)=T(3);X(4)=T(4);X(6)=T(6);

  END SUBROUTINE PUSHSOLR

  SUBROUTINE PUSHSOLD(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(SOLTP),INTENT(IN):: EL
    TYPE(REAL_8) T(6)
    INTEGER I,J

    CALL ALLOC(T,6)
    DO I=1,4
       DO J=1,4
          T(I)=EL%MAT(I,J)*X(J)+T(I)
       ENDDO
    ENDDO

    T(6)=X(6)+EL%LXY(0)
    DO I=1,10
       T(6)=T(6)+EL%LXY(I)*X(IN1(I))*X(IN2(I))
    ENDDO

    X(1)=T(1);X(2)=T(2);X(3)=T(3);X(4)=T(4);X(6)=T(6);

    CALL KILL(T,6)

  END SUBROUTINE PUSHSOLD

  SUBROUTINE PUSHSOLS(EL,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(SOLTP),INTENT(IN):: EL
    TYPE(REAL_8) X(6)


    CALL ALLOC(X)

    X=Y

    CALL PUSHSOL(EL,X)

    Y=X

    CALL KILL(X)

  END SUBROUTINE PUSHSOLS

  SUBROUTINE INTSOLR(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: MID
    TYPE(SOLT),INTENT(INOUT):: EL
    INTEGER I
    real(dp) DK,DK2,DK4,DK5,DK6,DKT


    IF(PRESENT(MID)) CALL XMID(MID,X,0)
    DKT=EL%L/EL%P%NST
    CALL GETMATSOL(EL,X)

    SELECT CASE(EL%P%METHOD)
    CASE(2)
       DK2=EL%L/EL%P%NST
       DK=DK2/two


       DO I=1,EL%P%NST    !-1
          CALL KICKMUL(EL,DK,X)  ! NEW
          CALL KICKPATH(EL,DK,X)
          CALL PUSHSOL(EL,X)

          if(EL%P%RADIATION) THEN
             CALL KICK_SOL(EL,DK2,X)  ! RADIATION
             CALL GETMATSOL(EL,X)
          ENDIF

          CALL KICKPATH(EL,DK,X)
          CALL KICKMUL(EL,DK,X)  ! NEW
          IF(PRESENT(MID))CALL XMID(MID,X,I)
       ENDDO

    CASE(4)
       DK2=EL%L/EL%P%NST/three
       DK6=two*DK2
       DK=DK2/two

       DO I=1,EL%P%NST     !-1
          CALL KICKMUL(EL,DK,X)    ! NEW
          CALL KICKPATH(EL,DK,X)
          CALL PUSHSOL(EL,X)
          CALL KICKPATH(EL,DK2,X)
          CALL KICKMUL(EL,DK6,X)
          CALL KICKPATH(EL,DK2,X)
          CALL PUSHSOL(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKMUL(EL,DK,X) ! NEW
          if(EL%P%RADIATION) THEN
             CALL KICK_SOL(EL,DKT,X)  ! RADIATION
             CALL GETMATSOL(EL,X)
          ENDIF
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
    CASE(6)
       DK2=c_14*EL%L/EL%P%NST/c_90
       DK4=c_32*EL%L/EL%P%NST/c_90
       DK6=twelve*EL%L/EL%P%NST/c_90
       DK5=DK6/two
       DK=DK2/two


       DO I=1,EL%P%NST    !-1
          CALL KICKMUL(EL,DK,X)   ! NEW
          CALL KICKPATH(EL,DK,X)

          CALL PUSHSOL(EL,X)

          CALL KICKMUL(EL,DK4,X)
          CALL KICKPATH(EL,DK4,X)

          CALL PUSHSOL(EL,X)

          CALL KICKPATH(EL,DK5,X)
          CALL KICKMUL(EL,DK6,X)   ! SYMMETRY POINT
          CALL KICKPATH(EL,DK5,X)

          CALL PUSHSOL(EL,X)

          CALL KICKPATH(EL,DK4,X)
          CALL KICKMUL(EL,DK4,X)

          CALL PUSHSOL(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKMUL(EL,DK,X)   ! NEW
          if(EL%P%RADIATION) THEN
             CALL KICK_SOL(EL,DKT,X)  ! RADIATION
             CALL GETMATSOL(EL,X)
          ENDIF
          IF(PRESENT(MID)) CALL XMID(MID,X,I)

       ENDDO




    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

  END SUBROUTINE INTSOLR


  SUBROUTINE INTSOLP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: mid
    TYPE(SOLTP),INTENT(INOUT):: EL
    INTEGER I
    TYPE(REAL_8) DK,DK2,DK4,DK5,DK6,DKT

    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)
    CALL ALLOC(DKT)
    DKT=EL%L/EL%P%NST
    CALL ALLOC(EL)
    CALL GETMATSOL(EL,X)

    SELECT CASE(EL%P%METHOD)
    CASE(2)
       CALL ALLOC(DK);CALL ALLOC(DK2);
       DK2=EL%L/EL%P%NST
       DK=DK2/two

       DO I=1,EL%P%NST    !-1
          CALL KICKMUL(EL,DK,X)  ! NEW
          CALL KICKPATH(EL,DK,X)
          CALL PUSHSOL(EL,X)

          if(EL%P%RADIATION) THEN
             CALL KICK_SOL(EL,DK2,X)  ! RADIATION
             CALL GETMATSOL(EL,X)
          ENDIF
          CALL KICKPATH(EL,DK,X)
          CALL KICKMUL(EL,DK,X)  ! NEW
          !          IF(PRESENT(MID))CALL XMID(MID,X,I)
       ENDDO
       CALL KILL(DK);CALL KILL(DK2);
    CASE(4)
       CALL ALLOC(DK,DK2,DK6);
       DK2=EL%L/EL%P%NST/three
       DK6=two*DK2
       DK=DK2/two

       DO I=1,EL%P%NST     !-1
          CALL KICKMUL(EL,DK,X)    ! NEW
          CALL KICKPATH(EL,DK,X)
          CALL PUSHSOL(EL,X)
          CALL KICKPATH(EL,DK2,X)
          CALL KICKMUL(EL,DK6,X)
          CALL KICKPATH(EL,DK2,X)
          CALL PUSHSOL(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKMUL(EL,DK,X) ! NEW
          if(EL%P%RADIATION) THEN
             CALL KICK_SOL(EL,DKT,X)  ! RADIATION
             CALL GETMATSOL(EL,X)
          ENDIF
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
       CALL KILL(DK,DK2,DK6);
    CASE(6)
       CALL ALLOC( DK,DK2,DK4,DK5,DK6);
       DK2=c_14*EL%L/EL%P%NST/c_90
       DK4=c_32*EL%L/EL%P%NST/c_90
       DK6=twelve*EL%L/EL%P%NST/c_90
       DK5=DK6/two
       DK=DK2/two


       DO I=1,EL%P%NST    !-1
          CALL KICKMUL(EL,DK,X)   ! NEW
          CALL KICKPATH(EL,DK,X)

          CALL PUSHSOL(EL,X)

          CALL KICKMUL(EL,DK4,X)
          CALL KICKPATH(EL,DK4,X)

          CALL PUSHSOL(EL,X)

          CALL KICKPATH(EL,DK5,X)
          CALL KICKMUL(EL,DK6,X)   ! SYMMETRY POINT
          CALL KICKPATH(EL,DK5,X)

          CALL PUSHSOL(EL,X)

          CALL KICKPATH(EL,DK4,X)
          CALL KICKMUL(EL,DK4,X)

          CALL PUSHSOL(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKMUL(EL,DK,X)   ! NEW
          if(EL%P%RADIATION) THEN
             CALL KICK_SOL(EL,DKT,X)  ! RADIATION
             CALL GETMATSOL(EL,X)
          ENDIF
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)

       ENDDO

       CALL KILL( DK,DK2,DK4,DK5,DK6);

    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

    CALL KILL(EL)
    CALL KILL(DKT)

  END SUBROUTINE INTSOLP

  SUBROUTINE INTSOLS(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(SOLTP),INTENT(INOUT):: EL
    INTEGER I
    TYPE(REAL_8) DK,DK2,DK4,DK5,DK6,DKT



    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)
    CALL ALLOC(DKT)
    DKT=EL%L/EL%P%NST
    CALL ALLOC(EL)
    CALL GETMATSOL(EL,X)

    SELECT CASE(EL%P%METHOD)
    CASE(2)
       CALL ALLOC(DK);CALL ALLOC(DK2);
       DK2=EL%L/EL%P%NST
       DK=DK2/two

       DO I=1,EL%P%NST    !-1
          CALL KICKMUL(EL,DK,X)  ! NEW
          CALL KICKPATH(EL,DK,X)
          CALL PUSHSOL(EL,X)

          if(EL%P%RADIATION) THEN
             CALL KICK_SOL(EL,DK2,X)  ! RADIATION
             CALL GETMATSOL(EL,X)
          ENDIF
          CALL KICKPATH(EL,DK,X)
          CALL KICKMUL(EL,DK,X)  ! NEW
          !          IF(PRESENT(MID))CALL XMID(MID,X,I)
       ENDDO
       CALL KILL(DK);CALL KILL(DK2);
    CASE(4)
       CALL ALLOC(DK,DK2,DK6);
       DK2=EL%L/EL%P%NST/three
       DK6=two*DK2
       DK=DK2/two

       DO I=1,EL%P%NST     !-1
          CALL KICKMUL(EL,DK,X)    ! NEW
          CALL KICKPATH(EL,DK,X)
          CALL PUSHSOL(EL,X)
          CALL KICKPATH(EL,DK2,X)
          CALL KICKMUL(EL,DK6,X)
          CALL KICKPATH(EL,DK2,X)
          CALL PUSHSOL(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKMUL(EL,DK,X) ! NEW
          if(EL%P%RADIATION) THEN
             CALL KICK_SOL(EL,DKT,X)  ! RADIATION
             CALL GETMATSOL(EL,X)
          ENDIF
          !       IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
       CALL KILL(DK,DK2,DK6);
    CASE(6)
       CALL ALLOC( DK,DK2,DK4,DK5,DK6);
       DK2=c_14*EL%L/EL%P%NST/c_90
       DK4=c_32*EL%L/EL%P%NST/c_90
       DK6=twelve*EL%L/EL%P%NST/c_90
       DK5=DK6/two
       DK=DK2/two


       DO I=1,EL%P%NST    !-1
          CALL KICKMUL(EL,DK,X)   ! NEW
          CALL KICKPATH(EL,DK,X)

          CALL PUSHSOL(EL,X)

          CALL KICKMUL(EL,DK4,X)
          CALL KICKPATH(EL,DK4,X)

          CALL PUSHSOL(EL,X)

          CALL KICKPATH(EL,DK5,X)
          CALL KICKMUL(EL,DK6,X)   ! SYMMETRY POINT
          CALL KICKPATH(EL,DK5,X)

          CALL PUSHSOL(EL,X)

          CALL KICKPATH(EL,DK4,X)
          CALL KICKMUL(EL,DK4,X)

          CALL PUSHSOL(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKMUL(EL,DK,X)   ! NEW
          if(EL%P%RADIATION) THEN
             CALL KICK_SOL(EL,DKT,X)  ! RADIATION
             CALL GETMATSOL(EL,X)
          ENDIF
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)

       ENDDO

       CALL KILL( DK,DK2,DK4,DK5,DK6);

    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

    CALL KILL(EL)
    CALL KILL(DKT)

  END SUBROUTINE INTSOLS


  SUBROUTINE SYMPINTSOLTR(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(SOLT),INTENT(INOUT):: EL
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: mid


    IF(EL%P%DIR==1) THEN
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)                    ! Added May 31st 2004
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL INTESOL(EL,X,MID)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)                    ! Added May 31st 2004
    ELSE
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)                    ! Added May 31st 2004
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL INTESOL(EL,X,MID)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)                    ! Added May 31st 2004
    ENDIF





  END SUBROUTINE SYMPINTSOLTR

  SUBROUTINE SYMPINTSOLTP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(SOLTP),INTENT(INOUT):: EL
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: mid

    IF(EL%P%DIR==1) THEN
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)                    ! Added May 31st 2004
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL INTESOL(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)                    ! Added May 31st 2004
    ELSE
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)                    ! Added May 31st 2004
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL INTESOL(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)                    ! Added May 31st 2004
    ENDIF


  END SUBROUTINE SYMPINTSOLTP

  SUBROUTINE SYMPINTSOLTS(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(SOLTP),INTENT(INOUT):: EL

    IF(EL%P%DIR==1) THEN
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)                    ! Added May 31st 2004
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL INTESOL(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)                    ! Added May 31st 2004
    ELSE
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)                    ! Added May 31st 2004
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL INTESOL(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)                    ! Added May 31st 2004
    ENDIF

  END SUBROUTINE SYMPINTSOLTS


  SUBROUTINE GETMULB_SOLTR(EL,B,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6),B(3)
    TYPE(SOLT),INTENT(IN):: EL
    real(dp) X1,X3,BBYTW,BBXTW,BBYTWT
    INTEGER J

    X1=X(1)
    X3=X(3)

    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF
    B(1)=BBXTW;B(2)=BBYTW;B(3)=EL%B_SOL;
  END SUBROUTINE GETMULB_SOLTR

  SUBROUTINE GETMULB_SOLTP(EL,B,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6),B(3)
    TYPE(SOLTP),INTENT(IN):: EL
    TYPE(REAL_8) X1,X3,BBYTW,BBXTW,BBYTWT
    INTEGER J
    CALL ALLOC(X1,X3,BBYTW,BBXTW,BBYTWT)
    X1=X(1)
    X3=X(3)

    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF
    B(1)=BBXTW;B(2)=BBYTW;B(3)=EL%B_SOL;

    CALL KILL(X1,X3,BBYTW,BBXTW,BBYTWT)

  END SUBROUTINE GETMULB_SOLTP

  SUBROUTINE KICKMULTR(EL,YL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(SOLT),INTENT(IN):: EL
    real(dp),INTENT(IN):: YL
    real(dp) B(3)

    CALL GETMULB_SOL(EL,B,X)

    X(2)=X(2)-YL*EL%P%DIR*EL%P%CHARGE*(B(2)-EL%BN(2)*X(1))
    X(4)=X(4)+YL*EL%P%DIR*EL%P%CHARGE*(B(1)-EL%BN(2)*X(3))

  END SUBROUTINE KICKMULTR

  SUBROUTINE KICKMULTP(EL,YL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(SOLTP),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) B(3)

    CALL ALLOC(B,3)

    CALL GETMULB_SOL(EL,B,X)

    X(2)=X(2)-YL*EL%P%DIR*EL%P%CHARGE*(B(2)-EL%BN(2)*X(1))
    X(4)=X(4)+YL*EL%P%DIR*EL%P%CHARGE*(B(1)-EL%BN(2)*X(3))

    CALL KILL(B,3)

  END SUBROUTINE KICKMULTP

  SUBROUTINE KICKMULTS(EL,YL,Y)
    IMPLICIT NONE
    TYPE(REAL_8) X(6)
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(SOLTP),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL

    CALL ALLOC(X,6);

    X=Y
    CALL KICKMUL(EL,YL,X)
    Y=X

    CALL KILL(X,6);

  END SUBROUTINE KICKMULTS

  SUBROUTINE KICK_SOLTR(EL,YL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(SOLt),INTENT(IN):: EL
    real(dp),INTENT(IN):: YL
    real(dp)  X_MEC(6),B(3),B2,X5

    IF(EL%P%RADIATION) THEN
       ! NO EXACT EL%EXACT
       if(EL%P%TIME) then
          x5=ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
       else
          x5=X(5)
       endif


       X_MEC=zero
       X_MEC(2)=X(2)+EL%B_SOL*EL%P%CHARGE*X(3)/two
       X_MEC(4)=X(4)-EL%B_SOL*EL%P%CHARGE*X(1)/two
       X_MEC(5)=X(5)
       CALL GETMULB_SOL(EL,B,X)
       CALL B2PERP(EL%P,B,X_MEC,X5,B2)
       X5=X(5)
       X(5)=X(5)-CRADF(EL%P)*(one+X(5))**2*B2*(one+half*(X_MEC(2)**2+X_MEC(4)**2)/(one+X(5))**2)*YL
       X(2)=X_MEC(2)*(one+X(5))/(one+X5)-EL%B_SOL*EL%P%CHARGE*X(3)/two
       X(4)=X_MEC(4)*(one+X(5))/(one+X5)+EL%B_SOL*EL%P%CHARGE*X(1)/two
    ENDIF


  END SUBROUTINE KICK_SOLTR

  SUBROUTINE KICK_SOLTP(EL,YL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(SOLTP),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8)  X_MEC(6),B(3),B2,X5

    IF(EL%P%RADIATION) THEN
       CALL ALLOC(X5)
       ! NO EXACT EL%EXACT
       if(EL%P%TIME) then
          x5=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
       else
          x5=X(5)
       endif

       CALL ALLOC(X_MEC,6)
       CALL ALLOC(B,3)
       CALL ALLOC(B2)
       X_MEC(2)=X(2)+EL%B_SOL*EL%P%CHARGE*X(3)/two
       X_MEC(4)=X(4)-EL%B_SOL*EL%P%CHARGE*X(1)/two
       X_MEC(5)=X(5)
       CALL GETMULB_SOL(EL,B,X)
       CALL B2PERP(EL%P,B,X_MEC,X5,B2)
       X5=X(5)
       X(5)=X(5)-CRADF(EL%P)*(one+X(5))**2*B2*(one+half*(X_MEC(2)**2+X_MEC(4)**2)/(one+X(5))**2)*YL
       X(2)=X_MEC(2)*(one+X(5))/(one+X5)-EL%B_SOL*EL%P%CHARGE*X(3)/two
       X(4)=X_MEC(4)*(one+X(5))/(one+X5)+EL%B_SOL*EL%P%CHARGE*X(1)/two
       CALL KILL(X_MEC,6)
       CALL KILL(B,3)
       CALL KILL(B2)
       CALL KILL(X5)
    ENDIF
  END SUBROUTINE KICK_SOLTP

  SUBROUTINE KICK_SOLTS(EL,YL,Y)
    IMPLICIT NONE
    TYPE(REAL_8) X(6),XR(6)
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(DAMAP) XP,ID,DISP,XT
    TYPE(SOLTP),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8)  X_MEC(6),B(3),B2,X5,x1,x3,DENF

    logical(lp) done_stoch
    real(dp) B20,B30,BF, v(6) !,R1,R2,DEN0
    INTEGER I,J
    ! NO EXACT EL%EXACT
    IF(EL%P%RADIATION) THEN
       CALL ALLOC(X)
       CALL ALLOC(XR)
       CALL ALLOC(XP)
       CALL ALLOC(DISP)
       CALL ALLOC(XT)
       CALL ALLOC(ID)
       CALL ALLOC(X_MEC)
       CALL ALLOC(B,3)
       CALL ALLOC(B2)
       CALL ALLOC(X5)
       CALL ALLOC(X1)
       CALL ALLOC(X3)
       CALL ALLOC(denf)
       if(EL%P%TIME) then
          x5=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
       else
          x5=X(5)
       endif
       X=Y
       XP=X
       XR=X
       X_MEC=X
       X_MEC(2)=X(2)+EL%B_SOL*EL%P%CHARGE*X(3)/two
       X_MEC(4)=X(4)-EL%B_SOL*EL%P%CHARGE*X(1)/two
       X_MEC(5)=X(5)
       XP%V(2)=X_MEC(2)/(one+X5)
       XP%V(4)=X_MEC(4)/(one+X5)
       CALL GETMULB_SOL(EL,B,X)
       CALL B2PERP(EL%P,B,X_MEC,X5,B2)
       X5=X(5)
       X(5)=X(5)-CRADF(EL%P)*(one+X(5))**2*B2*(one+half*(X_MEC(2)**2+X_MEC(4)**2)/(one+X(5))**2)*YL
       X(2)=X_MEC(2)*(one+X(5))/(one+X5)-EL%B_SOL*EL%P%CHARGE*X(3)/two
       X(4)=X_MEC(4)*(one+X(5))/(one+X5)+EL%B_SOL*EL%P%CHARGE*X(1)/two

       done_stoch=.false.
       if(EL%P%B0==zero.and.stoch_in_rec) then
          denf=(one+xR(5))**4*(one+half*(X_MEC(2)**2+X_MEC(4)**2)/(one+XR(5))**2)
          b20=b2
          b30=b20**c_1_5
          bf=cflucf(el%p)*b30
          denf=denf*bf*yl
          done_stoch=.true.
       elseif(EL%P%B0/=zero)   then
          done_stoch=.true.
       endif

       if(done_stoch) then

          if(EL%P%B0/=zero) then
             !
             if(knob) then
                v=X_MEC

                DISP=xp*id
                id=1
                DISP=ID-DISP
                XP=DISP*XP

                id=0
                XT=X_MEC
                DISP=XT*ID
                ID=1
                DISP=ID-DISP
                XT=DISP*XT
                xr=xt+V
                CALL B2PERP(EL%P,B,xr,X5,B2)
                denf=(one+xr(5))**4*(one+xr(1)*EL%P%B0+half*(xr(2)**2+xr(4)**2)/(one+xr(5))**2)
                denf=DENF*cflucf(el%p)*yl*b2**c_1_5
             else
                CALL B2PERP(EL%P,B,X_MEC,X5,B2)
                denf=(one+xR(5))**4*(one+half*(X_MEC(2)**2+X_MEC(4)**2)/(one+XR(5))**2)
                b20=b2
                b30=b20**c_1_5
                bf=cflucf(el%p)*b30
                denf=denf*bf*yl
             endif
          endif

          xp=xp**(-1)
          do i=1,6
             do j=1,6
                X1=(xp%v(i)).par.'000010'
                X3=(xp%v(j)).par.'000010'
                denf=denf.par.'000000'
                y(I)%E(J)=y(I)%E(J)+denf*x1*x3
             enddo
          enddo
       endif


       Y=X
       CALL KILL(XT)
       CALL KILL(DISP)
       CALL KILL(XR)
       CALL KILL(ID)
       CALL KILL(X_MEC)
       CALL KILL(B,3)
       CALL KILL(B2)
       CALL KILL(X1)
       CALL KILL(X3)
       CALL KILL(denf)
       CALL KILL(X5)
       CALL KILL(XP)
       CALL KILL(X)
    ENDIF
  END SUBROUTINE KICK_SOLTS

  SUBROUTINE KICKPATH6TR(EL,YL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(SOLT),INTENT(IN):: EL
    real(dp),INTENT(IN):: YL
    real(dp) PZ,PZ0
    ! ETIENNE
    IF(.NOT.EL%P%EXACT) RETURN
    if(EL%P%TIME) then
       PZ=root(one+two*X(5)/EL%P%beta0+x(5)**2-X(2)**2-X(4)**2)
       PZ0=root(one+two*X(5)/EL%P%beta0+x(5)**2)
       X(6)=X(6)+YL*(one/EL%P%beta0+x(5))*(X(2)**2+X(4)**2)*(one/PZ/(PZ+PZ0)-one/PZ0**2/two) &
            &     /PZ0
       PZ=(X(2)**2+X(4)**2)/PZ/PZ0/(PZ+PZ0)   ! = (one/PZ-one/PZ0)
       X(1)=X(1)+YL*X(2)*PZ
       X(3)=X(3)+YL*X(4)*PZ
    else
       PZ=root((one+X(5))**2-X(2)**2-X(4)**2)
       PZ0=one+X(5)
       X(6)=X(6)+YL*(X(2)**2+X(4)**2)*(one/PZ/(PZ+PZ0)-one/PZ0**2/two)
       PZ=(X(2)**2+X(4)**2)/PZ/PZ0/(PZ+PZ0)   ! = (one/PZ-one/PZ0)
       X(1)=X(1)+YL*X(2)*PZ
       X(3)=X(3)+YL*X(4)*PZ
    endif

  END SUBROUTINE KICKPATH6TR

  SUBROUTINE KICKPATH6TP(EL,YL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(SOLTP),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) PZ,PZ0
    ! ETIENNE
    IF(.NOT.EL%P%EXACT) RETURN
    CALL ALLOC(PZ,PZ0)
    if(EL%P%TIME) then
       PZ=sqrt(one+two*X(5)/EL%P%beta0+x(5)**2-X(2)**2-X(4)**2)
       PZ0=sqrt(one+two*X(5)/EL%P%beta0+x(5)**2)
       X(6)=X(6)+YL*(one/EL%P%beta0+x(5))*(X(2)**2+X(4)**2)*(one/PZ/(PZ+PZ0)-one/PZ0**2/two) &
            &     /PZ0
       PZ=(X(2)**2+X(4)**2)/PZ/PZ0/(PZ+PZ0)   ! = (one/PZ-one/PZ0)
       X(1)=X(1)+YL*X(2)*PZ
       X(3)=X(3)+YL*X(4)*PZ
    else
       PZ=sqrt((one+X(5))**2-X(2)**2-X(4)**2)
       PZ0=one+X(5)
       X(6)=X(6)+YL*(X(2)**2+X(4)**2)*(one/PZ/(PZ+PZ0)-one/PZ0**2/two)
       PZ=(X(2)**2+X(4)**2)/PZ/PZ0/(PZ+PZ0)   ! = (one/PZ-one/PZ0)
       X(1)=X(1)+YL*X(2)*PZ
       X(3)=X(3)+YL*X(4)*PZ
    endif
    CALL KILL(PZ,PZ0)

  END SUBROUTINE KICKPATH6TP

  SUBROUTINE KICKPATH6TS(EL,YL,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(SOLTP),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) X(6)
    ! ETIENNE
    IF(.NOT.EL%P%EXACT) RETURN
    CALL ALLOC(X)

    X=Y

    CALL KICKPATH(EL,YL,X)

    Y=X

    CALL KILL(X)

  END SUBROUTINE KICKPATH6TS


!!!! *************************************************************** !!!!
!!!! *           Beginning of the slow thick element               * !!!!
!!!! *************************************************************** !!!!

  SUBROUTINE GETMATR(EL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(KTK),INTENT(INOUT):: EL
    real(dp) HX(3,3),HY(3,3),HL(6,6),V(6),W(6)
    real(dp) DH,X5,X6
    INTEGER I,J,DIR

    DIR=EL%P%DIR*EL%P%CHARGE


    IF(EL%P%METHOD==2.AND.OLD_IMPLEMENTATION_OF_SIXTRACK) THEN
       DH=EL%L/EL%P%NST
    ELSE
       IF(EL%P%METHOD/=6) THEN
          DH=EL%L/EL%P%NST/two
       ELSE
          DH=EL%L/EL%P%NST/four
       ENDIF
    ENDIF

    IF(EL%P%TIME) THEN
       X5=ROOT(one+two*X(5)/el%P%beta0+x(5)**2)-1
    ELSE
       X5=X(5)
    ENDIF

    HX(1,1)=zero;HX(1,2)=DH/(one+X5);HX(1,3)=zero;
    HX(2,1)=DIR*DH*(-EL%BN(2)-EL%P%B0*EL%BN(1));HX(2,2)=zero;HX(2,3)=DH*EL%P%B0;
    HX(3,1)=zero;HX(3,2)=zero;HX(3,3)=zero;
    HY(1,1)=zero;HY(1,2)=HX(1,2);HY(1,3)=zero;
    HY(2,1)=DH*DIR*EL%BN(2);HY(2,2)=zero;HY(2,3)=zero;
    HY(3,1)=zero;HY(3,2)=zero;HY(3,3)=zero;
    CALL EXPCOSY(HX,EL%MATX)
    CALL EXPCOSY(HY,EL%MATY)
    DO I=1,6
       V(I)=zero
       DO J=1,6
          HL(I,J)=zero
       ENDDO
    ENDDO
    HL(1,3)=HX(2,3)*X5; HL(2,3)=HX(2,1); HL(3,2)=HX(1,2);
    HL(4,5)=HX(2,1); HL(6,5)=HX(1,2); HL(2,5)=HX(2,3)*X5;
    HL(5,6)=two*HX(2,1); HL(3,6)=two*HX(2,3)*X5;HL(5,4)=two*HX(1,2);
    V(2)=HX(2,3)
    V(6)=HX(1,2)/(one+X5)/two;
    CALL EXPCOSY6(HL,V,W)
    do i=1,6
       EL%LX(I)=W(I)
    enddo
    DO I=1,6
       V(I)=zero
       DO J=1,6
          HL(I,J)=zero
       ENDDO
    ENDDO
    HL(2,3)=HY(2,1); HL(3,2)=HY(1,2);
    HL(4,5)=HY(2,1); HL(6,5)=HY(1,2)
    HL(5,6)=two*HY(2,1);HL(5,4)=two*HY(1,2);
    V(6)=HY(1,2)/(one+X5)/two;
    CALL EXPCOSY6(HL,V,W)

    do i=1,3
       EL%LY(I)=W(3+I)
    enddo


    IF(EL%P%TIME) THEN         ! SPECIAL TIME FACTOR
       X6=(X(5)+two/EL%P%beta0)/(two+X5)              ! DELTA/E
       X5=(one/EL%P%beta0+X(5))/(one+X5)     ! dDELTA/dE
       EL%MATX(1,3)=EL%MATX(1,3)*X6
       EL%MATX(2,3)=EL%MATX(2,3)*X6
       do i=1,6
          EL%LX(I)=X5*EL%LX(I)
       enddo
       do i=1,3
          EL%LY(I)=X5*EL%LY(I)
       enddo
       ! BUG FOUND BY SCHMIDT
       !       EL%LX(1)=EL%LX(1)+EL%P%TOTALPATH*DH*X5
       EL%LX(1)=EL%LX(1)+DH*X5-(1-EL%P%TOTALPATH)*DH/EL%P%beta0
    ELSE
       EL%LX(1)=EL%LX(1)+EL%P%TOTALPATH*DH
    ENDIF

  END SUBROUTINE GETMATR

  SUBROUTINE GETMATD(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(KTKP),INTENT(INOUT):: EL
    TYPE(REAL_8) HX(3,3),HY(3,3),HL(6,6),V(6),W(6)
    TYPE(REAL_8) DH,X5,X6
    INTEGER I,J,DIR

    DIR=EL%P%DIR*EL%P%CHARGE

    DO I=1,3
       DO J=1,3
          CALL ALLOC(HX(I,J));CALL ALLOC(HY(I,J))
       ENDDO
    ENDDO
    DO I=1,6
       CALL ALLOC(V(I));CALL ALLOC(W(I))
       DO J=1,6
          CALL ALLOC(HL(I,J))
       ENDDO
    ENDDO
    CALL ALLOC(DH);CALL ALLOC(X5);CALL ALLOC(X6);
    IF(EL%P%METHOD==2.AND.OLD_IMPLEMENTATION_OF_SIXTRACK) THEN
       DH=EL%L/EL%P%NST
    ELSE
       IF(EL%P%METHOD/=6) THEN
          DH=EL%L/EL%P%NST/two
       ELSE
          DH=EL%L/EL%P%NST/four
       ENDIF
    ENDIF

    IF(EL%P%TIME) THEN
       X5=SQRT(one+two*X(5)/el%P%beta0+x(5)**2)-1
    ELSE
       X5=X(5)
    ENDIF
    HX(1,1)=zero;HX(1,2)=DH/(one+X5);HX(1,3)=zero;
    HX(2,1)=DIR*DH*(-EL%BN(2)-EL%P%B0*EL%BN(1));HX(2,2)=zero;HX(2,3)=DH*EL%P%B0;
    HX(3,1)=zero;HX(3,2)=zero;HX(3,3)=zero;
    HY(1,1)=zero;HY(1,2)=HX(1,2);HY(1,3)=zero;
    HY(2,1)=DH*DIR*EL%BN(2);HY(2,2)=zero;HY(2,3)=zero;
    HY(3,1)=zero;HY(3,2)=zero;HY(3,3)=zero;
    CALL EXPCOSY(HX,EL%MATX)
    CALL EXPCOSY(HY,EL%MATY)
    DO I=1,6
       V(I)=zero
       DO J=1,6
          HL(I,J)=zero
       ENDDO
    ENDDO
    HL(1,3)=HX(2,3)*X5; HL(2,3)=HX(2,1); HL(3,2)=HX(1,2);
    HL(4,5)=HX(2,1); HL(6,5)=HX(1,2); HL(2,5)=HX(2,3)*X5;
    HL(5,6)=two*HX(2,1); HL(3,6)=two*HX(2,3)*X5;HL(5,4)=two*HX(1,2);
    V(2)=HX(2,3)
    V(6)=HX(1,2)/(one+X5)/two;
    CALL EXPCOSY6(HL,V,W)
    do i=1,6
       EL%LX(I)=W(I)
    enddo
    DO I=1,6
       V(I)=zero
       DO J=1,6
          HL(I,J)=zero
       ENDDO
    ENDDO
    HL(2,3)=HY(2,1); HL(3,2)=HY(1,2);
    HL(4,5)=HY(2,1); HL(6,5)=HY(1,2)
    HL(5,6)=two*HY(2,1);HL(5,4)=two*HY(1,2);
    V(6)=HY(1,2)/(one+X5)/two;
    CALL EXPCOSY6(HL,V,W)

    do i=1,3
       EL%LY(I)=W(3+I)
    enddo

    IF(EL%P%TIME) THEN         ! SPECIAL TIME FACTOR
       X6=(X(5)+two/EL%P%beta0)/(two+X5)              ! DELTA/E
       X5=(one/EL%P%beta0+X(5))/(one+X5)     ! dDELTA/dE
       EL%MATX(1,3)=EL%MATX(1,3)*X6
       EL%MATX(2,3)=EL%MATX(2,3)*X6
       do i=1,6
          EL%LX(I)=X5*EL%LX(I)
       enddo
       do i=1,3
          EL%LY(I)=X5*EL%LY(I)
       enddo
       ! BUG FOUND BY SCHMIDT
       !       EL%LX(1)=EL%LX(1)+EL%P%TOTALPATH*DH*X5
       EL%LX(1)=EL%LX(1)+DH*X5-(1-EL%P%TOTALPATH)*DH/EL%P%beta0
    ELSE
       EL%LX(1)=EL%LX(1)+EL%P%TOTALPATH*DH
    ENDIF


    DO I=1,3
       DO J=1,3
          CALL KILL(HX(I,J));CALL KILL(HY(I,J))
       ENDDO
    ENDDO
    DO I=1,6
       CALL KILL(V(I));CALL KILL(W(I))
       DO J=1,6;CALL KILL(HL(I,J))
       ENDDO
    ENDDO
    CALL KILL(DH);CALL KILL(X5);CALL KILL(X6);


  END SUBROUTINE GETMATD


  SUBROUTINE GETMATS(EL,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(KTKP),INTENT(INOUT):: EL
    TYPE(REAL_8) X(6)

    CALL ALLOC(X)
    X=Y

    CALL GETMAT(EL,X)

    Y=X
    CALL KILL(X)

  END SUBROUTINE GETMATS




  SUBROUTINE EXPR(H,MATOUT)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: H(3,3),MATOUT(2,3)
    real(dp) AD(3,3),TEMP(3,3)
    real(dp) NORM,NORM0,NORMAT,NORMAT0
    logical(lp) FIRST
    INTEGER I,J,K,N

    DO I=1,2
       DO J=1,3
          MATOUT(I,J)=zero
       ENDDO
    ENDDO
    DO I=1,3
       DO J=1,3
          AD(I,J)=zero
          TEMP(I,J)=zero
       ENDDO
    ENDDO
    MATOUT(1,1)=one
    MATOUT(2,2)=one
    AD(1,1)=one
    AD(2,2)=one
    AD(3,3)=one
    FIRST=.TRUE.
    NORM=c_1d6
    NORMAT=c_2d5
    DO N=1,NMAXI
       !  COMPUTING H**N/N!
       DO I=1,3
          DO J=1,3
             DO K=1,3
                TEMP(I,K)=H(I,J)*AD(J,K)+TEMP(I,K)
             ENDDO
          ENDDO
       ENDDO
       NORM0=NORM
       NORMAT0=NORMAT
       !  ADDING TO MATOUT
       NORM=zero
       NORMAT=zero
       DO I=1,3   !2
          DO J=1,3
             AD(I,J)=TEMP(I,J)/N
             IF(I/=3) MATOUT(I,J)=MATOUT(I,J)+AD(I,J)
             IF(I/=3) NORMAT=NORMAT+ABS(MATOUT(I,J))
             TEMP(I,J)=zero
          ENDDO
       ENDDO
       NORM=ABS(NORMAT-NORMAT0)


       IF(FIRST) THEN
          IF(NORM<EPS_DEF_KIND) THEN
             FIRST=.FALSE.
          ENDIF
       ELSE
          IF(NORM>=NORM0) GOTO 100
       ENDIF


    ENDDO

    w_p=0
    w_p%nc=1
    w_p%fc='(1(1X,A72))'
    write(w_p%c(1),'(A31,1X,I4,1X,A11)') " EXPSOLR FAILED TO CONVERGE IN ",NMAXI," ITERATIONS"
    call write_e(0)

100 CONTINUE

  END SUBROUTINE EXPR

  SUBROUTINE EXPD(H,MATOUT)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: H(3,3),MATOUT(2,3)
    TYPE(REAL_8) AD(3,3),TEMP(3,3)
    real(dp) NORM,NORM0,NORMAT,NORMAT0
    logical(lp) FIRST
    INTEGER I,J,K,N

    DO I=1,2
       DO J=1,3
          MATOUT(I,J)=zero
       ENDDO
    ENDDO
    DO I=1,3
       DO J=1,3
          CALL ALLOC(AD(I,J))
          CALL ALLOC(TEMP(I,J))
       ENDDO
    ENDDO
    MATOUT(1,1)=one
    MATOUT(2,2)=one
    AD(1,1)=one
    AD(2,2)=one
    AD(3,3)=one
    FIRST=.TRUE.
    NORM=c_1d6
    NORMAT=c_2d5
    DO N=1,NMAXI
       !  COMPUTING H**N/N!
       DO I=1,3
          DO J=1,3
             DO K=1,3
                TEMP(I,K)=H(I,J)*AD(J,K)+TEMP(I,K)
             ENDDO
          ENDDO
       ENDDO
       NORM0=NORM
       NORMAT0=NORMAT
       !  ADDING TO MATOUT
       NORM=zero
       NORMAT=zero
       DO I=1,3   !2
          DO J=1,3
             AD(I,J)=TEMP(I,J)/N
             IF(I/=3) MATOUT(I,J)=MATOUT(I,J)+AD(I,J)
             IF(I/=3) NORMAT=NORMAT+ABS(MATOUT(I,J))
             TEMP(I,J)=zero
          ENDDO
       ENDDO
       NORM=ABS(NORMAT-NORMAT0)


       IF(FIRST) THEN
          IF(NORM<EPS_DEF_KIND) THEN
             FIRST=.FALSE.
          ENDIF
       ELSE
          IF(NORM>=NORM0) GOTO 100
       ENDIF


    ENDDO

    w_p=0
    w_p%nc=1
    w_p%fc='(1(1X,A72))'
    write(w_p%c(1),'(A31,1X,I4,1X,A11)') " EXPSOLR FAILED TO CONVERGE IN ",NMAXI," ITERATIONS"
    call write_e(0)

100 CONTINUE

    DO I=1,3
       DO J=1,3
          CALL KILL(AD(I,J))
          CALL KILL(TEMP(I,J))
       ENDDO
    ENDDO


  END SUBROUTINE EXPD


  SUBROUTINE EXP6R(H,V,MATOUT)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: H(6,6),V(6),MATOUT(6)
    real(dp) AD(6),TEMP(6)
    real(dp) NORM,NORM0,NORMAT,NORMAT0
    logical(lp) FIRST
    INTEGER I,J,N

    DO I=1,6
       MATOUT(I)=V(I)
       AD(I)=V(I)
       TEMP(I)=zero
    ENDDO
    FIRST=.TRUE.
    NORM=c_1d6
    NORMAT=c_2d5
    DO N=1,NMAXI
       !  COMPUTING H**N/N!
       DO I=1,6
          DO J=1,6
             TEMP(I)=H(I,J)*AD(J)+TEMP(I)
          ENDDO
       ENDDO
       NORM0=NORM
       NORMAT0=NORMAT
       !  ADDING TO MATOUT
       NORM=zero
       NORMAT=zero
       DO I=1,6   !2
          AD(I)=TEMP(I)/(N+1)
          MATOUT(I)=MATOUT(I)+AD(I)
          NORMAT=NORMAT+ABS(MATOUT(I))
          TEMP(I)=zero
       ENDDO
       NORM=ABS(NORMAT-NORMAT0)


       IF(FIRST) THEN
          IF(NORM<EPS_DEF_KIND) THEN
             FIRST=.FALSE.
          ENDIF
       ELSE
          IF(NORM>=NORM0) GOTO 100
       ENDIF


    ENDDO

    w_p=0
    w_p%nc=1
    w_p%fc='(1(1X,A72))'
    write(w_p%c(1),'(A31,1X,I4,1X,A11)') " EXPSOLR FAILED TO CONVERGE IN ",NMAXI," ITERATIONS"
    call write_e(0)

100 CONTINUE

  END SUBROUTINE EXP6R


  SUBROUTINE EXP6D(H,V,MATOUT)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: H(6,6),V(6),MATOUT(6)
    TYPE(REAL_8) AD(6),TEMP(6)
    real(dp) NORM,NORM0,NORMAT,NORMAT0
    logical(lp) FIRST
    INTEGER I,J,N

    CALL ALLOC(AD,6)
    CALL ALLOC(TEMP,6)

    DO I=1,6
       MATOUT(I)=V(I)
       AD(I)=V(I)
       TEMP(I)=zero
    ENDDO
    FIRST=.TRUE.
    NORM=c_1d6
    NORMAT=c_2d5
    DO N=1,NMAXI
       !  COMPUTING H**N/N!
       DO I=1,6
          DO J=1,6
             TEMP(I)=H(I,J)*AD(J)+TEMP(I)
          ENDDO
       ENDDO
       NORM0=NORM
       NORMAT0=NORMAT
       !  ADDING TO MATOUT
       NORM=zero
       NORMAT=zero
       DO I=1,6   !2
          AD(I)=TEMP(I)/(N+1)
          MATOUT(I)=MATOUT(I)+AD(I)
          NORMAT=NORMAT+ABS(MATOUT(I))
          TEMP(I)=zero
       ENDDO
       NORM=ABS(NORMAT-NORMAT0)


       IF(FIRST) THEN
          IF(NORM<EPS_DEF_KIND) THEN
             FIRST=.FALSE.
          ENDIF
       ELSE
          IF(NORM>=NORM0) GOTO 100
       ENDIF


    ENDDO

    w_p=0
    w_p%nc=1
    w_p%fc='(1(1X,A72))'
    write(w_p%c(1),'(A31,1X,I4,1X,A11)') " EXPSOLR FAILED TO CONVERGE IN ",NMAXI," ITERATIONS"
    call write_e(0)

100 CONTINUE


    CALL KILL(AD,6)
    CALL KILL(TEMP,6)

  END SUBROUTINE EXP6D
  !  ZEROING AND COPY ROUTINES


  SUBROUTINE INTKTKR(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: MID
    TYPE(KTK),INTENT(INOUT):: EL
    INTEGER I
    real(dp) DK,DK2,DK6,DK4,DK5


    IF(PRESENT(MID)) CALL XMID(MID,X,0)
    CALL GETMAT(EL,X)

    SELECT CASE(EL%P%METHOD)
    CASE(2)
       DK2=EL%L/EL%P%NST
       DK=DK2/two
       IF(OLD_IMPLEMENTATION_OF_SIXTRACK) THEN

          DO I=1,EL%P%NST  !-1
             CALL KICKKTK(EL,DK,X)  ! NEW
             CALL KICKPATH(EL,DK,X)
             CALL PUSHKTK(EL,X)

             CALL KICKPATH(EL,DK,X)
             if(EL%P%RADIATION) CALL GETMAT(EL,X)
             CALL KICKKTK(EL,DK,X)  ! NEW
             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO
       ELSE
          DO I=1,EL%P%NST  !-1
             CALL PUSHKTK(EL,X)
             CALL KICKPATH(EL,DK,X)
             CALL KICKKTK(EL,DK2,X)  ! NEW
             CALL KICKPATH(EL,DK,X)
             CALL PUSHKTK(EL,X)
             if(EL%P%RADIATION) CALL GETMAT(EL,X)
             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO
       ENDIF

    CASE(4)
       DK2=EL%L/EL%P%NST/three
       DK6=two*DK2
       DK=DK2/two

       DO I=1,EL%P%NST     !-1
          CALL KICKKTK(EL,DK,X)    ! NEW
          CALL KICKPATH(EL,DK,X)
          CALL PUSHKTK(EL,X)
          CALL KICKPATH(EL,DK2,X)
          CALL KICKKTK(EL,DK6,X)
          CALL KICKPATH(EL,DK2,X)
          CALL PUSHKTK(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKKTK(EL,DK,X) ! NEW
          if(EL%P%RADIATION) CALL GETMAT(EL,X)
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
    CASE(6)
       DK2=c_14*EL%L/EL%P%NST/c_90
       DK4=c_32*EL%L/EL%P%NST/c_90
       DK6=twelve*EL%L/EL%P%NST/c_90
       DK5=DK6/two
       DK=DK2/two


       DO I=1,EL%P%NST    !-1
          CALL KICKKTK(EL,DK,X)   ! NEW
          CALL KICKPATH(EL,DK,X)

          CALL PUSHKTK(EL,X)

          CALL KICKKTK(EL,DK4,X)
          CALL KICKPATH(EL,DK4,X)

          CALL PUSHKTK(EL,X)

          CALL KICKPATH(EL,DK5,X)
          CALL KICKKTK(EL,DK6,X)   ! SYMMETRY POINT
          CALL KICKPATH(EL,DK5,X)

          CALL PUSHKTK(EL,X)

          CALL KICKPATH(EL,DK4,X)
          CALL KICKKTK(EL,DK4,X)

          CALL PUSHKTK(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKKTK(EL,DK,X)   ! NEW
          if(EL%P%RADIATION) CALL GETMAT(EL,X)
          IF(PRESENT(MID)) CALL XMID(MID,X,I)

       ENDDO

    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

  END SUBROUTINE INTKTKR

  SUBROUTINE INTKTKD(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: MID
    TYPE(KTKP),INTENT(INOUT):: EL
    INTEGER I
    TYPE(REAL_8) DK,DK2,DK6,DK4,DK5


    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    CALL ALLOC(EL)
    CALL ALLOC(DK,DK2,DK6,DK4,DK5);
    CALL GETMAT(EL,X)

    SELECT CASE(EL%P%METHOD)
    CASE(2)
       DK2=EL%L/EL%P%NST
       DK=DK2/two

       IF(OLD_IMPLEMENTATION_OF_SIXTRACK) THEN

          DO I=1,EL%P%NST  !-1
             CALL KICKKTK(EL,DK,X)  ! NEW
             CALL KICKPATH(EL,DK,X)
             CALL PUSHKTK(EL,X)

             CALL KICKPATH(EL,DK,X)
             if(EL%P%RADIATION) CALL GETMAT(EL,X)
             CALL KICKKTK(EL,DK,X)  ! NEW
             !             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO
       ELSE
          DO I=1,EL%P%NST  !-1
             CALL PUSHKTK(EL,X)
             CALL KICKPATH(EL,DK,X)
             CALL KICKKTK(EL,DK2,X)  ! NEW
             CALL KICKPATH(EL,DK,X)
             CALL PUSHKTK(EL,X)
             if(EL%P%RADIATION) CALL GETMAT(EL,X)
             !             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO
       ENDIF

    CASE(4)
       DK2=EL%L/EL%P%NST/three
       DK6=two*DK2
       DK=DK2/two

       DO I=1,EL%P%NST     !-1
          CALL KICKKTK(EL,DK,X)    ! NEW
          CALL KICKPATH(EL,DK,X)
          CALL PUSHKTK(EL,X)
          CALL KICKPATH(EL,DK2,X)
          CALL KICKKTK(EL,DK6,X)
          CALL KICKPATH(EL,DK2,X)
          CALL PUSHKTK(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKKTK(EL,DK,X) ! NEW
          if(EL%P%RADIATION) CALL GETMAT(EL,X)
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
    CASE(6)
       DK2=c_14*EL%L/EL%P%NST/c_90
       DK4=c_32*EL%L/EL%P%NST/c_90
       DK6=twelve*EL%L/EL%P%NST/c_90
       DK5=DK6/two
       DK=DK2/two


       DO I=1,EL%P%NST    !-1
          CALL KICKKTK(EL,DK,X)   ! NEW
          CALL KICKPATH(EL,DK,X)

          CALL PUSHKTK(EL,X)

          CALL KICKKTK(EL,DK4,X)
          CALL KICKPATH(EL,DK4,X)

          CALL PUSHKTK(EL,X)

          CALL KICKPATH(EL,DK5,X)
          CALL KICKKTK(EL,DK6,X)   ! SYMMETRY POINT
          CALL KICKPATH(EL,DK5,X)

          CALL PUSHKTK(EL,X)

          CALL KICKPATH(EL,DK4,X)
          CALL KICKKTK(EL,DK4,X)

          CALL PUSHKTK(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKKTK(EL,DK,X)   ! NEW
          if(EL%P%RADIATION) CALL GETMAT(EL,X)
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)

       ENDDO



    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT
    CALL KILL(DK,DK2,DK6,DK4,DK5);
    CALL KILL(EL)

  END SUBROUTINE INTKTKD

  SUBROUTINE INTKTKS(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(KTKP),INTENT(INOUT):: EL
    INTEGER I
    TYPE(REAL_8) DK,DK2,DK6,DK4,DK5

    CALL ALLOC(EL)
    CALL ALLOC(DK,DK2,DK6,DK4,DK5);
    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)
    CALL GETMAT(EL,X)


    SELECT CASE(EL%P%METHOD)
    CASE(2)
       DK2=EL%L/EL%P%NST
       DK=DK2/two
       IF(OLD_IMPLEMENTATION_OF_SIXTRACK) THEN


          DO I=1,EL%P%NST  !-1
             CALL KICKKTK(EL,DK,X)  ! NEW
             CALL KICKPATH(EL,DK,X)
             CALL PUSHKTK(EL,X)

             CALL KICKPATH(EL,DK,X)
             if(EL%P%RADIATION) CALL GETMAT(EL,X)
             CALL KICKKTK(EL,DK,X)  ! NEW
             !         IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO
       ELSE
          DO I=1,EL%P%NST  !-1
             CALL PUSHKTK(EL,X)
             CALL KICKPATH(EL,DK,X)
             CALL KICKKTK(EL,DK2,X)  ! NEW
             CALL KICKPATH(EL,DK,X)
             CALL PUSHKTK(EL,X)
             if(EL%P%RADIATION) CALL GETMAT(EL,X)
             !         IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO
       ENDIF

    CASE(4)
       DK2=EL%L/EL%P%NST/three
       DK6=two*DK2
       DK=DK2/two

       DO I=1,EL%P%NST     !-1
          CALL KICKKTK(EL,DK,X)    ! NEW
          CALL KICKPATH(EL,DK,X)
          CALL PUSHKTK(EL,X)
          CALL KICKPATH(EL,DK2,X)
          CALL KICKKTK(EL,DK6,X)
          CALL KICKPATH(EL,DK2,X)
          CALL PUSHKTK(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKKTK(EL,DK,X) ! NEW
          if(EL%P%RADIATION) CALL GETMAT(EL,X)
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
    CASE(6)
       DK2=c_14*EL%L/EL%P%NST/c_90
       DK4=c_32*EL%L/EL%P%NST/c_90
       DK6=twelve*EL%L/EL%P%NST/c_90
       DK5=DK6/two
       DK=DK2/two


       DO I=1,EL%P%NST    !-1
          CALL KICKKTK(EL,DK,X)   ! NEW
          CALL KICKPATH(EL,DK,X)

          CALL PUSHKTK(EL,X)

          CALL KICKKTK(EL,DK4,X)
          CALL KICKPATH(EL,DK4,X)

          CALL PUSHKTK(EL,X)

          CALL KICKPATH(EL,DK5,X)
          CALL KICKKTK(EL,DK6,X)   ! SYMMETRY POINT
          CALL KICKPATH(EL,DK5,X)

          CALL PUSHKTK(EL,X)

          CALL KICKPATH(EL,DK4,X)
          CALL KICKKTK(EL,DK4,X)

          CALL PUSHKTK(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKKTK(EL,DK,X)   ! NEW
          if(EL%P%RADIATION) CALL GETMAT(EL,X)
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)

       ENDDO


    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT
    CALL KILL(DK,DK2,DK6,DK4,DK5);
    CALL KILL(EL)

  END SUBROUTINE INTKTKS


  SUBROUTINE PUSHKTKR(EL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(KTK),INTENT(IN):: EL
    real(dp) T(6)

    T(1)=EL%MATX(1,1)*X(1)+EL%MATX(1,2)*X(2)+EL%MATX(1,3)*X(5)
    T(2)=EL%MATX(2,1)*X(1)+EL%MATX(2,2)*X(2)+EL%MATX(2,3)*X(5)
    T(3)=EL%MATY(1,1)*X(3)+EL%MATY(1,2)*X(4)
    T(4)=EL%MATY(2,1)*X(3)+EL%MATY(2,2)*X(4)
    T(6)=X(6)+EL%LX(1)+EL%LX(2)*X(1)+EL%LX(3)*X(2)
    T(6)=T(6)+EL%LX(4)*X(1)**2+EL%LX(5)*X(1)*X(2)+EL%LX(6)*X(2)**2
    T(6)=T(6)+EL%LY(1)*X(3)**2+EL%LY(2)*X(3)*X(4)+EL%LY(3)*X(4)**2

    X(1)=T(1);X(2)=T(2);X(3)=T(3);X(4)=T(4);X(6)=T(6);

  END SUBROUTINE PUSHKTKR

  SUBROUTINE PUSHKTKD(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(KTKP),INTENT(IN):: EL
    TYPE(REAL_8) T(6)

    CALL ALLOC(T)
    T(1)=EL%MATX(1,1)*X(1)+EL%MATX(1,2)*X(2)+EL%MATX(1,3)*X(5)
    T(2)=EL%MATX(2,1)*X(1)+EL%MATX(2,2)*X(2)+EL%MATX(2,3)*X(5)
    T(3)=EL%MATY(1,1)*X(3)+EL%MATY(1,2)*X(4)
    T(4)=EL%MATY(2,1)*X(3)+EL%MATY(2,2)*X(4)
    T(6)=X(6)+EL%LX(1)+EL%LX(2)*X(1)+EL%LX(3)*X(2)
    T(6)=T(6)+EL%LX(4)*X(1)**2+EL%LX(5)*X(1)*X(2)+EL%LX(6)*X(2)**2
    T(6)=T(6)+EL%LY(1)*X(3)**2+EL%LY(2)*X(3)*X(4)+EL%LY(3)*X(4)**2

    X(1)=T(1);X(2)=T(2);X(3)=T(3);X(4)=T(4);X(6)=T(6);

    CALL KILL(T)

  END SUBROUTINE PUSHKTKD

  SUBROUTINE PUSHKTKS(EL,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(KTKP),INTENT(IN):: EL
    TYPE(REAL_8) X(6)


    CALL ALLOC(X)

    X=Y

    CALL PUSHKTK(EL,X)

    Y=X

    CALL KILL(X)

  END SUBROUTINE PUSHKTKS

  SUBROUTINE KICKKTKR(EL,YL,X)   !ETIENNE
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(KTK),INTENT(IN):: EL
    real(dp),INTENT(IN):: YL
    real(dp) X1,X3,X5,BBYTW,BBXTW,BBYTWT,B(3),B2
    INTEGER J,DIR

    DIR=EL%P%DIR*EL%P%CHARGE

    X1=X(1)
    X3=X(3)

    if(EL%P%TIME) then
       X5=ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
    else
       X5=X(5)
    endif


    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF


    IF(EL%P%RADIATION) THEN
       B(1)=BBXTW
       B(2)=BBYTW  !+EL%BN(1)
       B(3)=zero
       CALL B2PERP(EL%P,B,X,X5,B2)
       X(5)=X(5)-CRADF(EL%P)*(one+X(5))**2*B2*(one+X1*EL%P%B0+half*(X(2)**2+X(4)**2)/(one+X(5))**2)*YL
       if(EL%P%TIME) then
          X(2)=X(2)*ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          X(4)=X(4)*ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
       else
          X(2)=X(2)*(one+X(5))/(one+X5)
          X(4)=X(4)*(one+X(5))/(one+X5)
       endif
    ENDIF

    X(2)=X(2)-YL*DIR*(BBYTW-DIR*EL%P%B0-EL%BN(2)*X(1))
    X(4)=X(4)+YL*DIR*(BBXTW-EL%BN(2)*X(3))

  END SUBROUTINE KICKKTKR



  SUBROUTINE KICKKTKP(EL,YL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(KTKP),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) X1,X3,X5,BBYTW,BBXTW,BBYTWT,B(3),B2
    INTEGER J,DIR

    DIR=EL%P%DIR*EL%P%CHARGE

    CALL ALLOC(X1)
    CALL ALLOC(X3)
    CALL ALLOC(X5)
    CALL ALLOC(BBYTW)
    CALL ALLOC(BBXTW)
    CALL ALLOC(BBYTWT)


    X1=X(1)
    X3=X(3)
    if(EL%P%TIME) then
       X5=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
    else
       X5=X(5)
    endif


    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF

    IF(EL%P%RADIATION) THEN
       CALL ALLOC(B2)
       CALL ALLOC(B,3)
       B(1)=BBXTW
       B(2)=BBYTW   !+EL%BN(1)
       B(3)=zero
       CALL B2PERP(EL%P,B,X,X5,B2)
       X(5)=X(5)-CRADF(EL%P)*(one+X(5))**2*B2*(one+X1*EL%P%B0+half*(X(2)**2+X(4)**2)/(one+X(5))**2)*YL
       if(EL%P%TIME) then
          X(2)=X(2)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          X(4)=X(4)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
       else
          X(2)=X(2)*(one+X(5))/(one+X5)
          X(4)=X(4)*(one+X(5))/(one+X5)
       endif
       CALL KILL(B2)
       CALL KILL(B,3)
    ENDIF


    X(2)=X(2)-YL*DIR*(BBYTW-DIR*EL%P%B0-EL%BN(2)*X(1))
    X(4)=X(4)+YL*DIR*(BBXTW-EL%BN(2)*X(3))


    CALL KILL(X1)
    CALL KILL(X3)
    CALL KILL(X5)
    CALL KILL(BBYTW)
    CALL KILL(BBXTW)
    CALL KILL(BBYTWT)

  END SUBROUTINE KICKKTKP

  SUBROUTINE KICKKTKS(EL,YL,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(REAL_8) X(6),XR(6)
    TYPE(DAMAP) XP,ID,DISP,XT
    TYPE(KTKP),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) X1,X3,X5,BBYTW,BBXTW,BBYTWT,B(3),B2,DENF
    real(dp) B20,B30,BF, v(6) !,R1,R2
    logical(lp) done_stoch
    INTEGER I,J,DIR

    DIR=EL%P%DIR*EL%P%CHARGE


    CALL ALLOC(X1)
    CALL ALLOC(X3)
    CALL ALLOC(DENF)
    CALL ALLOC(X5)
    CALL ALLOC(BBYTW)
    CALL ALLOC(BBXTW)
    CALL ALLOC(BBYTWT)
    CALL ALLOC(X)
    CALL ALLOC(XP)
    CALL ALLOC(B2)
    CALL ALLOC(B,3)
    CALL ALLOC(XR)
    CALL ALLOC(ID)
    CALL ALLOC(DISP)
    CALL ALLOC(XT)



    X=Y

    X1=X(1)
    X3=X(3)
    if(EL%P%TIME) then
       X5=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
    else
       X5=X(5)
    endif


    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF


    XP=X
    XR=X
    XP%V(2)=X(2)/(one+x5)
    XP%V(4)=X(4)/(one+x5)
    IF(EL%P%RADIATION) THEN
       B(1)=BBXTW
       B(2)=BBYTW     !+EL%BN(1)
       B(3)=zero
       CALL B2PERP(EL%P,B,X,X5,B2)
       X(5)=X(5)-CRADF(EL%P)*(one+X(5))**2*B2*(one+X1*EL%P%B0+half*(X(2)**2+X(4)**2)/(one+X(5))**2)*YL

       if(EL%P%TIME) then
          X(2)=X(2)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          X(4)=X(4)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
       else
          X(2)=X(2)*(one+X(5))/(one+X5)
          X(4)=X(4)*(one+X(5))/(one+X5)
       endif

    ENDIF

    done_stoch=.false.
    if(EL%P%B0==zero.and.stoch_in_rec) then

       denf=(one+xr(5))**4*(one+xr(1)*EL%P%B0+half*(xr(2)**2+xr(4)**2)/(one+xr(5))**2)
       b20=b2
       b30=b20**c_1_5
       bf=cflucf(el%p)*b30
       denf=denf*bf*yl
       done_stoch=.true.
    elseif(EL%P%B0/=zero)   then
       done_stoch=.true.
    endif

    if(done_stoch) then

       if(EL%P%B0/=zero) then
          !
          if(knob) then
             v=XR
             DISP=xp*id
             id=1
             DISP=ID-DISP
             XP=DISP*XP

             id=0
             XT=XR
             DISP=XT*ID
             ID=1
             DISP=ID-DISP
             XT=DISP*XT
             xr=xt+V
             CALL B2PERP(EL%P,B,Xr,X5,B2)
             denf=(one+xr(5))**4*(one+xr(1)*EL%P%B0+half*(xr(2)**2+xr(4)**2)/(one+xr(5))**2)
             denf=DENF*cflucf(el%p)*yl*b2**c_1_5
          else
             CALL B2PERP(EL%P,B,Xr,X5,B2)
             denf=(one+xr(5))**4*(one+xr(1)*EL%P%B0+half*(xr(2)**2+xr(4)**2)/(one+xr(5))**2)
             b20=b2
             b30=b20**c_1_5
             bf=cflucf(el%p)*b30
             denf=denf*bf*yl
          endif
       endif

       xp=xp**(-1)
       do i=1,6
          do j=1,6
             X1=(xp%v(i)).par.'000010'
             X3=(xp%v(j)).par.'000010'
             denf=denf.par.'000000'
             y(I)%E(J)=y(I)%E(J)+denf*x1*x3
          enddo
       enddo
    endif

    X(2)=X(2)-YL*DIR*(BBYTW-DIR*EL%P%B0-EL%BN(2)*X(1))
    X(4)=X(4)+YL*DIR*(BBXTW-EL%BN(2)*X(3))



    Y=X
    CALL KILL(B2)
    CALL KILL(B,3)
    CALL KILL(XP)
    CALL KILL(X)
    CALL KILL(X1)
    CALL KILL(X3)
    CALL KILL(DENF)
    CALL KILL(X5)
    CALL KILL(BBYTW)
    CALL KILL(BBXTW)
    CALL KILL(BBYTWT)
    CALL KILL(XR)
    CALL KILL(ID)
    CALL KILL(DISP)
    CALL KILL(XT)
  END SUBROUTINE KICKKTKS




  SUBROUTINE SYMPINTKTKR(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(KTK),INTENT(INOUT):: EL
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: MID


    IF(EL%P%DIR==1) THEN
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL INTKTK(EL,X,MID)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
    ELSE
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL INTKTK(EL,X,MID)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
    ENDIF

  END SUBROUTINE SYMPINTKTKR

  SUBROUTINE SYMPINTKTKD(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(KTKP),INTENT(INOUT):: EL
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: MID


    IF(EL%P%DIR==1) THEN
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL INTKTK(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
    ELSE
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL INTKTK(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
    ENDIF

  END SUBROUTINE SYMPINTKTKD

  SUBROUTINE SYMPINTKTKS(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(KTKP),INTENT(INOUT):: EL


    IF(EL%P%DIR==1) THEN
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL INTKTK(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
    ELSE
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL INTKTK(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
    ENDIF


  END SUBROUTINE SYMPINTKTKS



!!!! *************************************************************** !!!!
!!!! *                 End of the slow thick element               * !!!!
!!!! *************************************************************** !!!!


!!!! *************************************************************** !!!!
!!!! *           Beginning of the fast thick element               * !!!!
!!!! *************************************************************** !!!!
  SUBROUTINE GETMAT7R(EL)
    IMPLICIT NONE
    TYPE(TKTF),INTENT(INOUT):: EL
    real(dp) HX(4,4),HY(4,4)
    real(dp) DH
    INTEGER DIR
!!!!  SPEED STUFF !!!
    real(dp) OMEGA, OMEGA2,C,S
    INTEGER S_OMEGA

    IF(EL%P%METHOD/=6) THEN
       DH=(EL%L/EL%P%NST)/EL%P%METHOD   ! method=1,2
       IF(EL%P%METHOD==4) DH=DH*TWO
    ELSE
       DH=EL%L/EL%P%NST/four
    ENDIF

    DIR=1
    IF(SPEED) THEN

       S_OMEGA=-1
       OMEGA2=DIR*(EL%BN(2)+EL%P%B0*EL%BN(1))

       IF(OMEGA2<zero) THEN
          OMEGA2=-OMEGA2
          S_OMEGA=1
       ENDIF
       if(OMEGA2.eq.zero) then   ! for Lahey bug in quadruple precision
          OMEGA=zero             ! not done yet on TPSA part
       else
          OMEGA=SQRT(OMEGA2)
       endif

       IF(OMEGA>zero) THEN
          IF(S_OMEGA==1) THEN
             C=COSH(OMEGA*DH)
             S=SINH(OMEGA*DH)
          ELSE
             C=COS(OMEGA*DH)
             S=SIN(OMEGA*DH)
          ENDIF
          EL%MATX(1,1)=C;
          EL%MATX(1,2)=S/OMEGA;
          EL%MATX(1,3)= EL%P%B0*(C-one)/OMEGA2*S_OMEGA;

          EL%MATX(2,1)=S_OMEGA*OMEGA*S; EL%MATX(2,2)=C;
          EL%MATX(2,3)= EL%P%B0*EL%MATX(1,2);
          EL%LX(1)=EL%P%B0*EL%MATX(1,2);   EL%LX(2)=EL%MATX(1,3);
          EL%LX(3)=-EL%P%B0**2*S_OMEGA*(DH-EL%MATX(1,2))/OMEGA2;
       ELSE
          EL%MATX(1,1)=one;EL%MATX(1,2)=DH;
          EL%MATX(2,1)=zero
          EL%MATX(2,2)=one
          EL%MATX(2,3)= EL%P%B0*DH;
          EL%MATX(1,3)= EL%MATX(2,3)*DH/two;
          EL%LX(1)=EL%MATX(2,3);EL%LX(2)=EL%MATX(1,3);
          EL%LX(3)=EL%MATX(1,3)*EL%P%B0*DH/three
       ENDIF

       S_OMEGA=-1
       OMEGA2=-DIR*EL%BN(2)

       IF(OMEGA2<zero) THEN
          OMEGA2=-OMEGA2
          S_OMEGA=1
       ENDIF
       OMEGA=SQRT(OMEGA2)


       IF(OMEGA>zero) THEN
          IF(S_OMEGA==1) THEN
             C=COSH(OMEGA*DH)
             S=SINH(OMEGA*DH)
          ELSE
             C=COS(OMEGA*DH)
             S=SIN(OMEGA*DH)
          ENDIF
          EL%MATY(1,1)=C;
          EL%MATY(1,2)=S/OMEGA;
          EL%MATY(1,3)=zero;
          EL%MATY(2,1)=S_OMEGA*OMEGA*S; EL%MATY(2,2)=C;
          EL%MATY(2,3)=zero;
       ELSE
          EL%MATY(1,3)=zero;
          EL%MATY(2,3)=zero;
          EL%MATY(1,1)=one;EL%MATY(1,2)=DH;
          EL%MATY(2,2)=one;EL%MATY(2,1)=zero;
       ENDIF





    ELSE     !  SPEED FALSE OR KNOB TRUE


       HX(1,1)=zero;HX(1,2)=DH;HX(1,3)=zero;HX(1,4)=zero;
       HX(2,1)=-DH*DIR*(EL%BN(2)+EL%P%B0*EL%BN(1));HX(2,2)=zero;HX(2,3)=DH*EL%P%B0;HX(2,4)=zero;
       HX(3,1)=zero;HX(3,2)=zero;HX(3,3)=zero;HX(3,4)=zero;
       HX(4,1)=DH*EL%P%B0;HX(4,2)=zero;HX(4,3)=zero;HX(4,4)=zero;

       HY(1,1)=zero;HY(1,2)=HX(1,2);HY(1,3)=zero;HY(1,4)=zero;
       HY(2,1)=DH*DIR*EL%BN(2);HY(2,2)=zero;HY(2,3)=zero;HY(2,4)=zero;
       HY(3,1)=zero;HY(3,2)=zero;HY(3,3)=zero;HY(3,4)=zero;
       HY(4,1)=zero;HY(4,2)=zero;HY(4,3)=zero;HY(4,4)=zero;

       ! BUG FOUND BY SCHMIDT (SUBTLE ONE; AFFECTS PTC LOGIC; YUCK!)

       !    IF(EL%P%TIME) THEN
       !       HX(2,3)=HX(2,3)/el%P%beta0
       !       HX(4,1)=HX(4,1)/el%P%beta0
       !    ENDIF

       CALL EXPCOSY7(HY,EL%MATY,EL%LX)
       CALL EXPCOSY7(HX,EL%MATX,EL%LX)







    ENDIF


    DIR=-1
    IF(SPEED) THEN

       S_OMEGA=-1
       OMEGA2=DIR*(EL%BN(2)+EL%P%B0*EL%BN(1))

       IF(OMEGA2<zero) THEN
          OMEGA2=-OMEGA2
          S_OMEGA=1
       ENDIF

       if(OMEGA2.eq.zero) then    ! for Lahey bug in quadruple precision
          OMEGA=zero
       else
          OMEGA=SQRT(OMEGA2)
       endif

       IF(OMEGA>zero) THEN
          IF(S_OMEGA==1) THEN
             C=COSH(OMEGA*DH)
             S=SINH(OMEGA*DH)
          ELSE
             C=COS(OMEGA*DH)
             S=SIN(OMEGA*DH)
          ENDIF
          EL%RMATX(1,1)=C;
          EL%RMATX(1,2)=S/OMEGA;
          EL%RMATX(1,3)= EL%P%B0*(C-one)/OMEGA2*S_OMEGA;
          EL%RMATX(2,1)=S_OMEGA*OMEGA*S; EL%RMATX(2,2)=C;
          EL%RMATX(2,3)= EL%P%B0*EL%RMATX(1,2);
          EL%RLX(1)=EL%P%B0*EL%RMATX(1,2);   EL%RLX(2)=EL%RMATX(1,3);
          EL%RLX(3)=-EL%P%B0**2*S_OMEGA*(DH-EL%RMATX(1,2))/OMEGA2;
       ELSE
          EL%RMATX(1,1)=one;EL%RMATX(1,2)=DH;
          EL%RMATX(2,1)=zero
          EL%RMATX(2,2)=one
          EL%RMATX(2,3)= EL%P%B0*DH;
          EL%RMATX(1,3)= EL%RMATX(2,3)*DH/two;
          EL%RLX(1)=EL%RMATX(2,3);EL%RLX(2)=EL%RMATX(1,3);
          EL%RLX(3)=EL%RMATX(1,3)*EL%P%B0*DH/three
       ENDIF

       S_OMEGA=-1
       OMEGA2=-DIR*EL%BN(2)

       IF(OMEGA2<zero) THEN
          OMEGA2=-OMEGA2
          S_OMEGA=1
       ENDIF
       OMEGA=SQRT(OMEGA2)


       IF(OMEGA>zero) THEN
          IF(S_OMEGA==1) THEN
             C=COSH(OMEGA*DH)
             S=SINH(OMEGA*DH)
          ELSE
             C=COS(OMEGA*DH)
             S=SIN(OMEGA*DH)
          ENDIF
          EL%RMATY(1,1)=C;
          EL%RMATY(1,2)=S/OMEGA;
          EL%RMATY(1,3)=zero;
          EL%RMATY(2,1)=S_OMEGA*OMEGA*S; EL%RMATY(2,2)=C;
          EL%RMATY(2,3)=zero;
       ELSE
          EL%RMATY(1,3)=zero;
          EL%RMATY(2,3)=zero;
          EL%RMATY(1,1)=one;EL%RMATY(1,2)=DH;
          EL%RMATY(2,2)=one;EL%RMATY(2,1)=zero;
       ENDIF





    ELSE     !  SPEED FALSE OR KNOB TRUE


       HX(1,1)=zero;HX(1,2)=DH;HX(1,3)=zero;HX(1,4)=zero;
       HX(2,1)=-DH*DIR*(EL%BN(2)+EL%P%B0*EL%BN(1));HX(2,2)=zero;HX(2,3)=DH*EL%P%B0;HX(2,4)=zero;
       HX(3,1)=zero;HX(3,2)=zero;HX(3,3)=zero;HX(3,4)=zero;
       HX(4,1)=DH*EL%P%B0;HX(4,2)=zero;HX(4,3)=zero;HX(4,4)=zero;

       HY(1,1)=zero;HY(1,2)=HX(1,2);HY(1,3)=zero;HY(1,4)=zero;
       HY(2,1)=DH*DIR*EL%BN(2);HY(2,2)=zero;HY(2,3)=zero;HY(2,4)=zero;
       HY(3,1)=zero;HY(3,2)=zero;HY(3,3)=zero;HY(3,4)=zero;
       HY(4,1)=zero;HY(4,2)=zero;HY(4,3)=zero;HY(4,4)=zero;

       ! BUG FOUND BY SCHMIDT (SUBTLE ONE; AFFECTS PTC LOGIC; YUCK!)

       !    IF(EL%P%TIME) THEN
       !       HX(2,3)=HX(2,3)/el%P%beta0
       !       HX(4,1)=HX(4,1)/el%P%beta0
       !    ENDIF

       CALL EXPCOSY7(HY,EL%RMATY,EL%RLX)
       CALL EXPCOSY7(HX,EL%RMATX,EL%RLX)







    ENDIF





  END SUBROUTINE GETMAT7R

  SUBROUTINE GETMAT7D(EL)
    IMPLICIT NONE
    TYPE(TKTFP),INTENT(INOUT):: EL
    TYPE(REAL_8) HX(4,4),HY(4,4)
    TYPE(REAL_8) DH
    INTEGER I,J,DIR
!!!!  SPEED STUFF !!!
    real(dp) OMEGA, OMEGA2,C,S
    INTEGER S_OMEGA

    DO I=1,4
       DO J=1,4
          CALL ALLOC(HX(I,J))
          CALL ALLOC(HY(I,J))
       ENDDO
    ENDDO
    CALL ALLOC(DH)


    IF(EL%P%METHOD/=6) THEN
       DH=(EL%L/EL%P%NST)/EL%P%METHOD   ! method=1,2
       IF(EL%P%METHOD==4) DH=DH*TWO
    ELSE
       DH=EL%L/EL%P%NST/four
    ENDIF

    DIR=1
    IF(SPEED.AND.(.NOT.KNOB)) THEN

       S_OMEGA=-1
       OMEGA2=DIR*(EL%BN(2)+EL%P%B0*EL%BN(1))

       IF(OMEGA2<zero) THEN
          OMEGA2=-OMEGA2
          S_OMEGA=1
       ENDIF
       OMEGA=SQRT(OMEGA2)


       IF(OMEGA>zero) THEN
          IF(S_OMEGA==1) THEN
             C=COSH(OMEGA*DH)
             S=SINH(OMEGA*DH)
          ELSE
             C=COS(OMEGA*DH)
             S=SIN(OMEGA*DH)
          ENDIF
          EL%MATX(1,1)=C;
          EL%MATX(1,2)=S/OMEGA;
          EL%MATX(1,3)= EL%P%B0*(C-one)/OMEGA2*S_OMEGA;
          EL%MATX(2,1)=S_OMEGA*OMEGA*S; EL%MATX(2,2)=C;
          EL%MATX(2,3)= EL%P%B0*EL%MATX(1,2);
          EL%LX(1)=EL%P%B0*EL%MATX(1,2);   EL%LX(2)=EL%MATX(1,3);
          EL%LX(3)=-EL%P%B0**2*S_OMEGA*(DH-EL%MATX(1,2))/OMEGA2;
       ELSE
          EL%MATX(1,1)=one;EL%MATX(1,2)=DH;
          EL%MATX(2,1)=zero
          EL%MATX(2,2)=one
          EL%MATX(2,3)= EL%P%B0*DH;
          EL%MATX(1,3)= EL%MATX(2,3)*DH/two;
          EL%LX(1)=EL%MATX(2,3);EL%LX(2)=EL%MATX(1,3);
          EL%LX(3)=EL%MATX(1,3)*EL%P%B0*DH/three
       ENDIF


       S_OMEGA=-1
       OMEGA2=-DIR*EL%BN(2)

       IF(OMEGA2<zero) THEN
          OMEGA2=-OMEGA2
          S_OMEGA=1
       ENDIF
       OMEGA=SQRT(OMEGA2)


       IF(OMEGA>zero) THEN
          IF(S_OMEGA==1) THEN
             C=COSH(OMEGA*DH)
             S=SINH(OMEGA*DH)
          ELSE
             C=COS(OMEGA*DH)
             S=SIN(OMEGA*DH)
          ENDIF
          EL%MATY(1,1)=C;
          EL%MATY(1,2)=S/OMEGA;
          EL%MATY(1,3)=zero;
          EL%MATY(2,1)=S_OMEGA*OMEGA*S; EL%MATY(2,2)=C;
          EL%MATY(2,3)=zero;
       ELSE
          EL%MATY(1,3)=zero;
          EL%MATY(2,3)=zero;
          EL%MATY(1,1)=one;EL%MATY(1,2)=DH;
          EL%MATY(2,2)=one;EL%MATY(2,1)=zero;
       ENDIF




    ELSE     !  SPEED FALSE OR KNOB TRUE


       HX(1,1)=zero;HX(1,2)=DH;HX(1,3)=zero;HX(1,4)=zero;
       HX(2,1)=-DH*DIR*(EL%BN(2)+EL%P%B0*EL%BN(1));HX(2,2)=zero;HX(2,3)=DH*EL%P%B0;HX(2,4)=zero;
       HX(3,1)=zero;HX(3,2)=zero;HX(3,3)=zero;HX(3,4)=zero;
       HX(4,1)=DH*EL%P%B0;HX(4,2)=zero;HX(4,3)=zero;HX(4,4)=zero;

       HY(1,1)=zero;HY(1,2)=HX(1,2);HY(1,3)=zero;HY(1,4)=zero;
       HY(2,1)=DH*DIR*EL%BN(2);HY(2,2)=zero;HY(2,3)=zero;HY(2,4)=zero;
       HY(3,1)=zero;HY(3,2)=zero;HY(3,3)=zero;HY(3,4)=zero;
       HY(4,1)=zero;HY(4,2)=zero;HY(4,3)=zero;HY(4,4)=zero;


       ! BUG FOUND BY SCHMIDT (SUBTLE ONE; AFFECTS PTC LOGIC; YUCK!)

       !    IF(EL%P%TIME) THEN
       !       HX(2,3)=HX(2,3)/el%P%beta0
       !       HX(4,1)=HX(4,1)/el%P%beta0
       !    ENDIF


       CALL EXPCOSY7(HY,EL%MATY,EL%LX)
       CALL EXPCOSY7(HX,EL%MATX,EL%LX)


    ENDIF     !  SPEED FALSE OR KNOB TRUE

    DIR=-1
    IF(SPEED.AND.(.NOT.KNOB)) THEN

       S_OMEGA=-1
       OMEGA2=DIR*(EL%BN(2)+EL%P%B0*EL%BN(1))

       IF(OMEGA2<zero) THEN
          OMEGA2=-OMEGA2
          S_OMEGA=1
       ENDIF
       OMEGA=SQRT(OMEGA2)


       IF(OMEGA>zero) THEN
          IF(S_OMEGA==1) THEN
             C=COSH(OMEGA*DH)
             S=SINH(OMEGA*DH)
          ELSE
             C=COS(OMEGA*DH)
             S=SIN(OMEGA*DH)
          ENDIF
          EL%RMATX(1,1)=C;
          EL%RMATX(1,2)=S/OMEGA;
          EL%RMATX(1,3)= EL%P%B0*(C-one)/OMEGA2*S_OMEGA;
          EL%RMATX(2,1)=S_OMEGA*OMEGA*S; EL%RMATX(2,2)=C;
          EL%RMATX(2,3)= EL%P%B0*EL%RMATX(1,2);
          EL%RLX(1)=EL%P%B0*EL%RMATX(1,2);   EL%RLX(2)=EL%RMATX(1,3);
          EL%RLX(3)=-EL%P%B0**2*S_OMEGA*(DH-EL%RMATX(1,2))/OMEGA2;
       ELSE
          EL%RMATX(1,1)=one;EL%RMATX(1,2)=DH;
          EL%RMATX(2,1)=zero
          EL%RMATX(2,2)=one
          EL%RMATX(2,3)= EL%P%B0*DH;
          EL%RMATX(1,3)= EL%RMATX(2,3)*DH/two;
          EL%RLX(1)=EL%RMATX(2,3);EL%RLX(2)=EL%RMATX(1,3);
          EL%RLX(3)=EL%RMATX(1,3)*EL%P%B0*DH/three
       ENDIF


       S_OMEGA=-1
       OMEGA2=-DIR*EL%BN(2)

       IF(OMEGA2<zero) THEN
          OMEGA2=-OMEGA2
          S_OMEGA=1
       ENDIF
       OMEGA=SQRT(OMEGA2)


       IF(OMEGA>zero) THEN
          IF(S_OMEGA==1) THEN
             C=COSH(OMEGA*DH)
             S=SINH(OMEGA*DH)
          ELSE
             C=COS(OMEGA*DH)
             S=SIN(OMEGA*DH)
          ENDIF
          EL%RMATY(1,1)=C;
          EL%RMATY(1,2)=S/OMEGA;
          EL%RMATY(1,3)=zero;
          EL%RMATY(2,1)=S_OMEGA*OMEGA*S; EL%RMATY(2,2)=C;
          EL%RMATY(2,3)=zero;
       ELSE
          EL%RMATY(1,3)=zero;
          EL%RMATY(2,3)=zero;
          EL%RMATY(1,1)=one;EL%RMATY(1,2)=DH;
          EL%RMATY(2,2)=one;EL%RMATY(2,1)=zero;
       ENDIF




    ELSE     !  SPEED FALSE OR KNOB TRUE


       HX(1,1)=zero;HX(1,2)=DH;HX(1,3)=zero;HX(1,4)=zero;
       HX(2,1)=-DH*DIR*(EL%BN(2)+EL%P%B0*EL%BN(1));HX(2,2)=zero;HX(2,3)=DH*EL%P%B0;HX(2,4)=zero;
       HX(3,1)=zero;HX(3,2)=zero;HX(3,3)=zero;HX(3,4)=zero;
       HX(4,1)=DH*EL%P%B0;HX(4,2)=zero;HX(4,3)=zero;HX(4,4)=zero;

       HY(1,1)=zero;HY(1,2)=HX(1,2);HY(1,3)=zero;HY(1,4)=zero;
       HY(2,1)=DH*DIR*EL%BN(2);HY(2,2)=zero;HY(2,3)=zero;HY(2,4)=zero;
       HY(3,1)=zero;HY(3,2)=zero;HY(3,3)=zero;HY(3,4)=zero;
       HY(4,1)=zero;HY(4,2)=zero;HY(4,3)=zero;HY(4,4)=zero;


       ! BUG FOUND BY SCHMIDT (SUBTLE ONE; AFFECTS PTC LOGIC; YUCK!)

       !    IF(EL%P%TIME) THEN
       !       HX(2,3)=HX(2,3)/el%P%beta0
       !       HX(4,1)=HX(4,1)/el%P%beta0
       !    ENDIF

       CALL EXPCOSY7(HY,EL%RMATY,EL%RLX)
       CALL EXPCOSY7(HX,EL%RMATX,EL%RLX)



    ENDIF     !  SPEED FALSE OR KNOB TRUE


    DO I=1,4
       DO J=1,4
          CALL KILL(HX(I,J))
          CALL KILL(HY(I,J))
       ENDDO
    ENDDO
    CALL KILL(DH)





  END SUBROUTINE GETMAT7D

  SUBROUTINE PUSHTKT7R(EL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(TKTF),INTENT(IN):: EL
    real(dp) T(4)

    ! BUG FOUND BY SCHMIDT (SUBTLE ONE; AFFECTS PTC LOGIC; YUCK!)
    !    T(1)=EL%MATX(1,1)*X(1)+EL%MATX(1,2)*X(2)+EL%MATX(1,3)*X(5)
    !    T(2)=EL%MATX(2,1)*X(1)+EL%MATX(2,2)*X(2)+EL%MATX(2,3)*X(5)


    IF(EL%P%DIR*EL%P%CHARGE==1) THEN
       IF(EL%P%TIME) THEN
          T(1)=EL%MATX(1,1)*X(1)+EL%MATX(1,2)*X(2)+EL%MATX(1,3)*X(5)/el%P%beta0
          T(2)=EL%MATX(2,1)*X(1)+EL%MATX(2,2)*X(2)+EL%MATX(2,3)*X(5)/el%P%beta0
          T(3)=EL%MATY(1,1)*X(3)+EL%MATY(1,2)*X(4)
          T(4)=EL%MATY(2,1)*X(3)+EL%MATY(2,2)*X(4)
          X(6)=X(6)+EL%LX(1)*X(1)/el%P%beta0+EL%LX(2)*X(2)/el%P%beta0+EL%LX(3)*X(5)
       ELSE
          T(1)=EL%MATX(1,1)*X(1)+EL%MATX(1,2)*X(2)+EL%MATX(1,3)*X(5)
          T(2)=EL%MATX(2,1)*X(1)+EL%MATX(2,2)*X(2)+EL%MATX(2,3)*X(5)
          T(3)=EL%MATY(1,1)*X(3)+EL%MATY(1,2)*X(4)
          T(4)=EL%MATY(2,1)*X(3)+EL%MATY(2,2)*X(4)
          X(6)=X(6)+EL%LX(1)*X(1)+EL%LX(2)*X(2)+EL%LX(3)*X(5)
       ENDIF
    ELSE
       IF(EL%P%TIME) THEN
          T(1)=EL%RMATX(1,1)*X(1)+EL%RMATX(1,2)*X(2)+EL%RMATX(1,3)*X(5)/el%P%beta0
          T(2)=EL%RMATX(2,1)*X(1)+EL%RMATX(2,2)*X(2)+EL%RMATX(2,3)*X(5)/el%P%beta0
          T(3)=EL%RMATY(1,1)*X(3)+EL%RMATY(1,2)*X(4)
          T(4)=EL%RMATY(2,1)*X(3)+EL%RMATY(2,2)*X(4)
          X(6)=X(6)+EL%RLX(1)*X(1)/el%P%beta0+EL%RLX(2)*X(2)/el%P%beta0+EL%RLX(3)*X(5)
       ELSE
          T(1)=EL%RMATX(1,1)*X(1)+EL%RMATX(1,2)*X(2)+EL%RMATX(1,3)*X(5)
          T(2)=EL%RMATX(2,1)*X(1)+EL%RMATX(2,2)*X(2)+EL%RMATX(2,3)*X(5)
          T(3)=EL%RMATY(1,1)*X(3)+EL%RMATY(1,2)*X(4)
          T(4)=EL%RMATY(2,1)*X(3)+EL%RMATY(2,2)*X(4)
          X(6)=X(6)+EL%RLX(1)*X(1)+EL%RLX(2)*X(2)+EL%RLX(3)*X(5)
       ENDIF
    ENDIF

    X(1)=T(1);X(2)=T(2);X(3)=T(3);X(4)=T(4);

  END SUBROUTINE PUSHTKT7R

  SUBROUTINE PUSHTKT7D(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(TKTFP),INTENT(IN):: EL
    TYPE(REAL_8) T(4)

    CALL ALLOC(T,4)

    ! BUG FOUND BY SCHMIDT (SUBTLE ONE; AFFECTS PTC LOGIC; YUCK!)
    !    T(1)=EL%MATX(1,1)*X(1)+EL%MATX(1,2)*X(2)+EL%MATX(1,3)*X(5)
    !    T(2)=EL%MATX(2,1)*X(1)+EL%MATX(2,2)*X(2)+EL%MATX(2,3)*X(5)
    IF(EL%P%DIR*EL%P%CHARGE==1) THEN
       IF(EL%P%TIME) THEN
          T(1)=EL%MATX(1,1)*X(1)+EL%MATX(1,2)*X(2)+EL%MATX(1,3)*X(5)/el%P%beta0
          T(2)=EL%MATX(2,1)*X(1)+EL%MATX(2,2)*X(2)+EL%MATX(2,3)*X(5)/el%P%beta0
          T(3)=EL%MATY(1,1)*X(3)+EL%MATY(1,2)*X(4)
          T(4)=EL%MATY(2,1)*X(3)+EL%MATY(2,2)*X(4)
          X(6)=X(6)+EL%LX(1)*X(1)/el%P%beta0+EL%LX(2)*X(2)/el%P%beta0+EL%LX(3)*X(5)
       ELSE
          T(1)=EL%MATX(1,1)*X(1)+EL%MATX(1,2)*X(2)+EL%MATX(1,3)*X(5)
          T(2)=EL%MATX(2,1)*X(1)+EL%MATX(2,2)*X(2)+EL%MATX(2,3)*X(5)
          T(3)=EL%MATY(1,1)*X(3)+EL%MATY(1,2)*X(4)
          T(4)=EL%MATY(2,1)*X(3)+EL%MATY(2,2)*X(4)
          X(6)=X(6)+EL%LX(1)*X(1)+EL%LX(2)*X(2)+EL%LX(3)*X(5)
       ENDIF
    ELSE
       IF(EL%P%TIME) THEN
          T(1)=EL%RMATX(1,1)*X(1)+EL%RMATX(1,2)*X(2)+EL%RMATX(1,3)*X(5)/el%P%beta0
          T(2)=EL%RMATX(2,1)*X(1)+EL%RMATX(2,2)*X(2)+EL%RMATX(2,3)*X(5)/el%P%beta0
          T(3)=EL%RMATY(1,1)*X(3)+EL%RMATY(1,2)*X(4)
          T(4)=EL%RMATY(2,1)*X(3)+EL%RMATY(2,2)*X(4)
          X(6)=X(6)+EL%RLX(1)*X(1)/el%P%beta0+EL%RLX(2)*X(2)/el%P%beta0+EL%RLX(3)*X(5)
       ELSE
          T(1)=EL%RMATX(1,1)*X(1)+EL%RMATX(1,2)*X(2)+EL%RMATX(1,3)*X(5)
          T(2)=EL%RMATX(2,1)*X(1)+EL%RMATX(2,2)*X(2)+EL%RMATX(2,3)*X(5)
          T(3)=EL%RMATY(1,1)*X(3)+EL%RMATY(1,2)*X(4)
          T(4)=EL%RMATY(2,1)*X(3)+EL%RMATY(2,2)*X(4)
          X(6)=X(6)+EL%RLX(1)*X(1)+EL%RLX(2)*X(2)+EL%RLX(3)*X(5)
       ENDIF
    ENDIF

    X(1)=T(1);X(2)=T(2);X(3)=T(3);X(4)=T(4);

    CALL KILL(T,4)

  END SUBROUTINE PUSHTKT7D

  SUBROUTINE PUSHTKT7S(EL,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(TKTFP),INTENT(IN):: EL
    TYPE(REAL_8) X(6)


    CALL ALLOC(X)

    X=Y

    CALL PUSHTKT7(EL,X)

    Y=X

    CALL KILL(X)

  END SUBROUTINE PUSHTKT7S

  !***********************************************************************
  ! ALMOST SAME AS ELEMENT KTK AND KTKP (POLYMORPH) CUT AND PASTE PLEASE *
  !***********************************************************************
  SUBROUTINE KICKTKT7R(EL,YL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(TKTF),INTENT(IN):: EL
    real(dp),INTENT(IN):: YL
    real(dp) X1,X3,X5,BBYTW,BBXTW,BBYTWT,B(3),B2
    INTEGER J,DIR

    DIR=EL%P%DIR*EL%P%CHARGE

    X1=X(1)
    X3=X(3)

    if(EL%P%TIME) then
       X5=ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
       X(2)=X(2)+YL*EL%P%B0*(X5-X(5)/EL%P%BETA0)
       X(6)=X(6)+YL*EL%P%B0*(  (X(5)+one/EL%P%beta0)/(one+X5) - one/EL%P%beta0  )*X(1)
    else
       X5=X(5)
    endif


    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF


    IF(EL%P%RADIATION) THEN
       B(1)=BBXTW
       B(2)=BBYTW  !+EL%BN(1)
       B(3)=zero
       CALL B2PERP(EL%P,B,X,X5,B2)
       IF(EL%P%EXACT) THEN
          X(5)=X(5)-CRADF(EL%P)*(one+X(5))**3*B2*YL/ROOT((one+X(5))**2-X(2)**2-X(4)**2)
       ELSE
          X(5)=X(5)-CRADF(EL%P)*(one+X(5))**2*B2*(one+X1*EL%P%B0+half*(X(2)**2+X(4)**2)/(one+X(5))**2)*YL
       ENDIF
       if(EL%P%TIME) then
          X(2)=X(2)*ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          X(4)=X(4)*ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
       else
          X(2)=X(2)*(one+X(5))/(one+X5)
          X(4)=X(4)*(one+X(5))/(one+X5)
       endif
    ENDIF

    X(2)=X(2)-YL*DIR*(BBYTW-DIR*EL%P%B0-EL%BN(2)*X(1))
    X(4)=X(4)+YL*DIR*(BBXTW-EL%BN(2)*X(3))


  END SUBROUTINE KICKTKT7R



  SUBROUTINE KICKTKT7P(EL,YL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(TKTFP),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) X1,X3,X5,BBYTW,BBXTW,BBYTWT,B(3),B2
    INTEGER J,DIR

    DIR=EL%P%DIR*EL%P%CHARGE


    CALL ALLOC(X1)
    CALL ALLOC(X3)
    CALL ALLOC(X5)
    CALL ALLOC(BBYTW)
    CALL ALLOC(BBXTW)
    CALL ALLOC(BBYTWT)


    X1=X(1)
    X3=X(3)

    if(EL%P%TIME) then
       X5=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
       X(2)=X(2)+YL*EL%P%B0*(X5-X(5)/EL%P%BETA0)
       X(6)=X(6)+YL*EL%P%B0*( (X(5)+one/EL%P%beta0)/(one+X5) - one/EL%P%beta0  )*X(1)
    else
       X5=X(5)
    endif


    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF

    IF(EL%P%RADIATION) THEN
       CALL ALLOC(B2)
       CALL ALLOC(B,3)
       B(1)=BBXTW
       B(2)=BBYTW    !+EL%BN(1)
       B(3)=zero
       CALL B2PERP(EL%P,B,X,X5,B2)
       IF(EL%P%EXACT) THEN
          X(5)=X(5)-CRADF(EL%P)*(one+X(5))**3*B2*YL/SQRT((one+X(5))**2-X(2)**2-X(4)**2)
       ELSE
          X(5)=X(5)-CRADF(EL%P)*(one+X(5))**2*B2*(one+X1*EL%P%B0+half*(X(2)**2+X(4)**2)/(one+X(5))**2)*YL
       ENDIF
       if(EL%P%TIME) then
          X(2)=X(2)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          X(4)=X(4)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
       else
          X(2)=X(2)*(one+X(5))/(one+X5)
          X(4)=X(4)*(one+X(5))/(one+X5)
       endif
       CALL KILL(B2)
       CALL KILL(B,3)
    ENDIF

    X(2)=X(2)-YL*DIR*(BBYTW-DIR*EL%P%B0-EL%BN(2)*X(1))
    X(4)=X(4)+YL*DIR*(BBXTW-EL%BN(2)*X(3))


    CALL KILL(X1)
    CALL KILL(X3)
    CALL KILL(X5)
    CALL KILL(BBYTW)
    CALL KILL(BBXTW)
    CALL KILL(BBYTWT)

  END SUBROUTINE KICKTKT7P

  SUBROUTINE KICKTKT7S(EL,YL,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(REAL_8) X(6),XR(6)
    TYPE(DAMAP) XP,ID,DISP,XT
    TYPE(TKTFP),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) X1,X3,X5,BBYTW,BBXTW,BBYTWT,B(3),B2,DENF
    real(dp) B20,B30,BF, v(6)  !,R1,R2,DEN0
    INTEGER I,J,DIR
    logical(lp) done_stoch

    DIR=EL%P%DIR*EL%P%CHARGE


    CALL ALLOC(X1)
    CALL ALLOC(X3)
    CALL ALLOC(denf)
    CALL ALLOC(X5)
    CALL ALLOC(BBYTW)
    CALL ALLOC(BBXTW)
    CALL ALLOC(BBYTWT)
    CALL ALLOC(X)
    CALL ALLOC(XP)
    CALL ALLOC(B2)
    CALL ALLOC(B,3)
    CALL ALLOC(XR)
    CALL ALLOC(ID)
    CALL ALLOC(DISP)
    CALL ALLOC(XT)

    X=Y

    X1=X(1)
    X3=X(3)

    if(EL%P%TIME) then
       X5=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
       X(2)=X(2)+YL*EL%P%B0*(X5-X(5)/EL%P%BETA0)
       X(6)=X(6)+YL*EL%P%B0*(  (X(5)+one/EL%P%beta0)/(one+X5) - one/EL%P%beta0  )*X(1)
    else
       X5=X(5)
    endif


    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF


    XP=X
    XR=X
    XP%V(2)=X(2)/(one+x5)
    XP%V(4)=X(4)/(one+x5)
    IF(EL%P%RADIATION) THEN
       B(1)=BBXTW
       B(2)=BBYTW  !+EL%BN(1)
       B(3)=zero
       CALL B2PERP(EL%P,B,X,X5,B2)
       IF(EL%P%EXACT) THEN
          X(5)=X(5)-CRADF(EL%P)*(one+X(5))**3*B2*YL/SQRT((one+X(5))**2-X(2)**2-X(4)**2)
       ELSE
          X(5)=X(5)-CRADF(EL%P)*(one+X(5))**2*B2*(one+X1*EL%P%B0+half*(X(2)**2+X(4)**2)/(one+X(5))**2)*YL
       ENDIF

       if(EL%P%TIME) then
          X(2)=X(2)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          X(4)=X(4)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
       else
          X(2)=X(2)*(one+X(5))/(one+X5)
          X(4)=X(4)*(one+X(5))/(one+X5)
       endif

    ENDIF

    done_stoch=.false.
    if(EL%P%B0==zero.and.stoch_in_rec) then

       if(EL%P%EXACT) then
          denf=(one+xR(5))**5/SQRT((one+XR(5))**2-XR(2)**2-XR(4)**2)
       else
          denf=(one+xr(5))**4*(one+xr(1)*EL%P%B0+half*(xr(2)**2+xr(4)**2)/(one+xr(5))**2)
       endif
       b20=b2
       b30=b20**c_1_5
       bf=cflucf(el%p)*b30
       denf=denf*bf*yl
       done_stoch=.true.
    elseif(EL%P%B0/=zero)   then
       done_stoch=.true.
    endif

    if(done_stoch) then

       if(EL%P%B0/=zero) then
          !
          if(knob) then
             v=XR
             DISP=xp*id
             id=1
             DISP=ID-DISP
             XP=DISP*XP

             id=0
             XT=XR
             DISP=XT*ID
             ID=1
             DISP=ID-DISP
             XT=DISP*XT

             xr=xt+V
             CALL B2PERP(EL%P,B,Xr,X5,B2)
             if(EL%P%EXACT) then
                denf=(one+xR(5))**5/SQRT((one+XR(5))**2-XR(2)**2-XR(4)**2)
             else
                denf=(one+xr(5))**4*(one+xr(1)*EL%P%B0+half*(xr(2)**2+xr(4)**2)/(one+xr(5))**2)
             endif
             denf=DENF*cflucf(el%p)*yl*b2**c_1_5
          else
             CALL B2PERP(EL%P,B,Xr,X5,B2)
             if(EL%P%EXACT) then
                denf=(one+xR(5))**5/SQRT((one+XR(5))**2-XR(2)**2-XR(4)**2)
             else
                denf=(one+xr(5))**4*(one+xr(1)*EL%P%B0+half*(xr(2)**2+xr(4)**2)/(one+xr(5))**2)
             endif
             b20=b2
             b30=b20**c_1_5
             bf=cflucf(el%p)*b30
             denf=denf*bf*yl
          endif
       endif

       xp=xp**(-1)
       do i=1,6
          do j=1,6
             X1=(xp%v(i)).par.'000010'
             X3=(xp%v(j)).par.'000010'
             denf=denf.par.'000000'
             y(I)%E(J)=y(I)%E(J)+denf*x1*x3
          enddo
       enddo
    endif


    X(2)=X(2)-YL*DIR*(BBYTW-DIR*EL%P%B0-EL%BN(2)*X(1))
    X(4)=X(4)+YL*DIR*(BBXTW-EL%BN(2)*X(3))




    Y=X
    CALL KILL(B2)
    CALL KILL(B,3)
    CALL KILL(XP)
    CALL KILL(X)
    CALL KILL(X1)
    CALL KILL(X3)
    CALL KILL(denf)
    CALL KILL(X5)
    CALL KILL(BBYTW)
    CALL KILL(BBXTW)
    CALL KILL(BBYTWT)
    CALL KILL(XR)
    CALL KILL(ID)
    CALL KILL(DISP)
    CALL KILL(XT)

  END SUBROUTINE KICKTKT7S

  SUBROUTINE KICKPATH6R(EL,YL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(KTK),INTENT(IN):: EL
    real(dp),INTENT(IN):: YL
    real(dp) PZ,PZ0
    ! ETIENNE
    IF(.NOT.EL%P%EXACT) RETURN
    if(EL%P%TIME) then
       PZ=root(one+two*X(5)/EL%P%beta0+x(5)**2-X(2)**2-X(4)**2)
       PZ0=root(one+two*X(5)/EL%P%beta0+x(5)**2)
       X(6)=X(6)+YL*(one/EL%P%beta0+x(5))*(X(2)**2+X(4)**2)*(one/PZ/(PZ+PZ0)-one/PZ0**2/two) &
            &     /PZ0
       PZ=(X(2)**2+X(4)**2)/PZ/PZ0/(PZ+PZ0)   ! = (one/PZ-one/PZ0)
       X(1)=X(1)+YL*X(2)*PZ
       X(3)=X(3)+YL*X(4)*PZ
    else
       PZ=root((one+X(5))**2-X(2)**2-X(4)**2)
       PZ0=one+X(5)
       X(6)=X(6)+YL*(X(2)**2+X(4)**2)*(one/PZ/(PZ+PZ0)-one/PZ0**2/two)
       PZ=(X(2)**2+X(4)**2)/PZ/PZ0/(PZ+PZ0)   ! = (one/PZ-one/PZ0)
       X(1)=X(1)+YL*X(2)*PZ
       X(3)=X(3)+YL*X(4)*PZ
    endif

  END SUBROUTINE KICKPATH6R

  SUBROUTINE KICKPATH6P(EL,YL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(KTKP),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) PZ,PZ0
    ! ETIENNE
    IF(.NOT.EL%P%EXACT) RETURN
    CALL ALLOC(PZ,PZ0)
    if(EL%P%TIME) then
       PZ=sqrt(one+two*X(5)/EL%P%beta0+x(5)**2-X(2)**2-X(4)**2)
       PZ0=sqrt(one+two*X(5)/EL%P%beta0+x(5)**2)
       X(6)=X(6)+YL*(one/EL%P%beta0+x(5))*(X(2)**2+X(4)**2)*(one/PZ/(PZ+PZ0)-one/PZ0**2/two) &
            &     /PZ0
       PZ=(X(2)**2+X(4)**2)/PZ/PZ0/(PZ+PZ0)   ! = (one/PZ-one/PZ0)
       X(1)=X(1)+YL*X(2)*PZ
       X(3)=X(3)+YL*X(4)*PZ
    else
       PZ=sqrt((one+X(5))**2-X(2)**2-X(4)**2)
       PZ0=one+X(5)
       X(6)=X(6)+YL*(X(2)**2+X(4)**2)*(one/PZ/(PZ+PZ0)-one/PZ0**2/two)
       PZ=(X(2)**2+X(4)**2)/PZ/PZ0/(PZ+PZ0)   ! = (one/PZ-one/PZ0)
       X(1)=X(1)+YL*X(2)*PZ
       X(3)=X(3)+YL*X(4)*PZ
    endif
    CALL KILL(PZ,PZ0)

  END SUBROUTINE KICKPATH6P

  SUBROUTINE KICKPATH6S(EL,YL,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(KTKP),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) X(6)
    ! ETIENNE
    IF(.NOT.EL%P%EXACT) RETURN
    CALL ALLOC(X)

    X=Y

    CALL KICKPATH(EL,YL,X)

    Y=X

    CALL KILL(X)

  END SUBROUTINE KICKPATH6S

  SUBROUTINE KICKPATHR(EL,YL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(TKTF),INTENT(IN):: EL
    real(dp),INTENT(IN):: YL
    real(dp) X1,X5,PZ
    ! ETIENNE
    if(EL%P%TIME) then
       if(EL%P%EXACT) THEN
          PZ=ROOT(one+two*X(5)/EL%P%beta0+x(5)**2-X(2)**2-X(4)**2)
          X(1)=X(1)+YL*X(2)*(one/PZ-one)
          X(3)=X(3)+YL*X(4)*(one/PZ-one)
          X(6)=X(6)+YL*(one/EL%P%beta0+x(5))/PZ-YL*(1-EL%P%TOTALPATH)/EL%P%beta0
       ELSE
          X5=ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
          X1=(X(5)+one/EL%P%BETA0)/(one+X5)
          X(1)=X(1)-X5*YL*X(2)/(one+X5)
          X(3)=X(3)-X5*YL*X(4)/(one+X5)
          ! BUG FOUND BY SCHMIDT
          !       X(6)=X(6)+X1*YL*( EL%P%TOTALPATH + (X(2)**2+X(4)**2)/two/(one+X5)**2 )
          X(6)=X(6)+X1*YL*( one + (X(2)**2+X(4)**2)/two/(one+X5)**2 )-YL*(1-EL%P%TOTALPATH)/EL%P%beta0
       ENDIF
    else
       if(EL%P%EXACT) THEN
          PZ=ROOT((one+X(5))**2-X(2)**2-X(4)**2)
          X(1)=X(1)+YL*X(2)*(one/PZ-one)
          X(3)=X(3)+YL*X(4)*(one/PZ-one)
          X(6)=X(6)+YL*(one+x(5))/PZ-YL*(1-EL%P%TOTALPATH)
       ELSE
          X(1)=X(1)-X(5)*YL*X(2)/(one+X(5))
          X(3)=X(3)-X(5)*YL*X(4)/(one+X(5))
          X(6)=X(6)+YL*( EL%P%TOTALPATH + (X(2)**2+X(4)**2)/two/(one+X(5))**2 )
       endif
    endif

  END SUBROUTINE KICKPATHR

  SUBROUTINE KICKPATHD(EL,YL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(TKTFP),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) X1,X5,PZ

    if(EL%P%TIME) then
       if(EL%P%EXACT) THEN
          CALL ALLOC(PZ)
          PZ=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2-X(2)**2-X(4)**2)
          X(1)=X(1)+YL*X(2)*(one/PZ-one)
          X(3)=X(3)+YL*X(4)*(one/PZ-one)
          X(6)=X(6)+YL*(one/EL%P%beta0+x(5))/PZ-YL*(1-EL%P%TOTALPATH)/EL%P%beta0
          CALL KILL(PZ)
       ELSE
          CALL ALLOC(X1,X5)
          X5=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
          X1=(X(5)+one/EL%P%BETA0)/(one+X5)
          X(1)=X(1)-X5*YL*X(2)/(one+X5)
          X(3)=X(3)-X5*YL*X(4)/(one+X5)
          ! BUG FOUND BY SCHMIDT
          !       X(6)=X(6)+X1*YL*( EL%P%TOTALPATH + (X(2)**2+X(4)**2)/two/(one+X5)**2 )
          X(6)=X(6)+X1*YL*( one + (X(2)**2+X(4)**2)/two/(one+X5)**2 )-YL*(1-EL%P%TOTALPATH)/EL%P%beta0
          CALL KILL(X1,X5)
       ENDIF
    else
       if(EL%P%EXACT) THEN
          CALL ALLOC(PZ)
          PZ=SQRT((one+X(5))**2-X(2)**2-X(4)**2)
          X(1)=X(1)+YL*X(2)*(one/PZ-one)
          X(3)=X(3)+YL*X(4)*(one/PZ-one)
          X(6)=X(6)+YL*(one+x(5))/PZ-YL*(1-EL%P%TOTALPATH)
          CALL KILL(PZ)
       ELSE
          X(1)=X(1)-X(5)*YL*X(2)/(one+X(5))
          X(3)=X(3)-X(5)*YL*X(4)/(one+X(5))
          X(6)=X(6)+YL*( EL%P%TOTALPATH + (X(2)**2+X(4)**2)/two/(one+X(5))**2 )
       endif
    endif

  END SUBROUTINE KICKPATHD

  SUBROUTINE KICKPATHS(EL,YL,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(TKTFP),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) X(6)

    CALL ALLOC(X)

    X=Y

    CALL KICKPATH(EL,YL,X)

    Y=X

    CALL KILL(X)

  END SUBROUTINE KICKPATHS


  SUBROUTINE INTTKT7R(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: MID
    TYPE(TKTF),INTENT(INOUT):: EL
    INTEGER I
    real(dp) DK,DK2,DK6,DK4,DK5

    IF(PRESENT(MID)) CALL XMID(MID,X,0)


    SELECT CASE(EL%P%METHOD)
    CASE(1)
       DK=EL%L/EL%P%NST
       DK2=two*dk

       DO I=1,EL%P%NST/2
          CALL PUSHTKT7(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKTKT7(EL,DK2,X)
          CALL KICKPATH(EL,DK,X)
          IF(PRESENT(MID)) CALL XMID(MID,X,2*I-1)
          CALL PUSHTKT7(EL,X)
          IF(PRESENT(MID)) CALL XMID(MID,X,2*I)
       ENDDO

    CASE(2)
       DK2=EL%L/EL%P%NST
       DK=DK2/two

       DO I=1,EL%P%NST
          !       CALL KICKTKT7(EL,DK2,X)
          !       CALL KICKPATH(EL,DK2,X)
          !       CALL PUSHTKT7(EL,X)
          !       CALL KICKPATH(EL,DK2,X)
          !       CALL KICKTKT7(EL,DK2,X)
          CALL PUSHTKT7(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKTKT7(EL,DK2,X)
          CALL KICKPATH(EL,DK,X)
          CALL PUSHTKT7(EL,X)

          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO

    CASE(4)
       DK2=EL%L/EL%P%NST/three
       DK6=two*DK2
       DK=DK2/two

       !       CALL KICKTKT7(EL,DK,X)
       DO I=1,EL%P%NST     !-1
          CALL KICKTKT7(EL,DK,X)    ! NEW
          CALL KICKPATH(EL,DK,X)
          CALL PUSHTKT7(EL,X)
          CALL KICKPATH(EL,DK2,X)
          CALL KICKTKT7(EL,DK6,X)

          CALL KICKPATH(EL,DK2,X)
          CALL PUSHTKT7(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKTKT7(EL,DK,X) ! NEW
          !          CALL KICKTKT7(EL,DK2,X)
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
       !       CALL KICKPATH(EL,DK,X)
       !       CALL PUSHTKT7(EL,X)
       !       CALL KICKPATH(EL,DK2,X)
       !       CALL KICKTKT7(EL,DK6,X)

       !       CALL KICKPATH(EL,DK2,X)
       !       CALL PUSHTKT7(EL,X)
       !       CALL KICKPATH(EL,DK,X)
       !       CALL KICKTKT7(EL,DK,X)

    CASE(6)
       DK2=c_14*EL%L/EL%P%NST/c_90
       DK4=c_32*EL%L/EL%P%NST/c_90
       DK6=twelve*EL%L/EL%P%NST/c_90
       DK5=DK6/two
       DK=DK2/two

       !       CALL KICKTKT7(EL,DK,X)
       DO I=1,EL%P%NST   !-1
          CALL KICKTKT7(EL,DK,X)  ! NEW
          CALL KICKPATH(EL,DK,X)

          CALL PUSHTKT7(EL,X)

          CALL KICKTKT7(EL,DK4,X)
          CALL KICKPATH(EL,DK4,X)

          CALL PUSHTKT7(EL,X)

          CALL KICKPATH(EL,DK5,X)
          CALL KICKTKT7(EL,DK6,X)   ! SYMMETRY POINT

          CALL KICKPATH(EL,DK5,X)

          CALL PUSHTKT7(EL,X)

          CALL KICKPATH(EL,DK4,X)
          CALL KICKTKT7(EL,DK4,X)

          CALL PUSHTKT7(EL,X)
          CALL KICKPATH(EL,DK,X)
          ! CALL KICKTKT7(EL,DK2,X)
          CALL KICKTKT7(EL,DK,X)  ! NEW

          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
       !       CALL KICKPATH(EL,DK,X)

       !       CALL PUSHTKT7(EL,X)

       !      CALL KICKTKT7(EL,DK4,X)

       !      CALL KICKPATH(EL,DK4,X)

       !       CALL PUSHTKT7(EL,X)

       !       CALL KICKPATH(EL,DK5,X)
       !       CALL KICKTKT7(EL,DK6,X)   ! SYMMETRY POINT
       !       CALL KICKPATH(EL,DK5,X)

       !       CALL PUSHTKT7(EL,X)

       !       CALL KICKPATH(EL,DK4,X)
       !       CALL KICKTKT7(EL,DK4,X)

       !      CALL PUSHTKT7(EL,X)
       !      CALL KICKPATH(EL,DK,X)
       !      CALL KICKTKT7(EL,DK,X)

    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

  END SUBROUTINE INTTKT7R

  SUBROUTINE INTTKT7D(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: MID
    TYPE(TKTFP),INTENT(INOUT):: EL
    INTEGER I
    logical(lp) BN,L
    TYPE(REAL_8) DK,DK2,DK6,DK4,DK5

    IF((EL%BN(2)%KIND==3.OR.EL%L%KIND==3).AND.KNOB) THEN
       CALL GETMAT7(EL)                                      ! RECOMPUTES ONLY IF KNOB (SPEED)
    ENDIF

    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    SELECT CASE(EL%P%METHOD)
    CASE(1)
       CALL ALLOC(DK);CALL ALLOC(DK2);
       DK=EL%L/EL%P%NST
       DK2=two*dk

       DO I=1,EL%P%NST/2
          CALL PUSHTKT7(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKTKT7(EL,DK2,X)
          CALL KICKPATH(EL,DK,X)
          CALL PUSHTKT7(EL,X)
       ENDDO
       CALL KILL(DK);CALL KILL(DK2);

    CASE(2)
       CALL ALLOC(DK);CALL ALLOC(DK2);
       DK2=EL%L/EL%P%NST
       DK=DK2/two



       DO I=1,EL%P%NST
          CALL PUSHTKT7(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKTKT7(EL,DK2,X)
          CALL KICKPATH(EL,DK,X)
          CALL PUSHTKT7(EL,X)

       ENDDO


       CALL KILL(DK);CALL KILL(DK2);


    CASE(4)
       CALL ALLOC(DK);CALL ALLOC(DK2);CALL ALLOC(DK6);
       DK2=EL%L/EL%P%NST/three
       DK6=two*DK2
       DK=DK2/two

       !       CALL KICKTKT7(EL,DK,X)
       DO I=1,EL%P%NST     !-1
          CALL KICKTKT7(EL,DK,X)   ! NEW
          CALL KICKPATH(EL,DK,X)
          CALL PUSHTKT7(EL,X)
          CALL KICKPATH(EL,DK2,X)
          CALL KICKTKT7(EL,DK6,X)
          CALL KICKPATH(EL,DK2,X)
          CALL PUSHTKT7(EL,X)
          CALL KICKPATH(EL,DK,X)
          !          CALL KICKTKT7(EL,DK2,X)
          CALL KICKTKT7(EL,DK,X)   ! NEW
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
       !       CALL KICKPATH(EL,DK,X)
       !       CALL PUSHTKT7(EL,X)
       !       CALL KICKPATH(EL,DK2,X)
       !       CALL KICKTKT7(EL,DK6,X)
       !       CALL KICKPATH(EL,DK2,X)
       !       CALL PUSHTKT7(EL,X)
       !       CALL KICKPATH(EL,DK,X)
       !       CALL KICKTKT7(EL,DK,X)

       CALL KILL(DK);CALL KILL(DK2);CALL KILL(DK6);

    CASE(6)
       CALL ALLOC(DK);CALL ALLOC(DK2);CALL ALLOC(DK6);CALL ALLOC(DK4);CALL ALLOC(DK5);
       DK2=c_14*EL%L/EL%P%NST/c_90
       DK4=c_32*EL%L/EL%P%NST/c_90
       DK6=twelve*EL%L/EL%P%NST/c_90
       DK5=DK6/two
       DK=DK2/two


       !       CALL KICKTKT7(EL,DK,X)
       DO I=1,EL%P%NST    !-1
          CALL KICKTKT7(EL,DK,X)   ! NEW
          CALL KICKPATH(EL,DK,X)

          CALL PUSHTKT7(EL,X)

          CALL KICKTKT7(EL,DK4,X)
          CALL KICKPATH(EL,DK4,X)

          CALL PUSHTKT7(EL,X)

          CALL KICKPATH(EL,DK5,X)
          CALL KICKTKT7(EL,DK6,X)   ! SYMMETRY POINT
          CALL KICKPATH(EL,DK5,X)

          CALL PUSHTKT7(EL,X)

          CALL KICKPATH(EL,DK4,X)
          CALL KICKTKT7(EL,DK4,X)

          CALL PUSHTKT7(EL,X)
          CALL KICKPATH(EL,DK,X)
          !          CALL KICKTKT7(EL,DK2,X)
          CALL KICKTKT7(EL,DK,X)   ! NEW
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)

       ENDDO
       !       CALL KICKPATH(EL,DK,X)

       !       CALL PUSHTKT7(EL,X)

       !       CALL KICKTKT7(EL,DK4,X)
       !       CALL KICKPATH(EL,DK4,X)

       !       CALL PUSHTKT7(EL,X)

       !       CALL KICKPATH(EL,DK5,X)
       !       CALL KICKTKT7(EL,DK6,X)   ! SYMMETRY POINT
       !       CALL KICKPATH(EL,DK5,X)

       !       CALL PUSHTKT7(EL,X)

       !       CALL KICKPATH(EL,DK4,X)
       !       CALL KICKTKT7(EL,DK4,X)

       !       CALL PUSHTKT7(EL,X)
       !       CALL KICKPATH(EL,DK,X)
       !       CALL KICKTKT7(EL,DK,X)

       CALL KILL(DK);CALL KILL(DK2);CALL KILL(DK6);CALL KILL(DK4);CALL KILL(DK5);


    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

    IF(KNOB) THEN
       BN=.FALSE.
       L=.FALSE.
       IF(EL%BN(2)%KIND==3) THEN
          BN=.TRUE.
       ENDIF
       IF(EL%L%KIND==3) THEN
          L=.TRUE.
       ENDIF
       IF(BN.OR.L) THEN
          EL%BN(2)%KIND=1
          EL%L%KIND=1
          CALL KILL(EL)                               ! RECOMPUTES ONLY IF KNOB (SPEED)
          CALL ALLOC(EL)                               ! KNOB IS REMOVED THE SLOW WAY(SPEED)
          CALL GETMAT7(EL)
          IF(BN) EL%BN(2)%KIND=3
          IF(L)  EL%L%KIND=3
       ENDIF
    ENDIF


  END SUBROUTINE INTTKT7D

  SUBROUTINE INTTKT7S(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(TKTFP),INTENT(INOUT):: EL
    INTEGER I
    TYPE(REAL_8) DK,DK2,DK6,DK4,DK5
    logical(lp) BN,L
    ! etienne

    IF((EL%BN(2)%KIND==3.OR.EL%L%KIND==3).AND.KNOB) THEN
       CALL GETMAT7(EL)                                      ! RECOMPUTES ONLY IF KNOB (SPEED)
    ENDIF
    SELECT CASE(EL%P%METHOD)
    CASE(1)
       CALL ALLOC(DK);CALL ALLOC(DK2);
       DK=EL%L/EL%P%NST
       DK2=two*dk

       DO I=1,EL%P%NST/2
          CALL PUSHTKT7(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKTKT7(EL,DK2,X)
          CALL KICKPATH(EL,DK,X)
          CALL PUSHTKT7(EL,X)
       ENDDO
       CALL KILL(DK);CALL KILL(DK2);
    CASE(2)
       CALL ALLOC(DK);CALL ALLOC(DK2);
       DK2=EL%L/EL%P%NST
       DK=DK2/two



       DO I=1,EL%P%NST
          CALL PUSHTKT7(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKTKT7(EL,DK2,X)
          CALL KICKPATH(EL,DK,X)
          CALL PUSHTKT7(EL,X)
       ENDDO


       CALL KILL(DK);CALL KILL(DK2);


    CASE(4)
       CALL ALLOC(DK);CALL ALLOC(DK2);CALL ALLOC(DK6);
       DK2=EL%L/EL%P%NST/three
       DK6=two*DK2
       DK=DK2/two

       CALL KICKTKT7(EL,DK,X)
       DO I=1,EL%P%NST-1
          CALL KICKPATH(EL,DK,X)
          CALL PUSHTKT7(EL,X)
          CALL KICKPATH(EL,DK2,X)
          CALL KICKTKT7(EL,DK6,X)
          CALL KICKPATH(EL,DK2,X)
          CALL PUSHTKT7(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKTKT7(EL,DK2,X)
       ENDDO
       CALL KICKPATH(EL,DK,X)
       CALL PUSHTKT7(EL,X)
       CALL KICKPATH(EL,DK2,X)
       CALL KICKTKT7(EL,DK6,X)
       CALL KICKPATH(EL,DK2,X)
       CALL PUSHTKT7(EL,X)
       CALL KICKPATH(EL,DK,X)
       CALL KICKTKT7(EL,DK,X)

       CALL KILL(DK);CALL KILL(DK2);CALL KILL(DK6);

    CASE(6)
       CALL ALLOC(DK);CALL ALLOC(DK2);CALL ALLOC(DK6);CALL ALLOC(DK4);CALL ALLOC(DK5);
       DK2=c_14*EL%L/EL%P%NST/c_90
       DK4=c_32*EL%L/EL%P%NST/c_90
       DK6=twelve*EL%L/EL%P%NST/c_90
       DK5=DK6/two
       DK=DK2/two


       CALL KICKTKT7(EL,DK,X)
       DO I=1,EL%P%NST-1
          CALL KICKPATH(EL,DK,X)

          CALL PUSHTKT7(EL,X)

          CALL KICKTKT7(EL,DK4,X)
          CALL KICKPATH(EL,DK4,X)

          CALL PUSHTKT7(EL,X)

          CALL KICKPATH(EL,DK5,X)
          CALL KICKTKT7(EL,DK6,X)   ! SYMMETRY POINT
          CALL KICKPATH(EL,DK5,X)

          CALL PUSHTKT7(EL,X)

          CALL KICKPATH(EL,DK4,X)
          CALL KICKTKT7(EL,DK4,X)

          CALL PUSHTKT7(EL,X)
          CALL KICKPATH(EL,DK,X)
          CALL KICKTKT7(EL,DK2,X)

       ENDDO
       CALL KICKPATH(EL,DK,X)

       CALL PUSHTKT7(EL,X)

       CALL KICKTKT7(EL,DK4,X)
       CALL KICKPATH(EL,DK4,X)

       CALL PUSHTKT7(EL,X)

       CALL KICKPATH(EL,DK5,X)
       CALL KICKTKT7(EL,DK6,X)   ! SYMMETRY POINT
       CALL KICKPATH(EL,DK5,X)

       CALL PUSHTKT7(EL,X)

       CALL KICKPATH(EL,DK4,X)
       CALL KICKTKT7(EL,DK4,X)

       CALL PUSHTKT7(EL,X)
       CALL KICKPATH(EL,DK,X)
       CALL KICKTKT7(EL,DK,X)

       CALL KILL(DK);CALL KILL(DK2);CALL KILL(DK6);CALL KILL(DK4);CALL KILL(DK5);


    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

    IF(KNOB) THEN
       BN=.FALSE.
       L=.FALSE.
       IF(EL%BN(2)%KIND==3) THEN
          BN=.TRUE.
       ENDIF
       IF(EL%L%KIND==3) THEN
          L=.TRUE.
       ENDIF
       IF(BN.OR.L) THEN
          EL%BN(2)%KIND=1
          EL%L%KIND=1
          CALL KILL(EL)                               ! RECOMPUTES ONLY IF KNOB (SPEED)
          CALL ALLOC(EL)                               ! KNOB IS REMOVED THE SLOW WAY(SPEED)
          CALL GETMAT7(EL)
          IF(BN) EL%BN(2)%KIND=3
          IF(L)  EL%L%KIND=3
       ENDIF
    ENDIF

  END SUBROUTINE INTTKT7S

  SUBROUTINE SYMPINTTKT7R(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(TKTF),INTENT(INOUT):: EL
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: MID


    IF(EL%P%DIR==1) THEN
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL INTTKT7(EL,X,MID)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
    ELSE
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL INTTKT7(EL,X,MID)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
    ENDIF


  END SUBROUTINE SYMPINTTKT7R

  SUBROUTINE SYMPINTTKT7D(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(TKTFP),INTENT(INOUT):: EL
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: MID

    IF(EL%P%DIR==1) THEN
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL INTTKT7(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
    ELSE
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL INTTKT7(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
    ENDIF


  END SUBROUTINE SYMPINTTKT7D

  SUBROUTINE SYMPINTTKT7S(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(TKTFP),INTENT(INOUT):: EL

    IF(EL%P%DIR==1) THEN
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL INTTKT7(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
    ELSE
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       CALL INTTKT7(EL,X)
       IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       CALL EDGE(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
    ENDIF

  END SUBROUTINE SYMPINTTKT7S


  SUBROUTINE EXPR7(H,MATOUT,LX)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: H(4,4),MATOUT(2,3),LX(3)
    real(dp) AD(4,4),TEMP(4,4)
    real(dp) NORM,NORM0,NORMAT,NORMAT0
    logical(lp) FIRST
    INTEGER I,J,K,N

    DO I=1,2
       DO J=1,3
          MATOUT(I,J)=zero
       ENDDO
    ENDDO
    DO I=1,3
       LX(I)=zero
    ENDDO

    DO I=1,4
       DO J=1,4
          AD(I,J)=zero
          TEMP(I,J)=zero
       ENDDO
    ENDDO
    MATOUT(1,1)=one
    MATOUT(2,2)=one
    AD(1,1)=one
    AD(2,2)=one
    AD(3,3)=one
    AD(4,4)=one
    FIRST=.TRUE.
    NORM=c_1d6
    NORMAT=c_2d5
    DO N=1,NMAXI
       !  COMPUTING H**N/N!
       DO I=1,4
          DO J=1,4
             DO K=1,4
                TEMP(I,K)=H(I,J)*AD(J,K)+TEMP(I,K)
             ENDDO
          ENDDO
       ENDDO
       NORM0=NORM
       NORMAT0=NORMAT
       !  ADDING TO MATOUT
       NORM=zero
       NORMAT=zero
       DO I=1,4   !2
          DO J=1,4
             AD(I,J)=TEMP(I,J)/N
             IF(I<3.AND.J<4)  THEN
                MATOUT(I,J)=MATOUT(I,J)+AD(I,J)
                NORMAT=NORMAT+ABS(MATOUT(I,J))
             ENDIF
             IF(I==4.AND.J<4) THEN
                LX(J)=LX(J)+AD(I,J)
                NORMAT=NORMAT+ABS(LX(J))
             ENDIF
             TEMP(I,J)=zero
          ENDDO
       ENDDO

       NORM=ABS(NORMAT-NORMAT0)


       IF(FIRST) THEN
          IF(NORM<EPS_DEF_KIND) THEN
             FIRST=.FALSE.
          ENDIF
       ELSE
          IF(NORM>=NORM0) GOTO 100
       ENDIF


    ENDDO

    w_p=0
    w_p%nc=1
    w_p%fc='(1(1X,A72))'
    write(w_p%c(1),'(A31,1X,I4,1X,A11)') " EXPSOLR FAILED TO CONVERGE IN ",NMAXI," ITERATIONS"
    call write_e(0)

100 CONTINUE

  END SUBROUTINE EXPR7


  SUBROUTINE EXPD7(H,MATOUT,LX)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: H(4,4),MATOUT(2,3),LX(3)
    TYPE(REAL_8) AD(4,4),TEMP(4,4)
    real(dp) NORM,NORM0,NORMAT,NORMAT0
    logical(lp) FIRST
    INTEGER I,J,K,N

    DO I=1,2
       DO J=1,3
          MATOUT(I,J)=zero
       ENDDO
    ENDDO
    DO I=1,3
       LX(I)=zero
    ENDDO

    DO I=1,4
       DO J=1,4
          CALL ALLOC(AD(I,J))
          CALL ALLOC(TEMP(I,J))
       ENDDO
    ENDDO
    MATOUT(1,1)=one
    MATOUT(2,2)=one
    AD(1,1)=one
    AD(2,2)=one
    AD(3,3)=one
    AD(4,4)=one
    FIRST=.TRUE.
    NORM=c_1d6
    NORMAT=c_2d5
    DO N=1,NMAXI
       !  COMPUTING H**N/N!
       DO I=1,4
          DO J=1,4
             DO K=1,4
                TEMP(I,K)=H(I,J)*AD(J,K)+TEMP(I,K)
             ENDDO
          ENDDO
       ENDDO
       NORM0=NORM
       NORMAT0=NORMAT
       !  ADDING TO MATOUT
       NORM=zero
       NORMAT=zero
       DO I=1,4   !2
          DO J=1,4
             AD(I,J)=TEMP(I,J)/N

             IF(I<3.AND.J<4)  THEN
                MATOUT(I,J)=MATOUT(I,J)+AD(I,J)
                NORMAT=NORMAT+ABS(MATOUT(I,J))
             ENDIF
             IF(I==4.AND.J<4) THEN
                LX(J)=LX(J)+AD(I,J)
                NORMAT=NORMAT+ABS(LX(J))
             ENDIF
             TEMP(I,J)=zero
          ENDDO
       ENDDO
       NORM=ABS(NORMAT-NORMAT0)


       IF(FIRST) THEN
          IF(NORM<EPS_DEF_KIND) THEN
             FIRST=.FALSE.
          ENDIF
       ELSE
          IF(NORM>=NORM0) GOTO 100
       ENDIF


    ENDDO

    w_p=0
    w_p%nc=1
    w_p%fc='(1(1X,A72))'
    write(w_p%c(1),'(A31,1X,I4,1X,A11)') " EXPSOLR FAILED TO CONVERGE IN ",NMAXI," ITERATIONS"
    call write_e(0)

100 CONTINUE

    DO I=1,4
       DO J=1,4
          CALL KILL(AD(I,J))
          CALL KILL(TEMP(I,J))
       ENDDO
    ENDDO


  END SUBROUTINE EXPD7

!!!!!!!!!!!!!!!!!!!!  the smi  !!!!!!!!!!!!!!!!!!!!!!!!!!!

  subroutine push_Nsmi_r(el,x,MID)
    implicit none
    TYPE (NSMI),INTENT(IN)::EL
    TYPE(WORM), OPTIONAL,INTENT(INOUT):: MID
    real(dp) ,INTENT(INOUT)::x(6)
    real(dp) ekk,CRKVE,CIKVE,CRKVEUK,XL,ZL


    XL=X(1)
    ZL=X(3)
    CRKVE=XL
    CIKVE=ZL

    EKK=-EL%P%DIR*EL%P%CHARGE*EL%BN(EL%P%NMUL)/TWO                      ! ANTI-SIXTRACK UNIT

    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    select case(el%P%NMUL)


       !--HORIZONTAL DIPOLE
    case(1)
       X(2)=X(2)+EKK
       !--NORMAL QUADRUPOLE
    case(2)
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL SEXTUPOLE
    case(3)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !--NORMAL OCTUPOLE
    case(4)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !--NORMAL DECAPOLE
    case(5)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL DODECAPOL
    case(6)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL 14-POL
    case(7)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL 16-POL
    case(8)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL 18-POL
    case(9)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL 20-POL
    case(10)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
    END SELECT

    IF(PRESENT(MID)) CALL XMID(MID,X,1)

    select case(el%P%NMUL)


       !--HORIZONTAL DIPOLE
    case(1)
       X(2)=X(2)+EKK
       !--NORMAL QUADRUPOLE
    case(2)
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL SEXTUPOLE
    case(3)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !--NORMAL OCTUPOLE
    case(4)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !--NORMAL DECAPOLE
    case(5)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL DODECAPOL
    case(6)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL 14-POL
    case(7)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL 16-POL
    case(8)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL 18-POL
    case(9)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL 20-POL
    case(10)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
    END SELECT

    !    IF(PRESENT(MID)) CALL XMID(MID,X,2)

  end subroutine push_Nsmi_r

  subroutine push_Nsmi_D(el,x)
    implicit none
    TYPE (NSMIP),INTENT(IN)::EL
    ! TYPE(WORM_8), OPTIONAL,INTENT(INOUT):: MID
    TYPE(real_8) ,INTENT(INOUT)::x(6)
    TYPE(real_8)ekk,CRKVE,CIKVE,CRKVEUK,XL,ZL

    CALL ALLOC(ekk);CALL ALLOC(CRKVE);CALL ALLOC(CIKVE);
    CALL ALLOC(CRKVEUK);CALL ALLOC(XL);CALL ALLOC(ZL);

    XL=X(1)
    ZL=X(3)
    CRKVE=XL
    CIKVE=ZL

    EKK=-EL%P%DIR*EL%P%CHARGE*EL%BN(EL%P%NMUL)/TWO                      ! ANTI-SIXTRACK UNIT

    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    select case(el%P%NMUL)


       !--HORIZONTAL DIPOLE
    case(1)
       X(2)=X(2)+EKK
       !--NORMAL QUADRUPOLE
    case(2)
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL SEXTUPOLE
    case(3)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !--NORMAL OCTUPOLE
    case(4)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !--NORMAL DECAPOLE
    case(5)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL DODECAPOL
    case(6)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL 14-POL
    case(7)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL 16-POL
    case(8)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL 18-POL
    case(9)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL 20-POL
    case(10)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
    END SELECT

    !    IF(PRESENT(MID)) CALL XMID(MID,X,1)

    select case(el%P%NMUL)


       !--HORIZONTAL DIPOLE
    case(1)
       X(2)=X(2)+EKK
       !--NORMAL QUADRUPOLE
    case(2)
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL SEXTUPOLE
    case(3)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !--NORMAL OCTUPOLE
    case(4)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !--NORMAL DECAPOLE
    case(5)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL DODECAPOL
    case(6)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL 14-POL
    case(7)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL 16-POL
    case(8)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL 18-POL
    case(9)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
       !---NORMAL 20-POL
    case(10)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CRKVE
       X(4)=X(4)-EKK*CIKVE
    END SELECT

    !    IF(PRESENT(MID)) CALL XMID(MID,X,2)

    CALL KILL(ekk);CALL KILL(CRKVE);CALL KILL(CIKVE);
    CALL KILL(CRKVEUK);CALL KILL(XL);CALL KILL(ZL);



  end subroutine push_Nsmi_D


  subroutine push_Nsmi_S(el,Y)
    implicit none
    TYPE (NSMIP),INTENT(IN)::EL
    TYPE(ENV_8) ,INTENT(INOUT)::Y(6)
    TYPE(real_8) x(6)

    CALL ALLOC(X)
    X=Y
    CALL push_Nsmi_D(EL,X)
    Y=X
    CALL KILL(X)

  end subroutine push_Nsmi_S

  subroutine push_Ssmi_r(el,x,MID)
    implicit none
    TYPE (SSMI),INTENT(IN)::EL
    TYPE(WORM), OPTIONAL,INTENT(INOUT):: MID
    real(dp) ,INTENT(INOUT)::x(6)
    real(dp) ekk,CRKVE,CIKVE,CRKVEUK,XL,ZL

    XL=X(1)
    ZL=X(3)
    CRKVE=XL
    CIKVE=ZL

    EKK=EL%P%DIR*EL%P%CHARGE*EL%AN(EL%P%NMUL)/TWO
    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    select case(el%P%NMUL)

       !---VERTICAL DIPOLE
    CASE(1)
       X(4)=X(4)+EKK
       !---SKEW QUADRUPOLE
    CASE(2)
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW SEXTUPOLE
    CASE(3)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW OCTUPOLE
    CASE(4)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW DECAPOLE
    CASE(5)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW DODECAPOL
    CASE(6)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW 14-POL
    CASE(7)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW 16-POL
    CASE(8)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW 18-POL
    CASE(9)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW 20-POL
    CASE(10)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE

    END SELECT

    IF(PRESENT(MID)) CALL XMID(MID,X,1)

    select case(el%P%NMUL)

       !---VERTICAL DIPOLE
    CASE(1)
       X(4)=X(4)+EKK
       !---SKEW QUADRUPOLE
    CASE(2)
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW SEXTUPOLE
    CASE(3)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW OCTUPOLE
    CASE(4)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW DECAPOLE
    CASE(5)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW DODECAPOL
    CASE(6)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW 14-POL
    CASE(7)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW 16-POL
    CASE(8)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW 18-POL
    CASE(9)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW 20-POL
    CASE(10)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE

    END SELECT
    !    IF(PRESENT(MID)) CALL XMID(MID,X,2)

  end subroutine push_Ssmi_r

  subroutine push_Ssmi_D(el,x)
    implicit none
    TYPE (SSMIP),INTENT(IN)::EL
    ! TYPE(WORM_8), OPTIONAL,INTENT(INOUT):: MID
    TYPE(real_8) ,INTENT(INOUT)::x(6)
    TYPE(real_8)ekk,CRKVE,CIKVE,CRKVEUK,XL,ZL

    CALL ALLOC(ekk);CALL ALLOC(CRKVE);CALL ALLOC(CIKVE);
    CALL ALLOC(CRKVEUK);CALL ALLOC(XL);CALL ALLOC(ZL);

    XL=X(1)
    ZL=X(3)
    CRKVE=XL
    CIKVE=ZL

    EKK=EL%P%DIR*EL%P%CHARGE*EL%AN(EL%P%NMUL)/TWO
    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    select case(el%P%NMUL)

       !---VERTICAL DIPOLE
    CASE(1)
       X(4)=X(4)+EKK
       !---SKEW QUADRUPOLE
    CASE(2)
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW SEXTUPOLE
    CASE(3)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW OCTUPOLE
    CASE(4)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW DECAPOLE
    CASE(5)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW DODECAPOL
    CASE(6)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW 14-POL
    CASE(7)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW 16-POL
    CASE(8)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW 18-POL
    CASE(9)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW 20-POL
    CASE(10)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE

    END SELECT

    !    IF(PRESENT(MID)) CALL XMID(MID,X,1)

    select case(el%P%NMUL)

       !---VERTICAL DIPOLE
    CASE(1)
       X(4)=X(4)+EKK
       !---SKEW QUADRUPOLE
    CASE(2)
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW SEXTUPOLE
    CASE(3)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW OCTUPOLE
    CASE(4)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW DECAPOLE
    CASE(5)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW DODECAPOL
    CASE(6)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW 14-POL
    CASE(7)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW 16-POL
    CASE(8)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW 18-POL
    CASE(9)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE
       !---SKEW 20-POL
    CASE(10)
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       CRKVEUK=CRKVE*XL-CIKVE*ZL
       CIKVE=CRKVE*ZL+CIKVE*XL
       CRKVE=CRKVEUK
       X(2)=X(2)+EKK*CIKVE
       X(4)=X(4)+EKK*CRKVE

    END SELECT
    !    IF(PRESENT(MID)) CALL XMID(MID,X,2)

    CALL KILL(ekk);CALL KILL(CRKVE);CALL KILL(CIKVE);
    CALL KILL(CRKVEUK);CALL KILL(XL);CALL KILL(ZL);

  end subroutine push_Ssmi_D

  subroutine push_Ssmi_S(el,Y)
    implicit none
    TYPE (SSMIP),INTENT(IN)::EL
    TYPE(ENV_8) ,INTENT(INOUT)::Y(6)
    TYPE(real_8) x(6)

    CALL ALLOC(X)
    X=Y
    CALL push_Ssmi_D(EL,X)
    Y=X
    CALL KILL(X)

  end subroutine push_Ssmi_S

!!!! *************************************************************** !!!!
!!!! *           Beginning of the teapot element                   * !!!!
!!!! *************************************************************** !!!!
  SUBROUTINE GETANBNR(EL)
    IMPLICIT NONE
    TYPE(TEAPOT),INTENT(INOUT):: EL
    INTEGER I,J,K,POW,nmul

    nmul=EL%P%NMUL
    IF(EL%P%NMUL> SECTOR_NMUL) THEN
       !  WRITE(6,*) " EL%P%NMUL > SECTOR_NMUL_MAX : CANNOT CONTINUE"
       nmul=SECTOR_NMUL
       !      STOP 1
    ENDIF

    DO I=1,S_B(NMUL)%N_MONO
       EL%BF_X(I)=zero
       EL%BF_Y(I)=zero
    ENDDO
    DO I=1,NMUL
       DO J=1,S_B(NMUL)%N_MONO
          K=S_B(NMUL)%I(J)+S_B(NMUL)%J(J)
          POW=K+1-I
          IF(K+1>=I) THEN


             EL%BF_X(J)=EL%BF_X(J)+(EL%AN(I)*S_B(NMUL)%A_X(I,J)+EL%BN(I)*S_B(NMUL)%B_X(I,J))*EL%P%B0**POW
             EL%BF_Y(J)=EL%BF_Y(J)+(EL%AN(I)*S_B(NMUL)%A_Y(I,J)+EL%BN(I)*S_B(NMUL)%B_Y(I,J))*EL%P%B0**POW

          ENDIF
       ENDDO
    ENDDO


  END SUBROUTINE GETANBNR

  SUBROUTINE GETANBNP(EL)
    IMPLICIT NONE
    TYPE(TEAPOTP),INTENT(INOUT):: EL
    INTEGER I,J,K,POW,nmul

    nmul=EL%P%NMUL
    IF(EL%P%NMUL> SECTOR_NMUL) THEN
       !  WRITE(6,*) " EL%P%NMUL > SECTOR_NMUL_MAX : CANNOT CONTINUE"
       nmul=SECTOR_NMUL
       !      STOP 1
    ENDIF

    DO I=1,S_B(NMUL)%N_MONO
       EL%BF_X(I)=zero
       EL%BF_Y(I)=zero
    ENDDO
    DO I=1,NMUL
       DO J=1,S_B(NMUL)%N_MONO
          K=S_B(NMUL)%I(J)+S_B(NMUL)%J(J)
          POW=K+1-I
          IF(K+1>=I) THEN


             EL%BF_X(J)=EL%BF_X(J)+(EL%AN(I)*S_B(NMUL)%A_X(I,J)+EL%BN(I)*S_B(NMUL)%B_X(I,J))*EL%P%B0**POW
             EL%BF_Y(J)=EL%BF_Y(J)+(EL%AN(I)*S_B(NMUL)%A_Y(I,J)+EL%BN(I)*S_B(NMUL)%B_Y(I,J))*EL%P%B0**POW

          ENDIF
       ENDDO
    ENDDO




  END SUBROUTINE GETANBNP




  SUBROUTINE SSECH1R(EL,YL,DL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    real(dp),INTENT(IN):: YL,DL
    TYPE(TEAPOT),INTENT(IN):: EL

    ! if(abs(x(1))+abs(x(3))+abs(x(2))+abs(x(4))>absolute_aperture.or.(.not.CHECK_MADX_APERTURE)) then
    !    if(CHECK_MADX_APERTURE) c_%message="exceed absolute_aperture in SSECH1R"
    !    CHECK_STABLE=.false.
    ! endif
    ! if(.not.CHECK_STABLE) return

    IF(EL%DRIFTKICK) THEN
       CALL Sprot(EL,YL,DL,X)
    ELSE
       CALL SSEC(EL,YL,DL,X)
    ENDIF

  END SUBROUTINE SSECH1R

  SUBROUTINE SSECH1P(EL,YL,DL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(REAL_8),INTENT(IN):: YL
    real(dp),INTENT(IN):: DL
    TYPE(TEAPOTP),INTENT(IN):: EL

    IF(EL%DRIFTKICK) THEN
       CALL Sprot(EL,YL,DL,X)
    ELSE
       CALL SSEC(EL,YL,DL,X)
    ENDIF

  END SUBROUTINE SSECH1P

  SUBROUTINE SSECH1S(EL,YL,DL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(REAL_8),INTENT(IN):: YL
    real(dp),INTENT(IN):: DL
    TYPE(TEAPOTP),INTENT(IN):: EL

    IF(EL%DRIFTKICK) THEN
       CALL Sprot(EL,YL,DL,X)
    ELSE
       CALL SSEC(EL,YL,DL,X)
    ENDIF

  END SUBROUTINE SSECH1S



  SUBROUTINE Sprotr(EL,YL,DL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    real(dp),INTENT(IN):: YL,DL
    TYPE(TEAPOT),INTENT(IN):: EL
    real(dp) XN(6),PZ,PT
    real(dp)  A,b,R
    if(EL%P%B0/=zero) then
       A=YL*EL%P%B0
       R=one/EL%P%B0
       if(EL%P%TIME) then
          B=EL%P%BETA0
          PZ=ROOT(one+two*x(5)/b+X(5)**2-X(2)**2-X(4)**2)
          PT=one-X(2)*TAN(A)/PZ
          !       XN(1)=(X(1)+R)/COS(A)/PT-R
          XN(1)=(X(1)+R*(two*sin(a/two)**2+X(2)*sin(A)/PZ))/COS(A)/PT
          XN(2)=X(2)*COS(A)+SIN(A)*PZ
          XN(3)=X(3)+X(4)*(X(1)+R)*TAN(A)/PZ/PT
          XN(6)=X(6)+(X(1)+R)*TAN(A)/PZ/PT*(one/b+x(5))
          XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL/EL%P%BETA0
       else
          PZ=ROOT((one+X(5))**2-X(2)**2-X(4)**2)
          PT=one-X(2)*TAN(A)/PZ
          XN(1)=(X(1)+R*(two*sin(a/two)**2+X(2)*sin(A)/PZ))/COS(A)/PT
          XN(2)=X(2)*COS(A)+SIN(A)*PZ
          XN(3)=X(3)+X(4)*(X(1)+R)*TAN(A)/PZ/PT
          XN(6)=X(6)+(one+X(5))*(X(1)+R)*TAN(A)/PZ/PT
          XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL
       endif
       X(1)=XN(1)
       X(2)=XN(2)
       X(3)=XN(3)
       X(6)=XN(6)
    else
       CALL DRIFT(YL,DL,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    endif
    !    CALL CHECK_STABILITY(X)
    call check_root_drift(el%p,X)
  END SUBROUTINE Sprotr

  SUBROUTINE SPROTP(EL,YL,DL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(REAL_8),INTENT(IN):: YL
    real(dp),INTENT(IN):: DL
    TYPE(TEAPOTP),INTENT(IN):: EL
    TYPE(REAL_8) XN(6),PZ,PT,A,ah
    real(dp)  b,R

    if(EL%P%B0/=zero) then
       CALL ALLOC( XN,6)
       CALL ALLOC( PZ)
       CALL ALLOC( PT)
       CALL ALLOC( A,ah)
       A=YL*EL%P%B0
       ah=a/two
       R=one/EL%P%B0
       if(EL%P%TIME) then
          B=EL%P%BETA0
          PZ=SQRT(one+two*x(5)/b+X(5)**2-X(2)**2-X(4)**2)
          PT=one-X(2)*TAN(A)/PZ
          !          XN(1)=(X(1)+R)/COS(A)/PT-R
          XN(1)=(X(1)+R*(two*sin(ah)**2+X(2)*sin(A)/PZ))/COS(A)/PT
          XN(2)=X(2)*COS(A)+SIN(A)*PZ
          XN(3)=X(3)+X(4)*(X(1)+R)*TAN(A)/PZ/PT
          XN(6)=X(6)+(X(1)+R)*TAN(A)/PZ/PT*(one/b+x(5))
          XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL/EL%P%BETA0
       else
          PZ=SQRT((one+X(5))**2-X(2)**2-X(4)**2)
          PT=one-X(2)*TAN(A)/PZ
          XN(1)=(X(1)+R*(two*sin(ah)**2+X(2)*sin(A)/PZ))/COS(A)/PT
          XN(2)=X(2)*COS(A)+SIN(A)*PZ
          XN(3)=X(3)+X(4)*(X(1)+R)*TAN(A)/PZ/PT
          XN(6)=X(6)+(one+X(5))*(X(1)+R)*TAN(A)/PZ/PT
          XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL
       endif
       X(1)=XN(1)
       X(2)=XN(2)
       X(3)=XN(3)
       X(6)=XN(6)

       CALL KILL( XN,6)
       CALL KILL( PZ)
       CALL KILL( PT)
       CALL KILL( A,ah)
    else
       CALL DRIFT(YL,DL,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    endif
  END SUBROUTINE SPROTP

  SUBROUTINE SPROTS(EL,YL,DL,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(REAL_8),INTENT(IN):: YL
    real(dp),INTENT(IN):: DL
    TYPE(TEAPOTP),INTENT(IN):: EL
    TYPE(REAL_8) XN(6),PZ,PT,A,X(6)
    real(dp)  b,R

    if(EL%P%B0/=zero) then
       CALL ALLOC( X,6)
       CALL ALLOC( XN,6)
       CALL ALLOC( PZ)
       CALL ALLOC( PT)
       CALL ALLOC( A)
       X=Y
       A=YL*EL%P%B0
       R=one/EL%P%B0
       if(EL%P%TIME) then
          B=EL%P%BETA0
          PZ=SQRT(one+two*x(5)/b+X(5)**2-X(2)**2-X(4)**2)
          PT=one-X(2)*TAN(A)/PZ
          XN(1)=(X(1)+R)/COS(A)/PT-R
          XN(2)=X(2)*COS(A)+SIN(A)*PZ
          XN(3)=X(3)+X(4)*(X(1)+R)*TAN(A)/PZ/PT
          XN(6)=X(6)+(X(1)+R)*TAN(A)/PZ/PT*(one/b+x(5))
          XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL/EL%P%BETA0
       else
          PZ=SQRT((one+X(5))**2-X(2)**2-X(4)**2)
          PT=one-X(2)*TAN(A)/PZ
          XN(1)=(X(1)+R)/COS(A)/PT-R
          XN(2)=X(2)*COS(A)+SIN(A)*PZ
          XN(3)=X(3)+X(4)*(X(1)+R)*TAN(A)/PZ/PT
          XN(6)=X(6)+(one+X(5))*(X(1)+R)*TAN(A)/PZ/PT
          XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL
       endif
       X(1)=XN(1)
       X(2)=XN(2)
       X(3)=XN(3)
       X(6)=XN(6)
       Y=X
       CALL KILL( X,6)
       CALL KILL( XN,6)
       CALL KILL( PZ)
       CALL KILL( PT)
       CALL KILL( A)
    else
       CALL DRIFT(YL,DL,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,Y)
    endif
  END SUBROUTINE SPROTS


  SUBROUTINE Ssecr(EL,YL,DL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    real(dp),INTENT(IN):: YL,DL
    TYPE(TEAPOT),INTENT(IN):: EL
    real(dp) XN(6),PZ,PZS,DPX,PT
    real(dp)  A,b,R
    INTEGER DIR

    DIR=EL%P%DIR*EL%P%CHARGE

    A=YL*EL%P%B0
    R=one/EL%P%B0
    if(EL%P%TIME) then
       B=EL%P%BETA0
       PZ=ROOT(one+two*x(5)/b+X(5)**2-X(2)**2-X(4)**2)
       XN(2)=X(2)*COS(A)+(PZ-DIR*EL%BN(1)*(R+X(1)))*SIN(A)
       DPX=(-X(2)*SIN(A)+(PZ-DIR*EL%BN(1)*(R+X(1)))*COS(A))/DIR/EL%BN(1)  !DPX*R/B1
       PT=ROOT(one+two*x(5)/b+X(5)**2-X(4)**2)
       PZS=ROOT(one+two*x(5)/b+X(5)**2-XN(2)**2-X(4)**2)
       XN(1)=PZS/DIR/EL%BN(1)-DPX-R

       XN(3)=(A+ARCSIN(X(2)/PT)-ARCSIN(XN(2)/PT))/DIR/EL%BN(1)

       XN(6)=X(6)+XN(3)*(one/b+x(5))
       XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL/EL%P%BETA0

       XN(3)=X(3)+X(4)*XN(3)
    else
       PZ=ROOT((one+X(5))**2-X(2)**2-X(4)**2)
       XN(2)=X(2)*COS(A) + ( PZ-DIR*EL%BN(1)*(R+X(1)) ) *SIN(A)
       DPX=(-X(2)*SIN(A)+(PZ-DIR*EL%BN(1)*(R+X(1)))*COS(A))/DIR/EL%BN(1)  !DPX*R/B1
       PT=ROOT((one+X(5))**2-X(4)**2)
       PZS=ROOT((one+X(5))**2-XN(2)**2-X(4)**2)
       XN(1)=PZS/DIR/EL%BN(1)-DPX-R

       XN(3)=(A+ARCSIN(X(2)/PT)-ARCSIN(XN(2)/PT))/DIR/EL%BN(1)

       XN(6)=X(6)+XN(3)*(one+X(5))
       XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL
       XN(3)=X(3)+X(4)*XN(3)

    endif
    X(1)=XN(1)
    X(2)=XN(2)
    X(3)=XN(3)
    X(6)=XN(6)
    !    CALL CHECK_STABILITY(X)
    call check_root_drift(EL%P,X)
  END SUBROUTINE Ssecr


  SUBROUTINE SsecP(EL,YL,DL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(REAL_8),INTENT(IN):: YL
    real(dp),INTENT(IN):: DL
    TYPE(TEAPOTP),INTENT(IN):: EL
    TYPE(REAL_8) XN(6),PZ,PT,A,PZS,DPX
    real(dp)  b,R
    INTEGER DIR

    DIR=EL%P%DIR*EL%P%CHARGE



    CALL ALLOC( XN,6)
    CALL ALLOC( PZ,PT,A,PZS,DPX)
    A=YL*EL%P%B0
    R=one/EL%P%B0
    if(EL%P%TIME) then
       B=EL%P%BETA0
       PZ=SQRT(one+two*x(5)/b+X(5)**2-X(2)**2-X(4)**2)
       XN(2)=X(2)*COS(A)+(PZ-DIR*EL%BN(1)*(R+X(1)))*SIN(A)
       DPX=(-X(2)*SIN(A)+(PZ-DIR*EL%BN(1)*(R+X(1)))*COS(A))/DIR/EL%BN(1)  !DPX*R/B1
       PT=SQRT(one+two*x(5)/b+X(5)**2-X(4)**2)
       PZS=SQRT(one+two*x(5)/b+X(5)**2-XN(2)**2-X(4)**2)
       XN(1)=PZS/DIR/EL%BN(1)-DPX-R

       XN(3)=(A+ASIN(X(2)/PT)-ASIN(XN(2)/PT))/DIR/EL%BN(1)

       XN(6)=X(6)+XN(3)*(one/b+x(5))
       XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL/EL%P%BETA0

       XN(3)=X(3)+X(4)*XN(3)
    else
       PZ=SQRT((one+X(5))**2-X(2)**2-X(4)**2)
       XN(2)=X(2)*COS(A) + ( PZ-DIR*EL%BN(1)*(R+X(1)) ) *SIN(A)
       DPX=(-X(2)*SIN(A)+(PZ-DIR*EL%BN(1)*(R+X(1)))*COS(A))/DIR/EL%BN(1)  !DPX*R/B1
       PT=SQRT((one+X(5))**2-X(4)**2)
       PZS=SQRT((one+X(5))**2-XN(2)**2-X(4)**2)
       XN(1)=PZS/DIR/EL%BN(1)-DPX-R

       XN(3)=(A+ASIN(X(2)/PT)-ASIN(XN(2)/PT))/DIR/EL%BN(1)

       XN(6)=X(6)+XN(3)*(one+X(5))
       XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL
       XN(3)=X(3)+X(4)*XN(3)

    endif
    X(1)=XN(1)
    X(2)=XN(2)
    X(3)=XN(3)
    X(6)=XN(6)

    CALL KILL( XN,6)
    CALL KILL( PZ,PT,A,PZS,DPX)
  END SUBROUTINE SsecP

  SUBROUTINE SsecS(EL,YL,DL,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(REAL_8),INTENT(IN):: YL
    real(dp),INTENT(IN):: DL
    TYPE(TEAPOTP),INTENT(IN):: EL
    TYPE(REAL_8) XN(6),X(6),PZ,PT,A,PZS,DPX
    real(dp)  b,R
    INTEGER DIR

    DIR=EL%P%DIR*EL%P%CHARGE


    CALL ALLOC( XN,6)
    CALL ALLOC( X,6)
    CALL ALLOC( PZ,PT,A,PZS,DPX)

    A=YL*EL%P%B0
    R=one/EL%P%B0
    X=Y
    if(EL%P%TIME) then
       B=EL%P%BETA0
       PZ=SQRT(one+two*x(5)/b+X(5)**2-X(2)**2-X(4)**2)
       XN(2)=X(2)*COS(A)+(PZ-DIR*EL%BN(1)*(R+X(1)))*SIN(A)
       DPX=(-X(2)*SIN(A)+(PZ-DIR*EL%BN(1)*(R+X(1)))*COS(A))/DIR/EL%BN(1)  !DPX*R/B1
       PT=SQRT(one+two*x(5)/b+X(5)**2-X(4)**2)
       PZS=SQRT(one+two*x(5)/b+X(5)**2-XN(2)**2-X(4)**2)
       XN(1)=PZS/DIR/EL%BN(1)-DPX-R

       XN(3)=(A+ASIN(X(2)/PT)-ASIN(XN(2)/PT))/DIR/EL%BN(1)

       XN(6)=X(6)+XN(3)*(one/b+x(5))
       XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL/EL%P%BETA0

       XN(3)=X(3)+X(4)*XN(3)
    else
       PZ=SQRT((one+X(5))**2-X(2)**2-X(4)**2)
       XN(2)=X(2)*COS(A) + ( PZ-DIR*EL%BN(1)*(R+X(1)) ) *SIN(A)
       DPX=(-X(2)*SIN(A)+(PZ-DIR*EL%BN(1)*(R+X(1)))*COS(A))/DIR/EL%BN(1)  !DPX*R/B1
       PT=SQRT((one+X(5))**2-X(4)**2)
       PZS=SQRT((one+X(5))**2-XN(2)**2-X(4)**2)
       XN(1)=PZS/DIR/EL%BN(1)-DPX-R

       XN(3)=(A+ASIN(X(2)/PT)-ASIN(XN(2)/PT))/DIR/EL%BN(1)

       XN(6)=X(6)+XN(3)*(one+X(5))
       XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL
       XN(3)=X(3)+X(4)*XN(3)

    endif
    X(1)=XN(1)
    X(2)=XN(2)
    X(3)=XN(3)
    X(6)=XN(6)
    Y=X

    CALL KILL( XN,6)
    CALL KILL( X,6)
    CALL KILL( PZ,PT,A,PZS,DPX)
  END SUBROUTINE SsecS

  SUBROUTINE SKICKR(EL,YL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    real(dp),INTENT(IN):: YL
    TYPE(TEAPOT),INTENT(IN):: EL
    real(dp) X1,X3,X5,BX,BY,BTX,BTY,B(3),B2,BtYT
    INTEGER J,M,A,K,DIR

    !    if(abs(x(1))+abs(x(3))+abs(x(2))+abs(x(4))>absolute_aperture.or.(.not.CHECK_MADX_APERTURE)) then
    !       if(CHECK_MADX_APERTURE) c_%message="exceed absolute_aperture in SKICKR"
    !       CHECK_STABLE=.false.
    !    endif
    !    if(.not.CHECK_STABLE) return

    DIR=EL%P%DIR*EL%P%CHARGE


    X1=X(1)
    X3=X(3)

    if(EL%P%TIME) then
       X5=ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
    else
       X5=X(5)
    endif


    BX=zero
    BY=zero

    k=0

    m=SECTOR_NMUL-1
    !    m=EL%P%nmul-1
    do a=m,1,-1
       BTX=zero
       BTY=zero
       do j=m-a,1,-1
          k=k+1
          !b%i(k)=a
          !b%j(k)=j
          BTX= (BTX+EL%BF_X(k))*X3  !x1
          BTY= (BTY+EL%BF_Y(k))*X3
       enddo

       k=k+1
       !  b%i(k)=a
       !  b%j(k)=0
       BTX= (BTX+EL%BF_X(k))
       BTY= (BTY+EL%BF_Y(k))
       BX= (BX+BTX)*X1
       BY= (BY+BTY)*X1
    enddo
    BTX=zero
    BTY=zero
    do j=m,1,-1
       k=k+1
       !  b%i(k)=0
       !  b%j(k)=j
       BTX= (BTX+EL%BF_X(k))*X3
       BTY= (BTY+EL%BF_Y(k))*X3
    enddo
    k=k+1
    !    b%i(k)=0
    !    b%j(k)=0
    BX= BX+BTX+EL%BF_X(k)  !+X3
    BY= BY+BTY+EL%BF_Y(k)  !+X3

    ! etienne
    IF(EL%P%NMUL>SECTOR_NMUL) THEN
       BtY=EL%BN(EL%P%NMUL)
       BtX=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,SECTOR_NMUL+1,-1
          BtYT=X1*BtY-X3*BtX+EL%BN(J)
          BtX =X3*BtY+X1*BtX+EL%AN(J)
          BtY =BtYT
       ENDDO

       DO  J=SECTOR_NMUL, 1,-1
          BtYT=X1*BtY-X3*BtX
          BtX =X3*BtY+X1*BtX
          BtY =BtYT
       ENDDO

       BX= BX-BTX
       BY= BY+BTY

    ENDIF



    X(2)=X(2)+YL*DIR*BX
    X(4)=X(4)+YL*DIR*BY
    IF(.NOT.EL%DRIFTKICK) THEN
       X(2)=X(2)+YL*DIR*EL%BN(1)*(one+X(1)*EL%P%B0)
    ENDIF

    IF(EL%P%RADIATION) THEN
       B(1)=BY/(one+EL%P%B0*X(1))
       B(2)=-BX/(one+EL%P%B0*X(1))
       B(3)=zero
       CALL B2PERP(EL%P,B,X,X5,B2)
       X(5)=X(5)-CRADF(EL%P)*(one+X(5))**3*B2*YL/ROOT((one+X(5))**2-X(2)**2-X(4)**2)*(one+EL%P%B0*X(1))
       if(EL%P%TIME) then
          X(2)=X(2)*ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          X(4)=X(4)*ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
       else
          X(2)=X(2)*(one+X(5))/(one+X5)
          X(4)=X(4)*(one+X(5))/(one+X5)
       endif
    ENDIF

  END SUBROUTINE SKICKR



  SUBROUTINE SKICKP(EL,YL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(TEAPOTP),INTENT(IN):: EL
    TYPE(REAL_8) X1,X3,BX,BY,BTX,BTY,X5,B(3),B2,BTYt
    INTEGER J,M,A,K,DIR

    real(dp) junk

    DIR=EL%P%DIR*EL%P%CHARGE

    CALL ALLOC(X1,X3,BX,BY,BTX,BTY,X5,B2,BTYt)
    CALL ALLOC(B,3)
    X1=X(1)
    X3=X(3)

    if(EL%P%TIME) then
       X5=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
    else
       X5=X(5)
    endif


    BX=zero
    BY=zero

    ! x1=one.mono.'1'
    ! x3=one.mono.'01'
    k=0
    m=SECTOR_NMUL-1
    !    m=EL%P%nmul-1
    do a=m,1,-1
       BTX=zero
       BTY=zero
       do j=m-a,1,-1
          k=k+1
          !b%i(k)=a
          !b%j(k)=j
          BTX= (BTX+EL%BF_X(k))*X3
          BTY= (BTY+EL%BF_Y(k))*X3
       enddo

       k=k+1
       !  b%i(k)=a
       !  b%j(k)=0
       BTX= (BTX+EL%BF_X(k))
       BTY= (BTY+EL%BF_Y(k))
       BX= (BX+BTX)*X1
       BY= (BY+BTY)*X1
    enddo
    BTX=zero
    BTY=zero
    do j=m,1,-1
       k=k+1
       !  b%i(k)=0
       !  b%j(k)=j
       BTX= (BTX+EL%BF_X(k))*X3
       BTY= (BTY+EL%BF_Y(k))*X3
    enddo
    k=k+1
    !    b%i(k)=0
    !    b%j(k)=0
    BX= BX+BTX+EL%BF_X(k)  !+X3
    BY= BY+BTY+EL%BF_Y(k)  !+X3

    ! etienne
    IF(EL%P%NMUL>SECTOR_NMUL) THEN
       BtY=EL%BN(EL%P%NMUL)
       BtX=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,SECTOR_NMUL+1,-1
          BtYT=X1*BtY-X3*BtX+EL%BN(J)
          BtX =X3*BtY+X1*BtX+EL%AN(J)
          BtY =BtYT
       ENDDO

       DO  J=SECTOR_NMUL, 1,-1
          BtYT=X1*BtY-X3*BtX
          BtX =X3*BtY+X1*BtX
          BtY =BtYT
       ENDDO

       BX= BX-BTX
       BY= BY+BTY

    ENDIF

    X(2)=X(2)+YL*DIR*BX
    X(4)=X(4)+YL*DIR*BY
    IF(.NOT.EL%DRIFTKICK) THEN
       X(2)=X(2)+YL*DIR*EL%BN(1)*(one+X(1)*EL%P%B0)
    ENDIF

    IF(EL%P%RADIATION) THEN
       B(1)=BY/(one+EL%P%B0*X(1))
       B(2)=-BX/(one+EL%P%B0*X(1))
       B(3)=zero
       CALL B2PERP(EL%P,B,X,X5,B2)
       X(5)=X(5)-CRADF(EL%P)*(one+X(5))**3*B2*YL/SQRT((one+X(5))**2-X(2)**2-X(4)**2)*(one+EL%P%B0*X(1))
       if(EL%P%TIME) then
          X(2)=X(2)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          X(4)=X(4)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
       else
          X(2)=X(2)*(one+X(5))/(one+X5)
          X(4)=X(4)*(one+X(5))/(one+X5)
       endif
    ENDIF

    CALL KILL(X1,X3,BX,BY,BTX,BTY,X5,B2,BtYT)
    CALL KILL(B,3)

  END SUBROUTINE SKICKP

  SUBROUTINE SKICKS(EL,YL,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(TEAPOTP),INTENT(IN):: EL
    TYPE(REAL_8) X1,X3,BX,BY,BTX,BTY,X5,B(3),B2,X(6),DENF,XR(6),BtYT
    TYPE(DAMAP) XP,ID,DISP,XT
    INTEGER J,M,A,K,I,DIR
    real(dp) B20,B30,BF, v(6)  !,R1,R2,DEN0
    logical(lp) done_stoch
    real(dp) :: tot=0.d0

    DIR=EL%P%DIR*EL%P%CHARGE

    CALL ALLOC(X1,X3,BX,BY,BTX,BTY,X5,B2,BtYT)
    CALL ALLOC(B,3)
    CALL ALLOC(X)
    CALL ALLOC(XP)
    CALL ALLOC(denf)
    CALL ALLOC(XR)
    CALL ALLOC(ID)
    CALL ALLOC(DISP)
    CALL ALLOC(XT)





    X=Y
    X1=X(1)
    X3=X(3)

    if(EL%P%TIME) then
       X5=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
    else
       X5=X(5)
    endif


    BX=zero
    BY=zero

    k=0
    m=SECTOR_NMUL-1
    !    m=EL%P%nmul-1
    do a=m,1,-1
       BTX=zero
       BTY=zero
       do j=m-a,1,-1
          k=k+1
          !b%i(k)=a
          !b%j(k)=j
          BTX= (BTX+EL%BF_X(k))*X3
          BTY= (BTY+EL%BF_Y(k))*X3
       enddo

       k=k+1
       !  b%i(k)=a
       !  b%j(k)=0
       BTX= (BTX+EL%BF_X(k))
       BTY= (BTY+EL%BF_Y(k))
       BX= (BX+BTX)*X1
       BY= (BY+BTY)*X1
    enddo
    BTX=zero
    BTY=zero
    do j=m,1,-1
       k=k+1
       !  b%i(k)=0
       !  b%j(k)=j
       BTX= (BTX+EL%BF_X(k))*X3
       BTY= (BTY+EL%BF_Y(k))*X3
    enddo
    k=k+1
    !    b%i(k)=0
    !    b%j(k)=0
    BX= BX+BTX+EL%BF_X(k)  !+X3
    BY= BY+BTY+EL%BF_Y(k)  !+X3

    ! etienne
    IF(EL%P%NMUL>SECTOR_NMUL) THEN
       BtY=EL%BN(EL%P%NMUL)
       BtX=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,SECTOR_NMUL+1,-1
          BtYT=X1*BtY-X3*BtX+EL%BN(J)
          BtX =X3*BtY+X1*BtX+EL%AN(J)
          BtY =BtYT
       ENDDO

       DO  J=SECTOR_NMUL, 1,-1
          BtYT=X1*BtY-X3*BtX
          BtX =X3*BtY+X1*BtX
          BtY =BtYT
       ENDDO

       BX= BX-BTX
       BY= BY+BTY

    ENDIF



    X(2)=X(2)+YL*DIR*BX
    X(4)=X(4)+YL*DIR*BY

    IF(.NOT.EL%DRIFTKICK) THEN
       X(2)=X(2)+YL*DIR*EL%BN(1)*(one+X(1)*EL%P%B0)
    ENDIF


    XP=X
    XR=X
    IF(EL%P%RADIATION) THEN
       XP%V(2)=X(2)/SQRT((one+x5)**2-X(2)**2-X(4)**2)
       XP%V(4)=X(4)/SQRT((one+x5)**2-X(2)**2-X(4)**2)
       B(1)=BY/(one+EL%P%B0*X(1))
       B(2)=-BX/(one+EL%P%B0*X(1))
       B(3)=zero
       CALL B2PERP(EL%P,B,X,X5,B2)
       X(5)=X(5)-CRADF(EL%P)*(one+X(5))**3*B2*YL/SQRT((one+X(5))**2-X(2)**2-X(4)**2)*(one+EL%P%B0*X(1))
       if(EL%P%TIME) then
          X(2)=X(2)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          X(4)=X(4)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
       else
          X(2)=X(2)*(one+X(5))/(one+X5)
          X(4)=X(4)*(one+X(5))/(one+X5)
       endif
    ENDIF



    done_stoch=.false.
    if(EL%P%B0==zero.and.stoch_in_rec) then

       denf=(one+xr(5))**5/SQRT((one+Xr(5))**2-Xr(2)**2-Xr(4)**2)*(one+EL%P%B0*Xr(1))
       b20=b2
       b30=b20**c_1_5
       bf=cflucf(el%p)*b30
       denf=denf*bf*yl
       done_stoch=.true.
    elseif(EL%P%B0/=zero)   then
       done_stoch=.true.
    endif

    if(done_stoch) then

       if(EL%P%B0/=zero) then
          !
          if(knob) then
             v=XR
             DISP=xp*id
             id=1
             DISP=ID-DISP
             XP=DISP*XP

             id=0
             XT=XR
             DISP=XT*ID
             ID=1
             DISP=ID-DISP
             XT=DISP*XT

             xr=xt+V
             CALL B2PERP(EL%P,B,Xr,X5,B2)
             denf=(one+xr(5))**5/SQRT((one+Xr(5))**2-Xr(2)**2-Xr(4)**2)*(one+EL%P%B0*Xr(1))
             denf=DENF*cflucf(el%p)*yl*b2**c_1_5
          else
             CALL B2PERP(EL%P,B,Xr,X5,B2)
             denf=(one+xr(5))**5/SQRT((one+Xr(5))**2-Xr(2)**2-Xr(4)**2)*(one+EL%P%B0*Xr(1))
             b20=b2
             b30=b20**c_1_5
             bf=cflucf(el%p)*b30
             denf=denf*bf*yl

          endif
       endif

       xp=xp**(-1)
       do i=1,6
          do j=1,6
             X1=(xp%v(i)).par.'000010'
             X3=(xp%v(j)).par.'000010'
             denf=denf.par.'000000'
             y(I)%E(J)=y(I)%E(J)+denf*x1*x3
          enddo
       enddo
    endif




    Y=X
    CALL KILL(X1,X3,BX,BY,BTX,BTY,X5,B2,BtYT)
    CALL KILL(B,3)
    CALL KILL(denf)
    CALL KILL(X)
    CALL KILL(XP)
    CALL KILL(XR)
    CALL KILL(ID)
    CALL KILL(DISP)
    CALL KILL(XT)

  END SUBROUTINE SKICKS

  SUBROUTINE SINTER(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(TEAPOT),INTENT(IN):: EL
    TYPE(WORM), OPTIONAL,INTENT(INOUT):: MID
    real(dp) D,DH,DD
    real(dp) D1,D2,DK1,DK2
    real(dp) DD1,DD2
    real(dp) DF(4),DK(4),DDF(4)
    INTEGER I,J

    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    SELECT CASE(EL%P%METHOD)
    CASE(2)
       DH=EL%L/two/EL%P%NST
       D=EL%L/EL%P%NST
       DD=EL%P%LD/two/EL%P%NST

       DO I=1,EL%P%NST
          CALL SSECH1(EL,DH,DD,X)
          CALL SKICK(EL,D,X)
          CALL SSECH1(EL,DH,DD,X)
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
    CASE(4)
       D1=EL%L*FD1/EL%P%NST
       D2=EL%L*FD2/EL%P%NST
       DD1=EL%P%LD*FD1/EL%P%NST
       DD2=EL%P%LD*FD2/EL%P%NST
       DK1=EL%L*FK1/EL%P%NST
       DK2=EL%L*FK2/EL%P%NST

       DO I=1,EL%P%NST
          CALL SSECH1(EL,D1,DD1,X)
          CALL SKICK (EL,DK1,X)
          CALL SSECH1(EL,D2,DD2,X)
          CALL SKICK (EL,DK2,X)

          CALL SSECH1(EL,D2,DD2,X)
          CALL SKICK (EL,DK1,X)
          CALL SSECH1(EL,D1,DD1,X)
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO

    CASE(6)
       DO I =1,4
          DF(I)=EL%L*YOSD(I)/EL%P%NST
          DDF(I)=EL%P%LD*YOSD(I)/EL%P%NST
          DK(I)=EL%L*YOSK(I)/EL%P%NST
       ENDDO

       DO I=1,EL%P%NST
          DO J=4,2,-1
             CALL SSECH1(EL,DF(J),DDF(J),X)
             CALL SKICK (EL,DK(J),X)
          ENDDO
          CALL SSECH1(EL,DF(1),DDF(1),X)
          CALL SKICK (EL,DK(1),X)

          CALL SSECH1(EL,DF(1),DDF(1),X)
          DO J=2,4
             CALL SKICK (EL,DK(J),X)
             CALL SSECH1(EL,DF(J),DDF(J),X)
          ENDDO
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO



    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

  END SUBROUTINE SINTER

  SUBROUTINE SINTEP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(TEAPOTP),INTENT(INOUT):: EL
    ! TYPE(WORM_8), OPTIONAL,INTENT(INOUT):: MID
    TYPE(REAL_8) D,DH
    real(dp) DD
    TYPE(REAL_8) D1,D2,DK1,DK2
    real(dp) DD1,DD2
    TYPE(REAL_8) DF(4),DK(4)
    real(dp) DDF(4)
    INTEGER I,J,error
    logical(lp) CHECK_KNOB
    logical(lp), ALLOCATABLE,dimension(:)::AN,BN

    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    IF(KNOB) THEN
       CALL CHECKPOTKNOB(EL,CHECK_KNOB) ! RECOMPUTES ONLY IF KNOB (SPEED)
       IF(CHECK_KNOB) THEN
          ALLOCATE(AN(EL%P%NMUL),BN(EL%P%NMUL))
          DO I=1,EL%P%NMUL
             BN(I)=.FALSE.
             AN(I)=.FALSE.
             IF(EL%BN(I)%KIND==3) BN(I)=.TRUE.
             IF(EL%AN(I)%KIND==3) AN(I)=.TRUE.
          ENDDO
          call GETANBN(EL)
       ENDIF
    ENDIF

    SELECT CASE(EL%P%METHOD)
    CASE(2)
       CALL ALLOC(DH)
       CALL ALLOC(D)
       DH=EL%L/two/EL%P%NST
       D=EL%L/EL%P%NST
       DD=EL%P%LD/two/EL%P%NST

       DO I=1,EL%P%NST
          CALL SSECH1(EL,DH,DD,X)
          CALL SKICK(EL,D,X)
          CALL SSECH1(EL,DH,DD,X)
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
       CALL KILL(DH)
       CALL KILL(D)
    CASE(4)
       CALL ALLOC(D1)
       CALL ALLOC(D2)
       CALL ALLOC(DK1)
       CALL ALLOC(DK2)
       D1=EL%L*FD1/EL%P%NST
       D2=EL%L*FD2/EL%P%NST
       DD1=EL%P%LD*FD1/EL%P%NST
       DD2=EL%P%LD*FD2/EL%P%NST
       DK1=EL%L*FK1/EL%P%NST
       DK2=EL%L*FK2/EL%P%NST

       DO I=1,EL%P%NST
          CALL SSECH1(EL,D1,DD1,X)
          CALL SKICK (EL,DK1,X)
          CALL SSECH1(EL,D2,DD2,X)
          CALL SKICK (EL,DK2,X)
          CALL SSECH1(EL,D2,DD2,X)
          CALL SKICK (EL,DK1,X)
          CALL SSECH1(EL,D1,DD1,X)
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
       CALL KILL(D1)
       CALL KILL(D2)
       CALL KILL(DK1)
       CALL KILL(DK2)
    CASE(6)
       CALL ALLOC(DF,4)
       CALL ALLOC(DK,4)
       DO I =1,4
          DF(I)=EL%L*YOSD(I)/EL%P%NST
          DDF(I)=EL%P%LD*YOSD(I)/EL%P%NST
          DK(I)=EL%L*YOSK(I)/EL%P%NST
       ENDDO

       DO I=1,EL%P%NST
          DO J=4,2,-1
             CALL SSECH1(EL,DF(J),DDF(J),X)
             CALL SKICK (EL,DK(J),X)
          ENDDO
          CALL SSECH1(EL,DF(1),DDF(1),X)
          CALL SKICK (EL,DK(1),X)
          CALL SSECH1(EL,DF(1),DDF(1),X)
          DO J=2,4
             CALL SKICK (EL,DK(J),X)
             CALL SSECH1(EL,DF(J),DDF(J),X)
          ENDDO
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
       CALL KILL(DF,4)
       CALL KILL(DK,4)

    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

    IF(KNOB) THEN
       IF(CHECK_KNOB) THEN
          DO I=1,EL%P%NMUL
             EL%BN(I)%KIND=1
             EL%AN(I)%KIND=1
          ENDDO
          CALL KILL(EL)                               ! RECOMPUTES ONLY IF KNOB (SPEED)
          CALL ALLOC(EL)
          CALL GETANBN(EL)                            ! KNOB IS REMOVED THE SLOW WAY(SPEED)
          DO I=1,EL%P%NMUL
             IF(AN(I)) EL%AN(I)%KIND=3
             IF(BN(I)) EL%BN(I)%KIND=3
          ENDDO
          DEALLOCATE (AN, STAT = error)
          IF(ERROR/=0) THEN
             w_p=0
             w_p%nc=1
             w_p%fc='(1(1X,A72))'
             w_p%c(1)= " AN ARRAY not DEALLOCATED : PROBLEMS"
             call write_e(357)
          ENDIF
          DEALLOCATE (BN, STAT = error)
          IF(ERROR/=0) THEN
             w_p=0
             w_p%nc=1
             w_p%fc='(1(1X,A72))'
             w_p%c(1)= " BN ARRAY not DEALLOCATED : PROBLEMS"
             call write_e(357)
          ENDIF
       ENDIF
    ENDIF




  END SUBROUTINE SINTEP

  SUBROUTINE SINTES(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(TEAPOTP),INTENT(INOUT):: EL
    TYPE(REAL_8) D,DH
    real(dp) DD
    TYPE(REAL_8) D1,D2,DK1,DK2
    real(dp) DD1,DD2
    TYPE(REAL_8) DF(4),DK(4)
    real(dp) DDF(4)
    INTEGER I,J,error
    logical(lp) CHECK_KNOB
    logical(lp), ALLOCATABLE,dimension(:)::AN,BN

    IF(KNOB) THEN
       CALL CHECKPOTKNOB(EL,CHECK_KNOB) ! RECOMPUTES ONLY IF KNOB (SPEED)
       IF(CHECK_KNOB) THEN
          ALLOCATE(AN(EL%P%NMUL),BN(EL%P%NMUL))
          DO I=1,EL%P%NMUL
             BN(I)=.FALSE.
             AN(I)=.FALSE.
             IF(EL%BN(I)%KIND==3) BN(I)=.TRUE.
             IF(EL%AN(I)%KIND==3) AN(I)=.TRUE.
          ENDDO
          call GETANBN(EL)
       ENDIF
    ENDIF


    SELECT CASE(EL%P%METHOD)
    CASE(2)
       CALL ALLOC(DH)
       CALL ALLOC(D)
       DH=EL%L/two/EL%P%NST
       D=EL%L/EL%P%NST
       DD=EL%P%LD/two/EL%P%NST

       DO I=1,EL%P%NST
          CALL SSECH1(EL,DH,DD,X)
          CALL SKICK(EL,D,X)
          CALL SSECH1(EL,DH,DD,X)
       ENDDO
       CALL KILL(DH)
       CALL KILL(D)
    CASE(4)
       CALL ALLOC(D1)
       CALL ALLOC(D2)
       CALL ALLOC(DK1)
       CALL ALLOC(DK2)
       D1=EL%L*FD1/EL%P%NST
       D2=EL%L*FD2/EL%P%NST
       DD1=EL%P%LD*FD1/EL%P%NST
       DD2=EL%P%LD*FD2/EL%P%NST
       DK1=EL%L*FK1/EL%P%NST
       DK2=EL%L*FK2/EL%P%NST

       DO I=1,EL%P%NST
          CALL SSECH1(EL,D1,DD1,X)
          CALL SKICK (EL,DK1,X)
          CALL SSECH1(EL,D2,DD2,X)
          CALL SKICK (EL,DK2,X)
          CALL SSECH1(EL,D2,DD2,X)
          CALL SKICK (EL,DK1,X)
          CALL SSECH1(EL,D1,DD1,X)
       ENDDO
       CALL KILL(D1)
       CALL KILL(D2)
       CALL KILL(DK1)
       CALL KILL(DK2)
    CASE(6)
       CALL ALLOC(DF,4)
       CALL ALLOC(DK,4)
       DO I =1,4
          DF(I)=EL%L*YOSD(I)/EL%P%NST
          DDF(I)=EL%P%LD*YOSD(I)/EL%P%NST
          DK(I)=EL%L*YOSK(I)/EL%P%NST
       ENDDO

       DO I=1,EL%P%NST
          DO J=4,2,-1
             CALL SSECH1(EL,DF(J),DDF(J),X)
             CALL SKICK (EL,DK(J),X)
          ENDDO
          CALL SSECH1(EL,DF(1),DDF(1),X)
          CALL SKICK (EL,DK(1),X)
          CALL SSECH1(EL,DF(1),DDF(1),X)
          DO J=2,4
             CALL SKICK (EL,DK(J),X)
             CALL SSECH1(EL,DF(J),DDF(J),X)
          ENDDO
       ENDDO
       CALL KILL(DF,4)
       CALL KILL(DK,4)


    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

    IF(KNOB) THEN
       IF(CHECK_KNOB) THEN
          DO I=1,EL%P%NMUL
             EL%BN(I)%KIND=1
             EL%AN(I)%KIND=1
          ENDDO
          CALL KILL(EL)                               ! RECOMPUTES ONLY IF KNOB (SPEED)
          CALL ALLOC(EL)
          CALL GETANBN(EL)                            ! KNOB IS REMOVED THE SLOW WAY(SPEED)
          DO I=1,EL%P%NMUL
             IF(AN(I)) EL%AN(I)%KIND=3
             IF(BN(I)) EL%BN(I)%KIND=3
          ENDDO
          DEALLOCATE (AN, STAT = error)
          IF(ERROR/=0) THEN
             w_p=0
             w_p%nc=1
             w_p%fc='(1(1X,A72))'
             w_p%c(1)= " AN ARRAY not DEALLOCATED : PROBLEMS"
             call write_e(357)
          ENDIF
          DEALLOCATE (BN, STAT = error)
          IF(ERROR/=0) THEN
             w_p=0
             w_p%nc=1
             w_p%fc='(1(1X,A72))'
             w_p%c(1)= " BN ARRAY not DEALLOCATED : PROBLEMS"
             call write_e(357)
          ENDIF
       ENDIF
    ENDIF


  END SUBROUTINE SINTES


  SUBROUTINE CHECKPOTKNOB(EL,CHECK_KNOB)
    IMPLICIT NONE
    TYPE(TEAPOTP),INTENT(IN):: EL
    logical(lp) CHECK_KNOB
    integer I

    CHECK_KNOB=.FALSE.
    I=1
    DO WHILE(I<=EL%P%NMUL.AND.(.NOT.CHECK_KNOB))
       IF(EL%BN(I)%KIND==3) CHECK_KNOB=.TRUE.
       IF(EL%AN(I)%KIND==3) CHECK_KNOB=.TRUE.
       I=I+1
    ENDDO
    IF(EL%L%KIND==3) CHECK_KNOB=.TRUE.

  END SUBROUTINE CHECKPOTKNOB


  SUBROUTINE SSYMPINTR(EL,X,MID)
    IMPLICIT NONE
    logical(lp) :: doneitt=.true.
    real(dp),INTENT(INOUT):: X(6)
    TYPE(TEAPOT),INTENT(IN):: EL
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: MID

    IF(EL%P%DIR==1) THEN
       IF(EL%P%EDGE(1)/=zero) THEN
          CALL ROT_XZ(EL%P%EDGE(1),X,EL%P%BETA0,DONEITT,EL%P%TIME)
          CALL FACE(EL%P,EL%BN,EL%H1,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          IF(EL%P%FRINGE) then
             CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
             x(2)=x(2)+EL%P%EDGE(1)*el%bn(2)*(wedge_coeff(1)*x(1)**2-wedge_coeff(2)*x(3)**2*half)
             x(4)=x(4)-EL%P%EDGE(1)*el%bn(2)*(wedge_coeff(2)*x(1)*x(3))
          ELSEIF(MAD8_WEDGE) THEN
             x(2)=x(2)+EL%P%EDGE(1)*el%bn(2)*(x(1)**2-x(3)**2)
             x(4)=x(4)-EL%P%EDGE(1)*el%bn(2)*(TWO*x(1)*x(3))
          endif
          CALL WEDGE(-EL%P%EDGE(1),X,EL2=EL)
       ELSE
          CALL FACE(EL%P,EL%BN,EL%H1,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       ENDIF

       CALL SINTE(EL,X,MID)

       IF(EL%P%EDGE(2)/=zero) THEN
          CALL WEDGE(-EL%P%EDGE(2),X,EL2=EL)
          IF(EL%P%FRINGE) then
             x(2)=x(2)+EL%P%EDGE(2)*el%bn(2)*(wedge_coeff(1)*x(1)**2-wedge_coeff(2)*x(3)**2*half)
             x(4)=x(4)-EL%P%EDGE(2)*el%bn(2)*(wedge_coeff(2)*x(1)*x(3))
             CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
          ELSEIF(MAD8_WEDGE) THEN
             x(2)=x(2)+EL%P%EDGE(2)*el%bn(2)*(x(1)**2-x(3)**2)
             x(4)=x(4)-EL%P%EDGE(2)*el%bn(2)*(TWO*x(1)*x(3))
          endif
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          CALL FACE(EL%P,EL%BN,EL%H2,X)
          CALL ROT_XZ(EL%P%EDGE(2),X,EL%P%BETA0,DONEITT,EL%P%TIME)
       ELSE
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          CALL FACE(EL%P,EL%BN,EL%H2,X)
       ENDIF

    ELSE


       IF(EL%P%EDGE(2)/=zero) THEN
          CALL ROT_XZ(EL%P%EDGE(2),X,EL%P%BETA0,DONEITT,EL%P%TIME)
          CALL FACE(EL%P,EL%BN,EL%H2,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          IF(EL%P%FRINGE) then
             CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
             x(2)=x(2)-EL%P%EDGE(2)*el%bn(2)*(wedge_coeff(1)*x(1)**2-wedge_coeff(2)*x(3)**2*half)
             x(4)=x(4)+EL%P%EDGE(2)*el%bn(2)*(wedge_coeff(2)*x(1)*x(3))
          ELSEIF(MAD8_WEDGE) THEN
             x(2)=x(2)-EL%P%EDGE(2)*el%bn(2)*(x(1)**2-x(3)**2)
             x(4)=x(4)+EL%P%EDGE(2)*el%bn(2)*(TWO*x(1)*x(3))
          endif
          CALL WEDGE(-EL%P%EDGE(2),X,EL2=EL)
       ELSE
          CALL FACE(EL%P,EL%BN,EL%H2,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       ENDIF

       CALL SINTE(EL,X,MID)

       IF(EL%P%EDGE(1)/=zero) THEN
          CALL WEDGE(-EL%P%EDGE(1),X,EL2=EL)
          IF(EL%P%FRINGE) then
             x(2)=x(2)-EL%P%EDGE(1)*el%bn(2)*(wedge_coeff(1)*x(1)**2-wedge_coeff(2)*x(3)**2*half)
             x(4)=x(4)+EL%P%EDGE(1)*el%bn(2)*(wedge_coeff(2)*x(1)*x(3))
             CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
          ELSEIF(MAD8_WEDGE) THEN
             x(2)=x(2)-EL%P%EDGE(1)*el%bn(2)*(x(1)**2-x(3)**2)
             x(4)=x(4)+EL%P%EDGE(1)*el%bn(2)*(TWO*x(1)*x(3))
          endif
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          CALL FACE(EL%P,EL%BN,EL%H1,X)
          CALL ROT_XZ(EL%P%EDGE(1),X,EL%P%BETA0,DONEITT,EL%P%TIME)
       ELSE
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          CALL FACE(EL%P,EL%BN,EL%H1,X)
       ENDIF


    ENDIF


  END SUBROUTINE SSYMPINTR

  SUBROUTINE SSYMPINTP(EL,X)
    IMPLICIT NONE
    logical(lp) :: doneitt=.true.
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(TEAPOTP),INTENT(INOUT):: EL
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: MID


    IF(EL%P%DIR==1) THEN

       IF(EL%P%EDGE(1)/=zero) THEN
          CALL ROT_XZ(EL%P%EDGE(1),X,EL%P%BETA0,DONEITT,EL%P%TIME)
          CALL FACE(EL%P,EL%BN,EL%H1,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          IF(EL%P%FRINGE) then
             CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
             x(2)=x(2)+EL%P%EDGE(1)*el%bn(2)*(wedge_coeff(1)*x(1)**2-wedge_coeff(2)*x(3)**2*half)
             x(4)=x(4)-EL%P%EDGE(1)*el%bn(2)*(wedge_coeff(2)*x(1)*x(3))
          ELSEIF(MAD8_WEDGE) THEN
             x(2)=x(2)+EL%P%EDGE(1)*el%bn(2)*(x(1)**2-x(3)**2)
             x(4)=x(4)-EL%P%EDGE(1)*el%bn(2)*(TWO*x(1)*x(3))
          endif
          CALL WEDGE(-EL%P%EDGE(1),X,EL2=EL)
       ELSE
          CALL FACE(EL%P,EL%BN,EL%H1,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       ENDIF

       CALL SINTE(EL,X)

       IF(EL%P%EDGE(2)/=zero) THEN
          CALL WEDGE(-EL%P%EDGE(2),X,EL2=EL)
          IF(EL%P%FRINGE) then
             x(2)=x(2)+EL%P%EDGE(2)*el%bn(2)*(wedge_coeff(1)*x(1)**2-wedge_coeff(2)*x(3)**2*half)
             x(4)=x(4)-EL%P%EDGE(2)*el%bn(2)*(wedge_coeff(2)*x(1)*x(3))
             CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
          ELSEIF(MAD8_WEDGE) THEN
             x(2)=x(2)+EL%P%EDGE(2)*el%bn(2)*(x(1)**2-x(3)**2)
             x(4)=x(4)-EL%P%EDGE(2)*el%bn(2)*(TWO*x(1)*x(3))
          endif
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          CALL FACE(EL%P,EL%BN,EL%H2,X)
          CALL ROT_XZ(EL%P%EDGE(2),X,EL%P%BETA0,DONEITT,EL%P%TIME)
       ELSE
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          CALL FACE(EL%P,EL%BN,EL%H2,X)
       ENDIF

    ELSE


       IF(EL%P%EDGE(2)/=zero) THEN
          CALL ROT_XZ(EL%P%EDGE(2),X,EL%P%BETA0,DONEITT,EL%P%TIME)
          CALL FACE(EL%P,EL%BN,EL%H2,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          IF(EL%P%FRINGE) then
             CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
             x(2)=x(2)-EL%P%EDGE(2)*el%bn(2)*(wedge_coeff(1)*x(1)**2-wedge_coeff(2)*x(3)**2*half)
             x(4)=x(4)+EL%P%EDGE(2)*el%bn(2)*(wedge_coeff(2)*x(1)*x(3))
          ELSEIF(MAD8_WEDGE) THEN
             x(2)=x(2)-EL%P%EDGE(2)*el%bn(2)*(x(1)**2-x(3)**2)
             x(4)=x(4)+EL%P%EDGE(2)*el%bn(2)*(TWO*x(1)*x(3))
          endif
          CALL WEDGE(-EL%P%EDGE(2),X,EL2=EL)
       ELSE
          CALL FACE(EL%P,EL%BN,EL%H2,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       ENDIF

       CALL SINTE(EL,X)

       IF(EL%P%EDGE(1)/=zero) THEN
          CALL WEDGE(-EL%P%EDGE(1),X,EL2=EL)
          IF(EL%P%FRINGE) then
             x(2)=x(2)-EL%P%EDGE(1)*el%bn(2)*(wedge_coeff(1)*x(1)**2-wedge_coeff(2)*x(3)**2*half)
             x(4)=x(4)+EL%P%EDGE(1)*el%bn(2)*(wedge_coeff(2)*x(1)*x(3))
             CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
          ELSEIF(MAD8_WEDGE) THEN
             x(2)=x(2)-EL%P%EDGE(1)*el%bn(2)*(x(1)**2-x(3)**2)
             x(4)=x(4)+EL%P%EDGE(1)*el%bn(2)*(TWO*x(1)*x(3))
          endif
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          CALL FACE(EL%P,EL%BN,EL%H1,X)
          CALL ROT_XZ(EL%P%EDGE(1),X,EL%P%BETA0,DONEITT,EL%P%TIME)
       ELSE
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          CALL FACE(EL%P,EL%BN,EL%H1,X)
       ENDIF


    ENDIF

  END SUBROUTINE SSYMPINTP

  SUBROUTINE SSYMPINTS(EL,X)
    IMPLICIT NONE
    logical(lp) :: doneitt=.true.
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(TEAPOTP),INTENT(INOUT):: EL
    TYPE(real_8)  XR(6)

    CALL ALLOC(XR)

    IF(EL%P%DIR==1) THEN

       IF(EL%P%EDGE(1)/=zero) THEN
          CALL ROT_XZ(EL%P%EDGE(1),X,EL%P%BETA0,DONEITT,EL%P%TIME)
          CALL FACE(EL%P,EL%BN,EL%H1,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          IF(EL%P%FRINGE) then
             CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
             XR=X
             XR(2)=XR(2)+EL%P%EDGE(1)*el%bn(2)*(wedge_coeff(1)*XR(1)**2-wedge_coeff(2)*XR(3)**2*half)
             XR(4)=XR(4)-EL%P%EDGE(1)*el%bn(2)*(wedge_coeff(2)*XR(1)*XR(3))
             X=XR
          ELSEIF(MAD8_WEDGE) THEN
             XR=X
             XR(2)=XR(2)+EL%P%EDGE(1)*el%bn(2)*(XR(1)**2-XR(3)**2)
             XR(4)=XR(4)-EL%P%EDGE(1)*el%bn(2)*(TWO*XR(1)*XR(3))
             X=XR
          endif
          CALL WEDGE(-EL%P%EDGE(1),X,EL2=EL)
       ELSE
          CALL FACE(EL%P,EL%BN,EL%H1,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          IF(EL%P%FRINGE)  CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       ENDIF

       CALL SINTE(EL,X)

       IF(EL%P%EDGE(2)/=zero) THEN
          CALL WEDGE(-EL%P%EDGE(2),X,EL2=EL)
          IF(EL%P%FRINGE) then
             XR=X
             XR(2)=XR(2)+EL%P%EDGE(2)*el%bn(2)*(wedge_coeff(1)*XR(1)**2-wedge_coeff(2)*XR(3)**2*half)
             XR(4)=XR(4)-EL%P%EDGE(2)*el%bn(2)*(wedge_coeff(2)*XR(1)*XR(3))
             CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
             X=XR
          ELSEIF(MAD8_WEDGE) THEN
             XR=X
             XR(2)=XR(2)+EL%P%EDGE(2)*el%bn(2)*(XR(1)**2-XR(3)**2)
             XR(4)=XR(4)-EL%P%EDGE(2)*el%bn(2)*(TWO*XR(1)*XR(3))
             X=XR
          endif
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          CALL FACE(EL%P,EL%BN,EL%H2,X)
          CALL ROT_XZ(EL%P%EDGE(2),X,EL%P%BETA0,DONEITT,EL%P%TIME)
       ELSE
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          CALL FACE(EL%P,EL%BN,EL%H2,X)
       ENDIF

    ELSE


       IF(EL%P%EDGE(2)/=zero) THEN
          CALL ROT_XZ(EL%P%EDGE(2),X,EL%P%BETA0,DONEITT,EL%P%TIME)
          CALL FACE(EL%P,EL%BN,EL%H2,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          IF(EL%P%FRINGE) then
             CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
             XR=X
             XR(2)=XR(2)-EL%P%EDGE(2)*el%bn(2)*(wedge_coeff(1)*XR(1)**2-wedge_coeff(2)*XR(3)**2*half)
             XR(4)=XR(4)+EL%P%EDGE(2)*el%bn(2)*(wedge_coeff(2)*XR(1)*XR(3))
             X=XR
          ELSEIF(MAD8_WEDGE) THEN
             XR=X
             XR(2)=XR(2)-EL%P%EDGE(2)*el%bn(2)*(XR(1)**2-XR(3)**2)
             XR(4)=XR(4)+EL%P%EDGE(2)*el%bn(2)*(TWO*XR(1)*XR(3))
             X=XR
          endif
          CALL WEDGE(-EL%P%EDGE(2),X,EL2=EL)
       ELSE
          CALL FACE(EL%P,EL%BN,EL%H2,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       ENDIF

       CALL SINTE(EL,X)

       IF(EL%P%EDGE(1)/=zero) THEN
          CALL WEDGE(-EL%P%EDGE(1),X,EL2=EL)
          IF(EL%P%FRINGE) then
             XR=X
             XR(2)=XR(2)-EL%P%EDGE(1)*el%bn(2)*(wedge_coeff(1)*XR(1)**2-wedge_coeff(2)*XR(3)**2*half)
             XR(4)=XR(4)+EL%P%EDGE(1)*el%bn(2)*(wedge_coeff(2)*XR(1)*XR(3))
             X=XR
             CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
          ELSEIF(MAD8_WEDGE) THEN
             XR=X
             XR(2)=XR(2)-EL%P%EDGE(1)*el%bn(2)*(XR(1)**2-XR(3)**2)
             XR(4)=XR(4)+EL%P%EDGE(1)*el%bn(2)*(TWO*XR(1)*XR(3))
             X=XR
          endif
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          CALL FACE(EL%P,EL%BN,EL%H1,X)
          CALL ROT_XZ(EL%P%EDGE(1),X,EL%P%BETA0,DONEITT,EL%P%TIME)
       ELSE
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          CALL FACE(EL%P,EL%BN,EL%H1,X)
       ENDIF


    ENDIF

    CALL KILL(XR)

  END SUBROUTINE SSYMPINTS

  !  monitor stuff

  SUBROUTINE MARTINR(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM), OPTIONAL,INTENT(INOUT):: MID
    TYPE(MARTIN),INTENT(INOUT):: EL
    real(dp) L0,BETA

    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    L0=X(6)

    if(EL%P%TIME.and.EL%DELTAMAP) then
       X(5)=(TWO*X(5)/EL%P%BETA0+X(5)**2)/(SQRT(ONE+TWO*X(5)/ EL%P%BETA0+X(5)**2  )+ONE)
    endif

    IF(EL%P%RADIATION) THEN
       IF(EL%P%DIR==1) THEN
          IF(ASSOCIATED(EL%T_RAD)) THEN
             CALL TRACK(EL%T_RAD,X,EL%P%NST)
          ELSE
             WRITE(6,*) " No forward radiating Taylor map provided "
             stop 996
          ENDIF
       ELSE
          IF(ASSOCIATED(EL%T_RAD_REV)) THEN
             CALL TRACK(EL%T_RAD_REV,X,EL%P%NST)
          ELSE
             WRITE(6,*) " No reverse radiating Taylor map provided "
             stop 998
          ENDIF
       ENDIF
    ELSE
       IF(EL%P%DIR==1) THEN
          IF(ASSOCIATED(EL%T)) THEN
             CALL TRACK(EL%T,X,EL%P%NST)
          ELSE
             WRITE(6,*) " No forward Taylor map provided "
             stop 997
          ENDIF
       ELSE
          IF(ASSOCIATED(EL%T_REV)) THEN
             CALL TRACK(EL%T_REV,X,EL%P%NST)
          ELSE
             WRITE(6,*) " No reverse Taylor map provided "
             stop 999
          ENDIF
       ENDIF
    ENDIF

    if(EL%P%TIME) then
       IF(EL%DELTAMAP) THEN
          X(5)=(TWO*X(5)+X(5)**2)/(SQRT(ONE/EL%P%BETA0**2+TWO*X(5)+X(5)**2  )+ONE/EL%P%BETA0)
          BETA=SQRT(ONE+TWO*X(5)/EL%P%BETA0+X(5)**2  )/(one/EL%P%BETA0+x(5))
          X(6)=(X(6)-L0)/beta+ EL%P%LD*(ONE/BETA-(1-EL%P%TOTALPATH)*ONE/EL%P%BETA0)+L0
       ELSE
          X(6)=X(6)+(EL%P%LD*EL%P%TOTALPATH)/EL%P%BETA0
       ENDIF
    ELSE
       X(6)=X(6)+EL%P%TOTALPATH*EL%P%LD
    endif


    IF(PRESENT(MID)) CALL XMID(MID,X,1)

  END SUBROUTINE MARTINR

  SUBROUTINE MARTINP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    ! TYPE(WORM_8), OPTIONAL,INTENT(INOUT):: MID
    TYPE(MARTIN),INTENT(INOUT):: EL
    TYPE(REAL_8) L0,BETA

    CALL ALLOC(L0,BETA)
    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)
    L0=X(6)

    if(EL%P%TIME.and.EL%DELTAMAP) then
       X(5)=(TWO*X(5)/EL%P%BETA0+X(5)**2)/(SQRT(ONE+TWO*X(5)/ EL%P%BETA0+X(5)**2  )+ONE)
    endif

    IF(EL%P%RADIATION) THEN
       IF(EL%P%DIR==1) THEN
          IF(ASSOCIATED(EL%T_RAD)) THEN
             CALL TRACK(EL%T_RAD,X,EL%P%NST)
          ELSE
             WRITE(6,*) " No forward radiating Taylor map provided "
             stop 996
          ENDIF
       ELSE
          IF(ASSOCIATED(EL%T_RAD_REV)) THEN
             CALL TRACK(EL%T_RAD_REV,X,EL%P%NST)
          ELSE
             WRITE(6,*) " No reverse radiating Taylor map provided "
             stop 998
          ENDIF
       ENDIF
    ELSE
       IF(EL%P%DIR==1) THEN
          IF(ASSOCIATED(EL%T)) THEN
             CALL TRACK(EL%T,X,EL%P%NST)
          ELSE
             WRITE(6,*) " No forward Taylor map provided "
             stop 997
          ENDIF
       ELSE
          IF(ASSOCIATED(EL%T_REV)) THEN
             CALL TRACK(EL%T_REV,X,EL%P%NST)
          ELSE
             WRITE(6,*) " No reverse Taylor map provided "
             stop 999
          ENDIF
       ENDIF
    ENDIF

    !    WRITE(6,*) " EL%P%TIME , EL%DELTAMAP,EL%P%LD ",EL%P%TIME , EL%DELTAMAP ,EL%P%LD
    if(EL%P%TIME) then
       IF(EL%DELTAMAP) THEN
          X(5)=(TWO*X(5)+X(5)**2)/(SQRT(ONE/EL%P%BETA0**2+TWO*X(5)+X(5)**2  )+ONE/EL%P%BETA0)
          BETA=SQRT(ONE+TWO*X(5)/EL%P%BETA0+X(5)**2  )/(one/EL%P%BETA0+x(5))
          X(6)=(X(6)-L0)/beta+ EL%P%LD*(ONE/BETA-(1-EL%P%TOTALPATH)*ONE/EL%P%BETA0)+L0
       ELSE
          X(6)=X(6)+(EL%P%LD*EL%P%TOTALPATH)/EL%P%BETA0
       ENDIF
    ELSE
       X(6)=X(6)+EL%P%TOTALPATH*EL%P%LD
    endif

    !    IF(PRESENT(MID)) CALL XMID(MID,X,1)

    CALL KILL(L0,BETA)

  END SUBROUTINE MARTINP

  SUBROUTINE MARTINS(EL,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(MARTIN),INTENT(INOUT):: EL
    TYPE(REAL_8) X(6)
    INTEGER I,J

    CALL ALLOC(X)
    X=Y

    CALL TRACK(EL,X)

    Y=X

    IF(EL%P%DIR==1) THEN
       do i=1,6
          do j=1,6
             y(I)%E(J)=y(I)%E(J)+EL%E(I,J)
          enddo
       enddo
    ELSE
       do i=1,6
          do j=1,6
             y(I)%E(J)=y(I)%E(J)+EL%E_REV(I,J)
          enddo
       enddo
    ENDIF


    CALL KILL(X)

  END SUBROUTINE MARTINS

  SUBROUTINE MONTR(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM), OPTIONAL,INTENT(INOUT):: MID
    TYPE(mon),INTENT(INOUT):: EL
    INTEGER I

    IF(PRESENT(MID)) CALL XMID(MID,X,0)
    DO I=1,EL%P%NST
       CALL MONTI(EL,X,I,MID)
    ENDDO
    !    IF(PRESENT(MID)) CALL XMID(MID,X,2)

  END SUBROUTINE MONTR




  SUBROUTINE MONTP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    ! TYPE(WORM_8), OPTIONAL,INTENT(INOUT):: MID
    TYPE(monP),INTENT(INOUT):: EL
    INTEGER I

    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)
    DO I=1,EL%P%NST
       CALL MONTI(EL,X,I)
    ENDDO
    !    IF(PRESENT(MID)) CALL XMID(MID,X,2)


  END SUBROUTINE MONTP


  SUBROUTINE MONTS(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(monP),INTENT(INOUT):: EL
    TYPE(REAL_8) DH

    INTEGER I

    DO I=1,EL%P%NST
       CALL MONTI(EL,X,I)
    ENDDO

  END SUBROUTINE MONTS

  SUBROUTINE MONTIR(EL,X,I,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM), OPTIONAL,INTENT(INOUT):: MID
    TYPE(mon),INTENT(INOUT):: EL
    INTEGER, INTENT(IN) :: I
    real(dp) DH,DD

    DH=EL%L/two/el%p%nst
    DD=EL%P%LD/two/el%p%nst

    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    if(mod(el%p%nst,2)==1) then
       if(i==(el%p%nst+1)/2) THEN
          EL%X=X(1);EL%Y=X(3);
       ENDIF
    endif
    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    if(mod(el%p%nst,2)==0) then
       if(i==el%p%nst/2) THEN
          EL%X=X(1);EL%Y=X(3);
       ENDIF
    ENDIF
    IF(PRESENT(MID))  CALL XMID(MID,X,i)

  END SUBROUTINE MONTIR


  SUBROUTINE MONTIP(EL,X,I)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    ! TYPE(WORM_8), OPTIONAL,INTENT(INOUT):: MID
    TYPE(monP),INTENT(INOUT):: EL
    real(dp) DD
    TYPE(REAL_8) DH
    INTEGER, INTENT(IN) :: I


    CALL ALLOC(DH)

    DH=EL%L/two/el%p%nst
    DD=EL%P%LD/two/el%p%nst

    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    if(mod(el%p%nst,2)==1) then
       if(i==(el%p%nst+1)/2) THEN
          EL%X=X(1);EL%Y=X(3);
       ENDIF
    endif
    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    if(mod(el%p%nst,2)==0) then
       if(i==el%p%nst/2) THEN
          EL%X=X(1);EL%Y=X(3);
       ENDIF
    endif
    !       IF(PRESENT(MID)) CALL XMID(MID,X,i)

    CALL KILL(DH)

  END SUBROUTINE MONTIP

  SUBROUTINE MONTIS(EL,X,I)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(monP),INTENT(INOUT):: EL
    real(dp) DD
    TYPE(REAL_8) DH
    INTEGER, INTENT(IN) :: I

    CALL ALLOC(DH)

    DH=EL%L/two/el%p%nst
    DD=EL%P%LD/two/el%p%nst

    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    if(mod(el%p%nst,2)==1) then
       if(i==(el%p%nst+1)/2) THEN
          EL%X=X(1)%V;EL%Y=X(3)%V;
       ENDIF
    endif
    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    if(mod(el%p%nst,2)==0) then
       if(i==el%p%nst/2) THEN
          EL%X=X(1)%V;EL%Y=X(3)%V;
       ENDIF
    endif

    CALL KILL(DH)


  END SUBROUTINE MONTIS
  !  RCOLLIMATOR STUFF

  SUBROUTINE RCOLLIMATORR(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM), OPTIONAL,INTENT(INOUT):: MID
    TYPE(RCOL),INTENT(INOUT):: EL
    INTEGER I

    IF(PRESENT(MID)) CALL XMID(MID,X,0)
    DO I=1,EL%P%NST
       CALL RCOLLIMATORi(EL,X,i,MID)
    ENDDO
    !    IF(PRESENT(MID)) CALL XMID(MID,X,2)

  END SUBROUTINE RCOLLIMATORR

  SUBROUTINE RCOLLIMATORP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    ! TYPE(WORM_8), OPTIONAL,INTENT(INOUT):: MID
    TYPE(RCOLP),INTENT(INOUT):: EL

    INTEGER I

    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)
    DO I=1,EL%P%NST
       CALL RCOLLIMATORi(EL,X,i)
    ENDDO
    !    IF(PRESENT(MID)) CALL XMID(MID,X,2)

  END SUBROUTINE RCOLLIMATORP

  SUBROUTINE RCOLLIMATORS(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(RCOLP),INTENT(INOUT):: EL

    INTEGER I

    DO I=1,EL%P%NST
       CALL RCOLLIMATORi(EL,X,i)
    ENDDO


  END SUBROUTINE RCOLLIMATORS



  SUBROUTINE RCOLLIMATORiR(EL,X,i,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM), OPTIONAL,INTENT(INOUT):: MID
    TYPE(RCOL),INTENT(INOUT):: EL
    real(dp) DH,DD
    logical(lp) aper
    integer, intent(in) :: i

    DH=EL%L/two/el%p%nst
    DD=EL%P%LD/two/el%p%nst

    aper=APERTURE_FLAG
    APERTURE_FLAG=.true.

    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    if(mod(el%p%nst,2)==1) then
       !       IF(PRESENT(MID)) THEN
       !          if(i==(el%p%nst+1)/2)  CALL XMID(MID,X,1)
       !       ENDIF
    endif
    CALL CHECK_APERTURE(EL%A,X)

    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    if(mod(el%p%nst,2)==0) then
       !       IF(PRESENT(MID)) THEN
       !          if(i==el%p%nst/2)  CALL XMID(MID,X,1)
       !       ENDIF
    endif

    IF(PRESENT(MID)) CALL XMID(MID,X,I)

    APERTURE_FLAG=aper

  END SUBROUTINE RCOLLIMATORiR

  SUBROUTINE RCOLLIMATORiP(EL,X,i)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    ! TYPE(WORM_8), OPTIONAL,INTENT(INOUT):: MID
    TYPE(RCOLP),INTENT(INOUT):: EL
    real(dp) DD
    TYPE(REAL_8) DH
    logical(lp) aper
    integer, intent(in) :: i

    CALL ALLOC(DH)
    DH=EL%L/two/el%p%nst
    DD=EL%P%LD/two/el%p%nst

    aper=APERTURE_FLAG
    APERTURE_FLAG=.true.

    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    if(mod(el%p%nst,2)==1) then
       !       IF(PRESENT(MID)) THEN
       !          if(i==(el%p%nst+1)/2)  CALL XMID(MID,X,1)
       !       ENDIF
    endif
    CALL CHECK_APERTURE(EL%A,X)

    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    if(mod(el%p%nst,2)==0) then
       !       IF(PRESENT(MID)) THEN
       !          if(i==el%p%nst/2)  CALL XMID(MID,X,1)
       !       ENDIF
    endif

    !IF(PRESENT(MID)) CALL XMID(MID,X,I)

    APERTURE_FLAG=aper

    CALL kill(DH)

  END SUBROUTINE RCOLLIMATORiP

  SUBROUTINE RCOLLIMATORiS(EL,X,i)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(RCOLP),INTENT(INOUT):: EL
    real(dp) DD
    TYPE(REAL_8) DH
    logical(lp) aper
    integer, intent(in) :: i

    CALL ALLOC(DH)
    DH=EL%L/two/el%p%nst
    DD=EL%P%LD/two/el%p%nst

    aper=APERTURE_FLAG
    APERTURE_FLAG=.true.

    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    CALL CHECK_APERTURE(EL%A,X)

    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)

    APERTURE_FLAG=aper

    CALL kill(DH)

  END SUBROUTINE RCOLLIMATORiS


  !  ECOLLIMATOR STUFF

  SUBROUTINE ECOLLIMATORR(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM), OPTIONAL,INTENT(INOUT):: MID
    TYPE(ECOL),INTENT(INOUT):: EL
    !   logical(lp) aper
    !   real(dp) DH,DD
    INTEGER I

    IF(PRESENT(MID)) CALL XMID(MID,X,0)
    DO I=1,EL%P%NST
       CALL ECOLLIMATORi(EL,X,i,MID)
    ENDDO


    !    DH=EL%L/two
    !    DD=EL%P%LD/two
    !    aper=APERTURE_FLAG
    !    APERTURE_FLAG=.true.
    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)
    !    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    !    CALL CHECK_APERTURE(EL%A,X)
    !    IF(PRESENT(MID)) CALL XMID(MID,X,1)
    !    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    !    IF(PRESENT(MID)) CALL XMID(MID,X,2)
    !    APERTURE_FLAG=aper


  END SUBROUTINE ECOLLIMATORR

  SUBROUTINE ECOLLIMATORP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(ECOLP),INTENT(INOUT):: EL
    ! TYPE(WORM_8), OPTIONAL,INTENT(INOUT):: MID
    !    real(dp) DD
    !    TYPE(REAL_8) DH
    !    logical(lp) aper
    INTEGER I
    !    CALL ALLOC(DH)



    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)
    DO I=1,EL%P%NST
       CALL ECOLLIMATORi(EL,X,i)
    ENDDO




    !    DH=EL%L/two
    !    DD=EL%P%LD/two
    !    aper=APERTURE_FLAG
    !    APERTURE_FLAG=.true.
    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)
    !    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    !    CALL CHECK_APERTURE(EL%A,X)
    !    IF(PRESENT(MID)) CALL XMID(MID,X,1)
    !    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    !    IF(PRESENT(MID)) CALL XMID(MID,X,2)
    !    APERTURE_FLAG=aper

    !    CALL KILL(DH)

  END SUBROUTINE ECOLLIMATORP

  SUBROUTINE ECOLLIMATORS(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(ECOLP),INTENT(INOUT):: EL

    INTEGER I

    DO I=1,EL%P%NST
       CALL ECOLLIMATORi(EL,X,i)
    ENDDO



    !    real(dp) DD
    !    TYPE(REAL_8) DH
    !    logical(lp) aper
    !    CALL ALLOC(DH)

    !    DH=EL%L/two
    !    DD=EL%P%LD/two
    !    aper=APERTURE_FLAG
    !    APERTURE_FLAG=.true.
    !    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    !    CALL CHECK_APERTURE(EL%A,X)
    !    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    !    APERTURE_FLAG=aper

    !    CALL KILL(DH)

  END SUBROUTINE ECOLLIMATORS

  SUBROUTINE ECOLLIMATORiR(EL,X,i,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM), OPTIONAL,INTENT(INOUT):: MID
    TYPE(ECOL),INTENT(INOUT):: EL
    real(dp) DH,DD
    logical(lp) aper
    integer, intent(in) :: i

    DH=EL%L/two/el%p%nst
    DD=EL%P%LD/two/el%p%nst

    aper=APERTURE_FLAG
    APERTURE_FLAG=.true.

    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    if(mod(el%p%nst,2)==1) then
       IF(PRESENT(MID)) THEN
          if(i==(el%p%nst+1)/2)  CALL XMID(MID,X,1)
       ENDIF
    endif
    CALL CHECK_APERTURE(EL%A,X)

    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    if(mod(el%p%nst,2)==0) then
       IF(PRESENT(MID)) THEN
          if(i==el%p%nst/2)  CALL XMID(MID,X,1)
       ENDIF
    endif

    APERTURE_FLAG=aper

  END SUBROUTINE ECOLLIMATORiR

  SUBROUTINE ECOLLIMATORiP(EL,X,i)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    ! TYPE(WORM_8), OPTIONAL,INTENT(INOUT):: MID
    TYPE(ECOLP),INTENT(INOUT):: EL
    real(dp) DD
    TYPE(REAL_8) DH
    logical(lp) aper
    integer, intent(in) :: i

    CALL ALLOC(DH)
    DH=EL%L/two/el%p%nst
    DD=EL%P%LD/two/el%p%nst

    aper=APERTURE_FLAG
    APERTURE_FLAG=.true.

    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    !    if(mod(el%p%nst,2)==1) then
    !       IF(PRESENT(MID)) THEN
    !          if(i==(el%p%nst+1)/2)  CALL XMID(MID,X,1)
    !       ENDIF
    !    endif
    CALL CHECK_APERTURE(EL%A,X)

    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    !    if(mod(el%p%nst,2)==0) then
    !       IF(PRESENT(MID)) THEN
    !          if(i==el%p%nst/2)  CALL XMID(MID,X,1)
    !       ENDIF
    !    endif

    APERTURE_FLAG=aper

    CALL kill(DH)

  END SUBROUTINE ECOLLIMATORiP

  SUBROUTINE ECOLLIMATORiS(EL,X,i)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(ECOLP),INTENT(INOUT):: EL
    real(dp) DD
    TYPE(REAL_8) DH
    logical(lp) aper
    integer, intent(in) :: i

    CALL ALLOC(DH)
    DH=EL%L/two/el%p%nst
    DD=EL%P%LD/two/el%p%nst

    aper=APERTURE_FLAG
    APERTURE_FLAG=.true.

    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
    CALL CHECK_APERTURE(EL%A,X)

    CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)

    APERTURE_FLAG=aper

    CALL kill(DH)

  END SUBROUTINE ECOLLIMATORiS

  !  Electric septum

  SUBROUTINE SEPR(EL,X,i,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(ESEPTUM),INTENT(INOUT):: EL
    TYPE(WORM), OPTIONAL,INTENT(INOUT):: MID
    real(dp) K,SH_X,SH,CH,CHM,PZ,E1,XT(2),ARG
    LOGICAL(LP) EXACT
    integer, intent(IN) ::i

    !    if(EL%P%EXACT) THEN
    if(.true.) then

       K=EL%P%CHARGE*EL%VOLT*c_1d_3/EL%P%P0C


       if(EL%P%TIME) then
          PZ=ROOT((one/EL%P%BETA0+X(5)+K*X(3))**2-(EL%P%GAMMA0I/EL%P%BETA0)**2-X(2)**2-X(4)**2)
          E1=one/EL%P%BETA0+X(5)
       else
          PZ=ROOT((one+X(5)+K*X(3))**2-X(2)**2-X(4)**2)
          E1=one+X(5)
       endif
       ARG=(EL%L/two/el%p%nst)*K/PZ
       SH_X=(EL%L/two/el%p%nst)*SINeHX_X(ARG)/PZ
       SH=SINeH(ARG)
       CH=COSeH(ARG)
       ARG=ARG*half
       CHM=(EL%L/two/el%p%nst)*SINeHX_X(ARG)/PZ*SINeH(ARG)
       ARG=ARG*TWO

       X(1)=X(1)+X(2)*(EL%L/two/el%p%nst)/PZ
       XT(1)=CH*X(3)+SH_X*X(4)+CHM*E1
       XT(2)=CH*X(4)+K*SH*X(3)+SH*E1
       X(6)=X(6)+CHM*X(4)+SH*X(3)+E1*SH_X

       X(3)=XT(1)
       X(4)=XT(2)

       if(EL%P%TIME) then
          X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/EL%P%BETA0/TWO/el%p%nst
       else
          X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/TWO/el%p%nst
       endif

       IF(PRESENT(MID)) THEN
          if(mod(el%p%nst,2)==1) then
             if(i==(el%p%nst+1)/2)  CALL XMID(MID,X,1)
          endif
       ENDIF

       K=EL%P%CHARGE*EL%VOLT*c_1d_3/EL%P%P0C    ! added 2004.06.09

       if(EL%P%TIME) then
          PZ=ROOT((one/EL%P%BETA0+X(5)+K*X(3))**2-(EL%P%GAMMA0I/EL%P%BETA0)**2-X(2)**2-X(4)**2)
          E1=one/EL%P%BETA0+X(5)
       else
          PZ=ROOT((one+X(5)+K*X(3))**2-X(2)**2-X(4)**2)
          E1=one+X(5)
       endif

       ARG=(EL%L/two/el%p%nst)*K/PZ
       SH_X=(EL%L/two/el%p%nst)*SINeHX_X(ARG)/PZ
       SH=SINeH(ARG)
       CH=COSeH(ARG)
       ARG=ARG*half
       CHM=(EL%L/two/el%p%nst)*SINeHX_X(ARG)/PZ*SINeH(ARG)
       ARG=ARG*TWO

       X(1)=X(1)+X(2)*(EL%L/two/el%p%nst)/PZ
       XT(1)=CH*X(3)+SH_X*X(4)+CHM*E1
       XT(2)=CH*X(4)+K*SH*X(3)+SH*E1
       X(6)=X(6)+CHM*X(4)+SH*X(3)+E1*SH_X

       X(3)=XT(1)
       X(4)=XT(2)

       if(EL%P%TIME) then
          X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/EL%P%BETA0/TWO/el%p%nst
       else
          X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/TWO/el%p%nst
       endif

       IF(PRESENT(MID)) THEN
          if(mod(el%p%nst,2)==0) then
             if(i==el%p%nst/2)  CALL XMID(MID,X,1)
          endif
       ENDIF
    else

       K=EL%P%CHARGE*EL%VOLT*c_1d_3/EL%P%P0C



       if(EL%P%TIME) then
          PZ=root((one/EL%P%BETA0+X(5)+K*X(3))**2-(EL%P%GAMMA0I/EL%P%BETA0)**2)
          E1=one/EL%P%BETA0+X(5)
       else
          PZ=(one+X(5)+K*X(3))
          E1=one+X(5)
       endif

       ARG=(EL%L/two/el%p%nst)*K/PZ
       SH_X=(EL%L/two/el%p%nst)*SINeHX_X(ARG)/PZ
       SH=SINeH(ARG)
       CH=COSeH(ARG)
       ARG=ARG*half
       CHM=(EL%L/two/el%p%nst)*SINeHX_X(ARG)/PZ*SINeH(ARG)
       ARG=ARG*TWO

       X(1)=X(1)+X(2)*(EL%L/two/el%p%nst)/PZ
       XT(1)=CH*X(3)+SH_X*X(4)+CHM*E1
       XT(2)=CH*X(4)+K*SH*X(3)+SH*E1
       X(6)=X(6)+CHM*X(4)+SH*X(3)+E1*SH_X

       X(3)=XT(1)
       X(4)=XT(2)

       if(EL%P%TIME) then
          X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/EL%P%BETA0/TWO/el%p%nst
       else
          X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/TWO/el%p%nst
       endif

       IF(PRESENT(MID)) THEN
          if(mod(el%p%nst,2)==1) then
             if(i==(el%p%nst+1)/2)  CALL XMID(MID,X,1)
          endif
       ENDIF


       K=EL%P%CHARGE*EL%VOLT*c_1d_3/EL%P%P0C    ! added 2004.06.09

       if(EL%P%TIME) then
          PZ=root((one/EL%P%BETA0+X(5)+K*X(3))**2-(EL%P%GAMMA0I/EL%P%BETA0)**2)
          E1=one/EL%P%BETA0+X(5)
       else
          PZ=(one+X(5)+K*X(3))
          E1=one+X(5)
       endif

       ARG=(EL%L/two/el%p%nst)*K/PZ
       SH_X=(EL%L/two/el%p%nst)*SINeHX_X(ARG)/PZ
       SH=SINeH(ARG)
       CH=COSeH(ARG)
       ARG=ARG*half
       CHM=(EL%L/two/el%p%nst)*SINeHX_X(ARG)/PZ*SINeH(ARG)
       ARG=ARG*TWO

       X(1)=X(1)+X(2)*(EL%L/two/el%p%nst)/PZ
       XT(1)=CH*X(3)+SH_X*X(4)+CHM*E1
       XT(2)=CH*X(4)+K*SH*X(3)+SH*E1
       X(6)=X(6)+CHM*X(4)+SH*X(3)+E1*SH_X

       X(3)=XT(1)
       X(4)=XT(2)

       if(EL%P%TIME) then
          X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/EL%P%BETA0/TWO/el%p%nst
       else
          X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/TWO/el%p%nst
       endif

       IF(PRESENT(MID)) THEN
          if(mod(el%p%nst,2)==0) then
             if(i==el%p%nst/2)  CALL XMID(MID,X,1)
          endif
       ENDIF

    endif


  END SUBROUTINE SEPR

  SUBROUTINE SEPP(EL,X,I)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(ESEPTUMP),INTENT(INOUT):: EL
    ! TYPE(WORM_8), OPTIONAL,INTENT(INOUT):: MID
    TYPE(REAL_8) K,SH_X,SH,CH,CHM,PZ,E1,XT(2),ARG
    LOGICAL(LP) EXACT
    integer, intent(IN) ::i

    !    if(EL%P%EXACT) THEN
    if(.true.) then

       CALL ALLOC( K,SH_X,SH,CH,CHM,PZ,E1)
       CALL ALLOC( XT,2)

       K=EL%P%CHARGE*EL%VOLT*c_1d_3/EL%P%P0C


       if(EL%P%TIME) then
          PZ=SQRT((one/EL%P%BETA0+X(5)+K*X(3))**2-(EL%P%GAMMA0I/EL%P%BETA0)**2-X(2)**2-X(4)**2)
          E1=one/EL%P%BETA0+X(5)
       else
          PZ=SQRT((one+X(5)+K*X(3))**2-X(2)**2-X(4)**2)
          E1=one+X(5)
       endif

       ARG=(EL%L/two/el%p%nst)*K/PZ
       SH_X=(EL%L/two/el%p%nst)*SINHX_X(ARG)/PZ
       SH=SINH(ARG)
       CH=COSH(ARG)
       ARG=ARG*half
       CHM=(EL%L/two/el%p%nst)*SINHX_X(ARG)/PZ*SINH(ARG)
       ARG=TWO*ARG

       X(1)=X(1)+X(2)*(EL%L/two/el%p%nst)/PZ
       XT(1)=CH*X(3)+SH_X*X(4)+CHM*E1
       XT(2)=CH*X(4)+K*SH*X(3)+SH*E1
       X(6)=X(6)+CHM*X(4)+SH*X(3)+E1*SH_X

       X(3)=XT(1)
       X(4)=XT(2)

       if(EL%P%TIME) then
          X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/EL%P%BETA0/TWO/el%p%nst
       else
          X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/TWO/el%p%nst
       endif

       !       IF(PRESENT(MID)) THEN
       !          if(mod(el%p%nst,2)==1) then
       !             if(i==(el%p%nst+1)/2)  CALL XMID(MID,X,1)
       !          endif
       !       ENDIF


       K=EL%P%CHARGE*EL%VOLT*c_1d_3/EL%P%P0C    ! added 2004.06.09
       if(EL%P%TIME) then
          PZ=SQRT((one/EL%P%BETA0+X(5)+K*X(3))**2-(EL%P%GAMMA0I/EL%P%BETA0)**2-X(2)**2-X(4)**2)
          E1=one/EL%P%BETA0+X(5)
       else
          PZ=SQRT((one+X(5)+K*X(3))**2-X(2)**2-X(4)**2)
          E1=one+X(5)
       endif


       ARG=(EL%L/two/el%p%nst)*K/PZ
       SH_X=(EL%L/two/el%p%nst)*SINHX_X(ARG)/PZ
       SH=SINH(ARG)
       CH=COSH(ARG)
       ARG=ARG*half
       CHM=(EL%L/two/el%p%nst)*SINHX_X(ARG)/PZ*SINH(ARG)
       ARG=TWO*ARG

       X(1)=X(1)+X(2)*(EL%L/two/el%p%nst)/PZ
       XT(1)=CH*X(3)+SH_X*X(4)+CHM*E1
       XT(2)=CH*X(4)+K*SH*X(3)+SH*E1
       X(6)=X(6)+CHM*X(4)+SH*X(3)+E1*SH_X

       X(3)=XT(1)
       X(4)=XT(2)

       if(EL%P%TIME) then
          X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/EL%P%BETA0/TWO/el%p%nst
       else
          X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/TWO/el%p%nst
       endif
       !       IF(PRESENT(MID)) THEN
       !          if(mod(el%p%nst,2)==0) then
       !             if(i==el%p%nst/2)  CALL XMID(MID,X,1)
       !          endif
       !       ENDIF


       CALL KILL( K,SH_X,SH,CH,CHM,PZ,E1,ARG)
       CALL KILL( XT,2)
    else

       CALL ALLOC( K,SH_X,SH,CH,CHM,PZ,E1)
       CALL ALLOC( XT,2)

       K=EL%P%CHARGE*EL%VOLT*c_1d_3/EL%P%P0C

       if(EL%P%TIME) then
          PZ=SQRT((one/EL%P%BETA0+X(5)+K*X(3))**2-(EL%P%GAMMA0I/EL%P%BETA0)**2)
          E1=one/EL%P%BETA0+X(5)
       else
          PZ=(one+X(5)+K*X(3))
          E1=one+X(5)
       endif

       ARG=(EL%L/two/el%p%nst)*K/PZ
       SH_X=(EL%L/two/el%p%nst)*SINHX_X(ARG)/PZ
       SH=SINH(ARG)
       CH=COSH(ARG)
       ARG=ARG*half
       CHM=(EL%L/two/el%p%nst)*SINHX_X(ARG)/PZ*SINH(ARG)
       ARG=TWO*ARG

       X(1)=X(1)+X(2)*(EL%L/two/el%p%nst)/PZ
       XT(1)=CH*X(3)+SH_X*X(4)+CHM*E1
       XT(2)=CH*X(4)+K*SH*X(3)+SH*E1
       X(6)=X(6)+CHM*X(4)+SH*X(3)+E1*SH_X

       X(3)=XT(1)
       X(4)=XT(2)

       if(EL%P%TIME) then
          X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/EL%P%BETA0/TWO/el%p%nst
       else
          X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/TWO/el%p%nst
       endif

       !       IF(PRESENT(MID)) THEN
       !          if(mod(el%p%nst,2)==1) then
       !             if(i==(el%p%nst+1)/2)  CALL XMID(MID,X,1)
       !          endif
       !       ENDIF


       K=EL%P%CHARGE*EL%VOLT*c_1d_3/EL%P%P0C    ! added 2004.06.09
       if(EL%P%TIME) then
          PZ=SQRT((one/EL%P%BETA0+X(5)+K*X(3))**2-(EL%P%GAMMA0I/EL%P%BETA0)**2)
          E1=one/EL%P%BETA0+X(5)
       else
          PZ=(one+X(5)+K*X(3))
          E1=one+X(5)
       endif


       ARG=(EL%L/two/el%p%nst)*K/PZ
       SH_X=(EL%L/two/el%p%nst)*SINHX_X(ARG)/PZ
       SH=SINH(ARG)
       CH=COSH(ARG)
       ARG=ARG*half
       CHM=(EL%L/two/el%p%nst)*SINHX_X(ARG)/PZ*SINH(ARG)
       ARG=TWO*ARG

       X(1)=X(1)+X(2)*(EL%L/two/el%p%nst)/PZ
       XT(1)=CH*X(3)+SH_X*X(4)+CHM*E1
       XT(2)=CH*X(4)+K*SH*X(3)+SH*E1
       X(6)=X(6)+CHM*X(4)+SH*X(3)+E1*SH_X

       X(3)=XT(1)
       X(4)=XT(2)

       if(EL%P%TIME) then
          X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/EL%P%BETA0/TWO/el%p%nst
       else
          X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/TWO/el%p%nst
       endif

       !       IF(PRESENT(MID)) THEN
       !          if(mod(el%p%nst,2)==0) then
       !             if(i==el%p%nst/2)  CALL XMID(MID,X,1)
       !          endif
       !       ENDIF


       CALL KILL( K,SH_X,SH,CH,CHM,PZ,E1,ARG)
       CALL KILL( XT,2)

    ENDIF
  END SUBROUTINE SEPP

  SUBROUTINE SEPS(EL,Y)
    IMPLICIT NONE
    TYPE(REAL_8)  X(6)
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(ESEPTUMP),INTENT(INOUT):: EL

    CALL ALLOC(X,6)
    X=Y
    CALL SEPTTRACK(EL,X,0)

    Y=X
    CALL KILL(X,6)
  END SUBROUTINE SEPS


  SUBROUTINE SYMPSEPR(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(ESEPTUM),INTENT(INOUT):: EL
    TYPE(WORM), OPTIONAL,INTENT(INOUT):: MID
    integer i
    !    LOGICAL(LP) EXACT

    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    do i=1,el%p%nst
       CALL SEPTTRACK(EL,X,i,MID)
    enddo

    IF(PRESENT(MID)) CALL XMID(MID,X,1)

  END SUBROUTINE SYMPSEPR

  SUBROUTINE SYMPSEPP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(ESEPTUMP),INTENT(INOUT):: EL
    ! TYPE(WORM_8), OPTIONAL,INTENT(INOUT):: MID
    integer i

    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)
    do i=1,el%p%nst
       CALL SEPTTRACK(EL,X,i)
    enddo
    !    IF(PRESENT(MID)) CALL XMID(MID,X,1)


  END SUBROUTINE SYMPSEPP

  SUBROUTINE SYMPSEPS(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(ESEPTUMP),INTENT(INOUT):: EL
    integer i

    !    EXACT=.TRUE.
    !       CALL ROT_XY(EL%PHAS,X,EXACT)
    do i=1,el%p%nst
       CALL SEPTTRACK(EL,X)
    enddo
    !       EL%PHAS=-EL%PHAS; CALL ROT_XY(EL%PHAS,X,EXACT);EL%PHAS=-EL%PHAS;


  END SUBROUTINE SYMPSEPS


  !  New kind for straigth exact

  SUBROUTINE KICKEXR(EL,YL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(STREX),INTENT(IN):: EL
    real(dp),INTENT(IN):: YL
    real(dp) X1,X3,X5,BBYTW,BBXTW,BBYTWT,B(3),B2
    INTEGER J,DIR

    DIR=EL%P%DIR*EL%P%CHARGE

    X1=X(1)
    X3=X(3)

    if(EL%P%TIME) then
       X5=ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
    else
       X5=X(5)
    endif

    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF

    IF(EL%P%RADIATION) THEN
       B(1)=BBXTW
       B(2)=BBYTW
       B(3)=zero
       CALL B2PERP(EL%P,B,X,X5,B2)
       X(5)=X(5)-CRADF(EL%P)*(one+X(5))**3*B2*YL/ROOT((one+X(5))**2-X(2)**2-X(4)**2)
       if(EL%P%TIME) then
          X(2)=X(2)*ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          X(4)=X(4)*ROOT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
       else
          X(2)=X(2)*(one+X(5))/(one+X5)
          X(4)=X(4)*(one+X(5))/(one+X5)
       endif
    ENDIF

    X(2)=X(2)-YL*DIR*BBYTW
    X(4)=X(4)+YL*DIR*BBXTW

    IF(.NOT.EL%DRIFTKICK) THEN
       X(2)=X(2)+YL*DIR*EL%BN(1)
    ENDIF

  END SUBROUTINE KICKEXR

  SUBROUTINE KICKEXP(EL,YL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(STREXP),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) X1,X3,X5,BBYTW,BBXTW,BBYTWT,B(3),B2
    INTEGER J,DIR

    DIR=EL%P%DIR*EL%P%CHARGE

    CALL ALLOC(X1)
    CALL ALLOC(X3)
    CALL ALLOC(X5)
    CALL ALLOC(BBYTW)
    CALL ALLOC(BBXTW)
    CALL ALLOC(BBYTWT)

    X1=X(1)
    X3=X(3)
    if(EL%P%TIME) then
       X5=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
    else
       X5=X(5)
    endif


    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF

    IF(EL%P%RADIATION) THEN
       CALL ALLOC(B2)
       CALL ALLOC(B,3)
       B(1)=BBXTW
       B(2)=BBYTW
       B(3)=zero
       CALL B2PERP(EL%P,B,X,X5,B2)
       X(5)=X(5)-CRADF(EL%P)*(one+X(5))**3*B2*YL/SQRT((one+X(5))**2-X(2)**2-X(4)**2)
       if(EL%P%TIME) then
          X(2)=X(2)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          X(4)=X(4)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
       else
          X(2)=X(2)*(one+X(5))/(one+X5)
          X(4)=X(4)*(one+X(5))/(one+X5)
       endif
       CALL KILL(B2)
       CALL KILL(B,3)
    ENDIF
    X(2)=X(2)-YL*DIR*BBYTW
    X(4)=X(4)+YL*DIR*BBXTW

    IF(.NOT.EL%DRIFTKICK) THEN
       X(2)=X(2)+YL*DIR*EL%BN(1)
    ENDIF

    CALL KILL(X1)
    CALL KILL(X3)
    CALL KILL(X5)
    CALL KILL(BBYTW)
    CALL KILL(BBXTW)
    CALL KILL(BBYTWT)

  END SUBROUTINE KICKEXP

  SUBROUTINE KICKEXS(EL,YL,Y)
    IMPLICIT NONE
    TYPE(REAL_8) X(6),XR(6)
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(DAMAP) XP,ID,DISP,XT
    TYPE(STREXP),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(IN):: YL
    TYPE(REAL_8) X1,X3,X5,BBYTW,BBXTW,BBYTWT,B(3),B2,DENF
    real(dp) B20,B30,BF, v(6) !,R1,R2,DEN0
    logical(lp) done_stoch
    INTEGER I,J,DIR

    DIR=EL%P%DIR*EL%P%CHARGE

    CALL ALLOC(X1)
    CALL ALLOC(X3)
    CALL ALLOC(X5)
    CALL ALLOC(denf)
    CALL ALLOC(BBYTW)
    CALL ALLOC(BBXTW)
    CALL ALLOC(BBYTWT)
    CALL ALLOC(X)
    CALL ALLOC(XR)
    CALL ALLOC(XP)
    CALL ALLOC(ID)
    CALL ALLOC(DISP)
    CALL ALLOC(XT)
    CALL ALLOC(B2)
    CALL ALLOC(B,3)



    X=Y
    X1=X(1)
    X3=X(3)
    if(EL%P%TIME) then
       X5=SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)-one
    else
       X5=X(5)
    endif


    IF(EL%P%NMUL>=1) THEN
       BBYTW=EL%BN(EL%P%NMUL)
       BBXTW=EL%AN(EL%P%NMUL)


       DO  J=EL%P%NMUL-1,1,-1
          BBYTWT=X1*BBYTW-X3*BBXTW+EL%BN(J)
          BBXTW=X3*BBYTW+X1*BBXTW+EL%AN(J)
          BBYTW=BBYTWT
       ENDDO
    ELSE
       BBYTW=zero
       BBXTW=zero
    ENDIF

    XP=X
    XR=X
    XP%V(2)=X(2)/SQRT((one+x5)**2-X(2)**2-X(4)**2)
    XP%V(4)=X(4)/SQRT((one+x5)**2-X(2)**2-X(4)**2)
    IF(EL%P%RADIATION) THEN
       B(1)=BBXTW
       B(2)=BBYTW
       B(3)=zero
       CALL B2PERP(EL%P,B,X,X5,B2)
       X(5)=X(5)-CRADF(EL%P)*(one+X(5))**3*B2*YL/SQRT((one+X(5))**2-X(2)**2-X(4)**2)

       if(EL%P%TIME) then
          X(2)=X(2)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
          X(4)=X(4)*SQRT(one+two*X(5)/EL%P%beta0+x(5)**2)/(one+X5)
       else
          X(2)=X(2)*(one+X(5))/(one+X5)
          X(4)=X(4)*(one+X(5))/(one+X5)
       endif

    ENDIF
    X(2)=X(2)-YL*DIR*BBYTW
    X(4)=X(4)+YL*DIR*BBXTW
    IF(.NOT.EL%DRIFTKICK) THEN
       X(2)=X(2)+YL*DIR*EL%BN(1)
    ENDIF

    done_stoch=.false.
    if(EL%P%B0==zero.and.stoch_in_rec) then

       denf=(one+xR(5))**5/SQRT((one+XR(5))**2-XR(2)**2-XR(4)**2)
       b20=b2
       b30=b20**c_1_5
       bf=cflucf(el%p)*b30
       denf=denf*bf*yl
       done_stoch=.true.
    elseif(EL%P%B0/=zero)   then
       done_stoch=.true.
    endif

    if(done_stoch) then

       if(EL%P%B0/=zero) then
          !
          if(knob) then
             v=xr
             DISP=xp*id
             id=1
             DISP=ID-DISP
             XP=DISP*XP

             id=0
             XT=XR
             DISP=XT*ID
             ID=1
             DISP=ID-DISP
             XT=DISP*XT
             xr=xt+V
             CALL B2PERP(EL%P,B,Xr,X5,B2)

             denf=(one+xR(5))**5/SQRT((one+XR(5))**2-XR(2)**2-XR(4)**2)

             denf=DENF*cflucf(el%p)*yl*b2**c_1_5
          else
             CALL B2PERP(EL%P,B,Xr,X5,B2)
             denf=(one+xR(5))**5/SQRT((one+XR(5))**2-XR(2)**2-XR(4)**2)
             b20=b2
             b30=b20**c_1_5
             bf=cflucf(el%p)*b30
             denf=denf*bf*yl
          endif
       endif

       xp=xp**(-1)
       do i=1,6
          do j=1,6
             X1=(xp%v(i)).par.'000010'
             X3=(xp%v(j)).par.'000010'
             denf=denf.par.'000000'
             y(I)%E(J)=y(I)%E(J)+denf*x1*x3
          enddo
       enddo
    endif


    Y=X
    CALL KILL(B2)
    CALL KILL(B,3)
    CALL KILL(XP)
    CALL KILL(ID)
    CALL KILL(DISP)
    CALL KILL(XT)
    CALL KILL(X)
    CALL KILL(XR)
    CALL KILL(X1)
    CALL KILL(X3)
    CALL KILL(X5)
    CALL KILL(BBYTW)
    CALL KILL(BBXTW)
    CALL KILL(BBYTWT)
    CALL KILL(denf)

  END SUBROUTINE KICKEXS


  SUBROUTINE INTEEXR(EL,X,MID)
    IMPLICIT NONE
    TYPE(STREX),INTENT(IN):: EL
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM) ,OPTIONAL,INTENT(INOUT):: MID
    real(dp) D,DH,DD
    real(dp) D1,D2,DK1,DK2
    real(dp) DD1,DD2
    real(dp) DF(4),DK(4),DDF(4)
    INTEGER I,J

    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    IF(EL%DRIFTKICK) THEN

       SELECT CASE(EL%P%METHOD)
       CASE(2)
          DH=EL%L/two/EL%P%NST
          D=EL%L/EL%P%NST
          DD=EL%P%LD/two/EL%P%NST

          DO I=1,EL%P%NST
             CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICKEX (EL,D,X)
             CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO
       CASE(4)
          D1=EL%L*FD1/EL%P%NST
          D2=EL%L*FD2/EL%P%NST
          DD1=EL%P%LD*FD1/EL%P%NST
          DD2=EL%P%LD*FD2/EL%P%NST
          DK1=EL%L*FK1/EL%P%NST
          DK2=EL%L*FK2/EL%P%NST

          DO I=1,EL%P%NST
             CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICKEX (EL,DK1,X)
             CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICKEX (EL,DK2,X)
             CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICKEX (EL,DK1,X)
             CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO

       CASE(6)
          DO I =1,4
             DF(I)=EL%L*YOSD(I)/EL%P%NST
             DDF(I)=EL%P%LD*YOSD(I)/EL%P%NST
             DK(I)=EL%L*YOSK(I)/EL%P%NST
          ENDDO

          DO I=1,EL%P%NST
             DO J=4,2,-1
                CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
                CALL KICKEX (EL,DK(J),X)
             ENDDO
             CALL DRIFT(DF(1),DDF(1),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICKEX (EL,DK(1),X)
             CALL DRIFT(DF(1),DDF(1),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             DO J=2,4
                CALL KICKEX (EL,DK(J),X)
                CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             ENDDO
             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO

       CASE DEFAULT
          w_p=0
          w_p%nc=1
          w_p%fc='(1(1X,A72))'
          WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
          call write_e(357)
       END SELECT
    ELSE
       SELECT CASE(EL%P%METHOD)
       CASE(2)
          DH=EL%L/two/EL%P%NST
          D=EL%L/EL%P%NST
          DD=EL%P%LD/two/EL%P%NST

          DO I=1,EL%P%NST
             CALL SPAR(EL,DH,DD,X)
             CALL KICKEX (EL,D,X)
             CALL SPAR(EL,DH,DD,X)
             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO
       CASE(4)
          D1=EL%L*FD1/EL%P%NST
          D2=EL%L*FD2/EL%P%NST
          DD1=EL%P%LD*FD1/EL%P%NST
          DD2=EL%P%LD*FD2/EL%P%NST
          DK1=EL%L*FK1/EL%P%NST
          DK2=EL%L*FK2/EL%P%NST

          DO I=1,EL%P%NST
             CALL SPAR(EL,D1,DD1,X)
             CALL KICKEX (EL,DK1,X)
             CALL SPAR(EL,D2,DD2,X)
             CALL KICKEX (EL,DK2,X)
             CALL SPAR(EL,D2,DD2,X)
             CALL KICKEX (EL,DK1,X)
             CALL SPAR(EL,D1,DD1,X)
             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO

       CASE(6)
          DO I =1,4
             DF(I)=EL%L*YOSD(I)/EL%P%NST
             DDF(I)=EL%P%LD*YOSD(I)/EL%P%NST
             DK(I)=EL%L*YOSK(I)/EL%P%NST
          ENDDO

          DO I=1,EL%P%NST
             DO J=4,2,-1
                CALL SPAR(EL,DF(J),DDF(J),X)
                CALL KICKEX (EL,DK(J),X)
             ENDDO
             CALL SPAR(EL,DF(1),DDF(1),X)
             CALL KICKEX (EL,DK(1),X)
             CALL SPAR(EL,DF(1),DDF(1),X)
             DO J=2,4
                CALL KICKEX (EL,DK(J),X)
                CALL SPAR(EL,DF(J),DDF(J),X)
             ENDDO
             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO


       CASE DEFAULT
          w_p=0
          w_p%nc=1
          w_p%fc='(1(1X,A72))'
          WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
          call write_e(357)
       END SELECT

    ENDIF



  END SUBROUTINE INTEEXR





  SUBROUTINE INTEEXP(EL,X)
    IMPLICIT NONE
    TYPE(STREXP),INTENT(IN):: EL
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: MID
    TYPE(REAL_8) D,DH
    real(dp) DD
    TYPE(REAL_8) D1,D2,DK1,DK2
    real(dp) DD1,DD2
    TYPE(REAL_8) DF(4),DK(4)
    real(dp) DDF(4)
    INTEGER I,J

    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    IF(EL%DRIFTKICK) THEN
       SELECT CASE(EL%P%METHOD)
       CASE(2)
          CALL ALLOC(DH)
          CALL ALLOC(D)
          DH=EL%L/two/EL%P%NST
          D=EL%L/EL%P%NST
          DD=EL%P%LD/two/EL%P%NST

          DO I=1,EL%P%NST
             CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICKEX (EL,D,X)
             CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             !             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO
          CALL KILL(DH)
          CALL KILL(D)
       CASE(4)
          CALL ALLOC(D1)
          CALL ALLOC(D2)
          CALL ALLOC(DK1)
          CALL ALLOC(DK2)
          D1=EL%L*FD1/EL%P%NST
          D2=EL%L*FD2/EL%P%NST
          DD1=EL%P%LD*FD1/EL%P%NST
          DD2=EL%P%LD*FD2/EL%P%NST
          DK1=EL%L*FK1/EL%P%NST
          DK2=EL%L*FK2/EL%P%NST

          DO I=1,EL%P%NST
             CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICKEX (EL,DK1,X)
             CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICKEX (EL,DK2,X)
             CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICKEX (EL,DK1,X)
             CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             !             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO
          CALL KILL(D1)
          CALL KILL(D2)
          CALL KILL(DK1)
          CALL KILL(DK2)
       CASE(6)
          CALL ALLOC(DF,4)
          CALL ALLOC(DK,4)
          DO I =1,4
             DF(I)=EL%L*YOSD(I)/EL%P%NST
             DDF(I)=EL%P%LD*YOSD(I)/EL%P%NST
             DK(I)=EL%L*YOSK(I)/EL%P%NST
          ENDDO

          DO I=1,EL%P%NST
             DO J=4,2,-1
                CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
                CALL KICKEX (EL,DK(J),X)
             ENDDO
             CALL DRIFT(DF(1),DDF(1),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICKEX (EL,DK(1),X)
             CALL DRIFT(DF(1),DDF(1),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             DO J=2,4
                CALL KICKEX (EL,DK(J),X)
                CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             ENDDO
             !             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO
          CALL KILL(DF,4)
          CALL KILL(DK,4)


       CASE DEFAULT
          w_p=0
          w_p%nc=1
          w_p%fc='(1(1X,A72))'
          WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
          call write_e(357)
       END SELECT
    ELSE
       SELECT CASE(EL%P%METHOD)
       CASE(2)
          CALL ALLOC(DH)
          CALL ALLOC(D)
          DH=EL%L/two/EL%P%NST
          D=EL%L/EL%P%NST
          DD=EL%P%LD/two/EL%P%NST

          DO I=1,EL%P%NST
             CALL SPAR(EL,DH,DD,X)
             CALL KICKEX (EL,D,X)
             CALL SPAR(EL,DH,DD,X)
             !             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO
          CALL KILL(DH)
          CALL KILL(D)
       CASE(4)
          CALL ALLOC(D1)
          CALL ALLOC(D2)
          CALL ALLOC(DK1)
          CALL ALLOC(DK2)
          D1=EL%L*FD1/EL%P%NST
          D2=EL%L*FD2/EL%P%NST
          DD1=EL%P%LD*FD1/EL%P%NST
          DD2=EL%P%LD*FD2/EL%P%NST
          DK1=EL%L*FK1/EL%P%NST
          DK2=EL%L*FK2/EL%P%NST

          DO I=1,EL%P%NST
             CALL SPAR(EL,D1,DD1,X)
             CALL KICKEX (EL,DK1,X)
             CALL SPAR(EL,D2,DD2,X)
             CALL KICKEX (EL,DK2,X)
             CALL SPAR(EL,D2,DD2,X)
             CALL KICKEX (EL,DK1,X)
             CALL SPAR(EL,D1,DD1,X)
             !             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO
          CALL KILL(D1)
          CALL KILL(D2)
          CALL KILL(DK1)
          CALL KILL(DK2)
       CASE(6)
          CALL ALLOC(DF,4)
          CALL ALLOC(DK,4)
          DO I =1,4
             DF(I)=EL%L*YOSD(I)/EL%P%NST
             DDF(I)=EL%P%LD*YOSD(I)/EL%P%NST
             DK(I)=EL%L*YOSK(I)/EL%P%NST
          ENDDO

          DO I=1,EL%P%NST
             DO J=4,2,-1
                CALL SPAR(EL,DF(J),DDF(J),X)
                CALL KICKEX (EL,DK(J),X)
             ENDDO
             CALL SPAR(EL,DF(1),DDF(1),X)
             CALL KICKEX (EL,DK(1),X)
             CALL SPAR(EL,DF(1),DDF(1),X)
             DO J=2,4
                CALL KICKEX (EL,DK(J),X)
                CALL SPAR(EL,DF(J),DDF(J),X)
             ENDDO
             !             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO
          CALL KILL(DF,4)
          CALL KILL(DK,4)


       CASE DEFAULT
          w_p=0
          w_p%nc=1
          w_p%fc='(1(1X,A72))'
          WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
          call write_e(357)
       END SELECT
    ENDIF

  END SUBROUTINE INTEEXP


  SUBROUTINE INTEEXS(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(STREXP),INTENT(IN):: EL
    TYPE(REAL_8) D,DH
    real(dp) DD
    TYPE(REAL_8) D1,D2,DK1,DK2
    real(dp) DD1,DD2
    TYPE(REAL_8) DF(4),DK(4)
    real(dp) DDF(4)
    INTEGER I,J


    IF(EL%DRIFTKICK) THEN
       SELECT CASE(EL%P%METHOD)
       CASE(2)
          CALL ALLOC(DH)
          CALL ALLOC(D)
          DH=EL%L/two/EL%P%NST
          D=EL%L/EL%P%NST
          DD=EL%P%LD/two/EL%P%NST

          DO I=1,EL%P%NST
             CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICKEX (EL,D,X)
             CALL DRIFT(DH,DD,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          ENDDO
          CALL KILL(DH)
          CALL KILL(D)
       CASE(4)
          CALL ALLOC(D1)
          CALL ALLOC(D2)
          CALL ALLOC(DK1)
          CALL ALLOC(DK2)
          D1=EL%L*FD1/EL%P%NST
          D2=EL%L*FD2/EL%P%NST
          DD1=EL%P%LD*FD1/EL%P%NST
          DD2=EL%P%LD*FD2/EL%P%NST
          DK1=EL%L*FK1/EL%P%NST
          DK2=EL%L*FK2/EL%P%NST

          DO I=1,EL%P%NST
             CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICKEX (EL,DK1,X)
             CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICKEX (EL,DK2,X)
             CALL DRIFT(D2,DD2,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICKEX (EL,DK1,X)
             CALL DRIFT(D1,DD1,EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
          ENDDO
          CALL KILL(D1)
          CALL KILL(D2)
          CALL KILL(DK1)
          CALL KILL(DK2)
       CASE(6)
          CALL ALLOC(DF,4)
          CALL ALLOC(DK,4)
          DO I =1,4
             DF(I)=EL%L*YOSD(I)/EL%P%NST
             DDF(I)=EL%P%LD*YOSD(I)/EL%P%NST
             DK(I)=EL%L*YOSK(I)/EL%P%NST
          ENDDO

          DO I=1,EL%P%NST
             DO J=4,2,-1
                CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
                CALL KICKEX (EL,DK(J),X)
             ENDDO
             CALL DRIFT(DF(1),DDF(1),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             CALL KICKEX (EL,DK(1),X)
             CALL DRIFT(DF(1),DDF(1),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             DO J=2,4
                CALL KICKEX (EL,DK(J),X)
                CALL DRIFT(DF(J),DDF(J),EL%P%beta0,EL%P%TOTALPATH,EL%P%EXACT,EL%P%TIME,X)
             ENDDO
          ENDDO
          CALL KILL(DF,4)
          CALL KILL(DK,4)



       CASE DEFAULT
          w_p=0
          w_p%nc=1
          w_p%fc='(1(1X,A72))'
          WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
          call write_e(357)
       END SELECT
    ELSE
       SELECT CASE(EL%P%METHOD)
       CASE(2)
          CALL ALLOC(DH)
          CALL ALLOC(D)
          DH=EL%L/two/EL%P%NST
          D=EL%L/EL%P%NST
          DD=EL%P%LD/two/EL%P%NST

          DO I=1,EL%P%NST
             CALL SPAR(EL,DH,DD,X)
             CALL KICKEX (EL,D,X)
             CALL SPAR(EL,DH,DD,X)
          ENDDO
          CALL KILL(DH)
          CALL KILL(D)
       CASE(4)
          CALL ALLOC(D1)
          CALL ALLOC(D2)
          CALL ALLOC(DK1)
          CALL ALLOC(DK2)
          D1=EL%L*FD1/EL%P%NST
          D2=EL%L*FD2/EL%P%NST
          DD1=EL%P%LD*FD1/EL%P%NST
          DD2=EL%P%LD*FD2/EL%P%NST
          DK1=EL%L*FK1/EL%P%NST
          DK2=EL%L*FK2/EL%P%NST

          DO I=1,EL%P%NST
             CALL SPAR(EL,D1,DD1,X)
             CALL KICKEX (EL,DK1,X)
             CALL SPAR(EL,D2,DD2,X)
             CALL KICKEX (EL,DK2,X)
             CALL SPAR(EL,D2,DD2,X)
             CALL KICKEX (EL,DK1,X)
             CALL SPAR(EL,D1,DD1,X)
          ENDDO
          CALL KILL(D1)
          CALL KILL(D2)
          CALL KILL(DK1)
          CALL KILL(DK2)
       CASE(6)
          CALL ALLOC(DF,4)
          CALL ALLOC(DK,4)
          DO I =1,4
             DF(I)=EL%L*YOSD(I)/EL%P%NST
             DDF(I)=EL%P%LD*YOSD(I)/EL%P%NST
             DK(I)=EL%L*YOSK(I)/EL%P%NST
          ENDDO

          DO I=1,EL%P%NST
             DO J=4,2,-1
                CALL SPAR(EL,DF(J),DDF(J),X)
                CALL KICKEX (EL,DK(J),X)
             ENDDO
             CALL SPAR(EL,DF(1),DDF(1),X)
             CALL KICKEX (EL,DK(1),X)
             CALL SPAR(EL,DF(1),DDF(1),X)
             DO J=2,4
                CALL KICKEX (EL,DK(J),X)
                CALL SPAR(EL,DF(J),DDF(J),X)
             ENDDO
          ENDDO
          CALL KILL(DF,4)
          CALL KILL(DK,4)


       CASE DEFAULT
          w_p=0
          w_p%nc=1
          w_p%fc='(1(1X,A72))'
          WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
          call write_e(357)
       END SELECT
    ENDIF

  END SUBROUTINE INTEEXS

  SUBROUTINE SYMPINTEXR(EL,X,MID)
    IMPLICIT NONE
    logical(lp) :: doneitt=.true.
    real(dp),INTENT(INOUT):: X(6)
    TYPE(STREX),INTENT(IN):: EL
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: MID
    real(dp) ANGH
    !etienne

    IF(EL%P%DIR==1) THEN


       IF(EL%LIKEMAD) THEN

          ANGH=EL%P%B0*EL%P%LD*half-EL%P%EDGE(1)
          CALL ROT_XZ(EL%P%EDGE(1),X,EL%P%BETA0,DONEITT,EL%P%TIME)
          CALL FACE(EL%P,EL%BN,EL%H1,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
          CALL  WEDGE(ANGH,X,EL1=EL)

       ELSE
          CALL EDGE_TRUE_PARALLEL(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       ENDIF


       CALL INTE_strex(EL,X,MID)

       IF(EL%LIKEMAD) THEN
          ANGH=EL%P%B0*EL%P%LD*half-EL%P%EDGE(2)
          CALL  WEDGE(ANGH,X,EL1=EL)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          CALL FACE(EL%P,EL%BN,EL%H2,X)
          CALL ROT_XZ(EL%P%EDGE(2),X,EL%P%BETA0,DONEITT,EL%P%TIME)
       ELSE
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
          CALL EDGE_TRUE_PARALLEL(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
       ENDIF


    ELSE


       IF(EL%LIKEMAD) THEN

          ANGH=EL%P%B0*EL%P%LD*half-EL%P%EDGE(2)
          CALL ROT_XZ(EL%P%EDGE(2),X,EL%P%BETA0,DONEITT,EL%P%TIME)
          CALL FACE(EL%P,EL%BN,EL%H2,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
          CALL  WEDGE(ANGH,X,EL1=EL)
       ELSE
          CALL EDGE_TRUE_PARALLEL(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       ENDIF


       CALL INTE_strex(EL,X,MID)

       IF(EL%LIKEMAD) THEN
          ANGH=EL%P%B0*EL%P%LD*half-EL%P%EDGE(1)
          CALL  WEDGE(ANGH,X,EL1=EL)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          CALL FACE(EL%P,EL%BN,EL%H1,X)
          CALL ROT_XZ(EL%P%EDGE(1),X,EL%P%BETA0,DONEITT,EL%P%TIME)
       ELSE
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
          CALL EDGE_TRUE_PARALLEL(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
       ENDIF


    ENDIF


  END SUBROUTINE SYMPINTEXR

  SUBROUTINE SYMPINTEXP(EL,X)
    IMPLICIT NONE
    logical(lp) :: doneitt=.true.
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(STREXP),INTENT(IN):: EL
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: MID
    real(dp) ANGH

    IF(EL%P%DIR==1) THEN


       IF(EL%LIKEMAD) THEN

          ANGH=EL%P%B0*EL%P%LD*half-EL%P%EDGE(1)
          CALL ROT_XZ(EL%P%EDGE(1),X,EL%P%BETA0,DONEITT,EL%P%TIME)
          CALL FACE(EL%P,EL%BN,EL%H1,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
          CALL  WEDGE(ANGH,X,EL1=EL)

       ELSE
          CALL EDGE_TRUE_PARALLEL(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       ENDIF


       CALL INTE_strex(EL,X)

       IF(EL%LIKEMAD) THEN
          ANGH=EL%P%B0*EL%P%LD*half-EL%P%EDGE(2)
          CALL  WEDGE(ANGH,X,EL1=EL)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          CALL FACE(EL%P,EL%BN,EL%H2,X)
          CALL ROT_XZ(EL%P%EDGE(2),X,EL%P%BETA0,DONEITT,EL%P%TIME)
       ELSE
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
          CALL EDGE_TRUE_PARALLEL(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
       ENDIF


    ELSE


       IF(EL%LIKEMAD) THEN

          ANGH=EL%P%B0*EL%P%LD*half-EL%P%EDGE(2)
          CALL ROT_XZ(EL%P%EDGE(2),X,EL%P%BETA0,DONEITT,EL%P%TIME)
          CALL FACE(EL%P,EL%BN,EL%H2,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
          CALL  WEDGE(ANGH,X,EL1=EL)
       ELSE
          CALL EDGE_TRUE_PARALLEL(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       ENDIF


       CALL INTE_strex(EL,X)

       IF(EL%LIKEMAD) THEN
          ANGH=EL%P%B0*EL%P%LD*half-EL%P%EDGE(1)
          CALL  WEDGE(ANGH,X,EL1=EL)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          CALL FACE(EL%P,EL%BN,EL%H1,X)
          CALL ROT_XZ(EL%P%EDGE(1),X,EL%P%BETA0,DONEITT,EL%P%TIME)
       ELSE
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
          CALL EDGE_TRUE_PARALLEL(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
       ENDIF


    ENDIF

  END SUBROUTINE SYMPINTEXP

  SUBROUTINE SYMPINTEXS(EL,X)
    IMPLICIT NONE
    logical(lp) :: doneitt=.true.
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(STREXP),INTENT(IN):: EL
    real(dp) ANGH

    IF(EL%P%DIR==1) THEN


       IF(EL%LIKEMAD) THEN

          ANGH=EL%P%B0*EL%P%LD*half-EL%P%EDGE(1)
          CALL ROT_XZ(EL%P%EDGE(1),X,EL%P%BETA0,DONEITT,EL%P%TIME)
          CALL FACE(EL%P,EL%BN,EL%H1,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
          CALL  WEDGE(ANGH,X,EL1=EL)

       ELSE
          CALL EDGE_TRUE_PARALLEL(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
       ENDIF


       CALL INTE_strex(EL,X)

       IF(EL%LIKEMAD) THEN
          ANGH=EL%P%B0*EL%P%LD*half-EL%P%EDGE(2)
          CALL  WEDGE(ANGH,X,EL1=EL)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          CALL FACE(EL%P,EL%BN,EL%H2,X)
          CALL ROT_XZ(EL%P%EDGE(2),X,EL%P%BETA0,DONEITT,EL%P%TIME)
       ELSE
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
          CALL EDGE_TRUE_PARALLEL(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
       ENDIF


    ELSE


       IF(EL%LIKEMAD) THEN

          ANGH=EL%P%B0*EL%P%LD*half-EL%P%EDGE(2)
          CALL ROT_XZ(EL%P%EDGE(2),X,EL%P%BETA0,DONEITT,EL%P%TIME)
          CALL FACE(EL%P,EL%BN,EL%H2,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,2,X)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
          CALL  WEDGE(ANGH,X,EL1=EL)
       ELSE
          CALL EDGE_TRUE_PARALLEL(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,2,X)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,2,X)
       ENDIF


       CALL INTE_strex(EL,X)

       IF(EL%LIKEMAD) THEN
          ANGH=EL%P%B0*EL%P%LD*half-EL%P%EDGE(1)
          CALL  WEDGE(ANGH,X,EL1=EL)
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
          CALL FRINGE_(EL%P,EL%BN,EL%FINT,EL%HGAP,1,X)
          CALL FACE(EL%P,EL%BN,EL%H1,X)
          CALL ROT_XZ(EL%P%EDGE(1),X,EL%P%BETA0,DONEITT,EL%P%TIME)
       ELSE
          IF(EL%P%FRINGE) CALL MULTIPOLE_FRINGE(EL%P,EL%AN,EL%BN,1,X)
          CALL EDGE_TRUE_PARALLEL(EL%P,EL%BN,EL%H1,EL%H2,EL%FINT,EL%HGAP,1,X)
       ENDIF


    ENDIF

  END SUBROUTINE SYMPINTEXS

  SUBROUTINE SPARr(EL,YL,DL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    real(dp),INTENT(IN):: YL,DL
    TYPE(STREX),INTENT(IN):: EL
    real(dp) XN(6),PZ,PZS,PT
    real(dp)  b
    INTEGER DIR

    DIR=EL%P%DIR*EL%P%CHARGE

    if(EL%P%TIME) then
       B=EL%P%BETA0
       PZ=ROOT(one+two*x(5)/b+X(5)**2-X(2)**2-X(4)**2)
       XN(2)=X(2)-YL*DIR*EL%BN(1)
       PT=ROOT(one+two*x(5)/b+X(5)**2-X(4)**2)
       PZS=ROOT(one+two*x(5)/b+X(5)**2-XN(2)**2-X(4)**2)
       XN(1)=X(1)+(PZS-PZ)/DIR/EL%BN(1)

       XN(3)=(ARCSIN(X(2)/PT)-ARCSIN(XN(2)/PT))/DIR/EL%BN(1)

       XN(6)=X(6)+XN(3)*(one/b+x(5))
       XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL/b

       XN(3)=X(3)+X(4)*XN(3)
    else
       PZ=ROOT((one+X(5))**2-X(2)**2-X(4)**2)
       XN(2)=X(2)-YL*DIR*EL%BN(1)
       PT=ROOT((one+X(5))**2-X(4)**2)
       PZS=ROOT((one+X(5))**2-XN(2)**2-X(4)**2)
       XN(1)=X(1)+(PZS-PZ)/DIR/EL%BN(1)

       XN(3)=(ARCSIN(X(2)/PT)-ARCSIN(XN(2)/PT))/DIR/EL%BN(1)

       XN(6)=X(6)+XN(3)*(one+X(5))
       XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL

       XN(3)=X(3)+X(4)*XN(3)

    endif
    X(1)=XN(1)
    X(2)=XN(2)
    X(3)=XN(3)
    X(6)=XN(6)

  END SUBROUTINE SPARr

  SUBROUTINE SPARP(EL,YL,DL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(REAL_8),INTENT(IN):: YL
    real(dp),INTENT(IN):: DL
    TYPE(STREXP),INTENT(IN):: EL
    TYPE(REAL_8) XN(6),PZ,PZS,PT
    real(dp)  b
    INTEGER DIR

    DIR=EL%P%DIR*EL%P%CHARGE

    CALL ALLOC(XN,6)
    CALL ALLOC(PZ,PZS,PT)

    if(EL%P%TIME) then
       B=EL%P%BETA0
       PZ=SQRT(one+two*x(5)/b+X(5)**2-X(2)**2-X(4)**2)
       XN(2)=X(2)-YL*DIR*EL%BN(1)
       PT=SQRT(one+two*x(5)/b+X(5)**2-X(4)**2)
       PZS=SQRT(one+two*x(5)/b+X(5)**2-XN(2)**2-X(4)**2)
       XN(1)=X(1)+(PZS-PZ)/DIR/EL%BN(1)

       XN(3)=(ASIN(X(2)/PT)-ASIN(XN(2)/PT))/DIR/EL%BN(1)

       XN(6)=X(6)+XN(3)*(one/b+x(5))
       XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL/b

       XN(3)=X(3)+X(4)*XN(3)
    else
       PZ=SQRT((one+X(5))**2-X(2)**2-X(4)**2)
       XN(2)=X(2)-YL*DIR*EL%BN(1)
       PT=SQRT((one+X(5))**2-X(4)**2)
       PZS=SQRT((one+X(5))**2-XN(2)**2-X(4)**2)
       XN(1)=X(1)+(PZS-PZ)/DIR/EL%BN(1)

       XN(3)=(ASIN(X(2)/PT)-ASIN(XN(2)/PT))/DIR/EL%BN(1)

       XN(6)=X(6)+XN(3)*(one+X(5))
       XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL

       XN(3)=X(3)+X(4)*XN(3)

    endif
    X(1)=XN(1)
    X(2)=XN(2)
    X(3)=XN(3)
    X(6)=XN(6)

    CALL KILL(XN,6)
    CALL KILL(PZ,PZS,PT)


  END SUBROUTINE SPARP

  SUBROUTINE SPARS(EL,YL,DL,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(REAL_8),INTENT(IN):: YL
    real(dp),INTENT(IN):: DL
    TYPE(STREXP),INTENT(IN):: EL
    TYPE(REAL_8) X(6),XN(6),PZ,PZS,PT
    real(dp)  b
    INTEGER DIR

    DIR=EL%P%DIR*EL%P%CHARGE

    CALL ALLOC(XN,6)
    CALL ALLOC(X,6)
    CALL ALLOC(PZ,PZS,PT)
    X=Y
    if(EL%P%TIME) then
       B=EL%P%BETA0
       PZ=SQRT(one+two*x(5)/b+X(5)**2-X(2)**2-X(4)**2)
       XN(2)=X(2)-YL*DIR*EL%BN(1)
       PT=SQRT(one+two*x(5)/b+X(5)**2-X(4)**2)
       PZS=SQRT(one+two*x(5)/b+X(5)**2-XN(2)**2-X(4)**2)
       XN(1)=X(1)+(PZS-PZ)/DIR/EL%BN(1)

       XN(3)=(ASIN(X(2)/PT)-ASIN(XN(2)/PT))/DIR/EL%BN(1)

       XN(6)=X(6)+XN(3)*(one/b+x(5))
       XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL/b

       XN(3)=X(3)+X(4)*XN(3)
    else
       PZ=SQRT((one+X(5))**2-X(2)**2-X(4)**2)
       XN(2)=X(2)-YL*DIR*EL%BN(1)
       PT=SQRT((one+X(5))**2-X(4)**2)
       PZS=SQRT((one+X(5))**2-XN(2)**2-X(4)**2)
       XN(1)=X(1)+(PZS-PZ)/DIR/EL%BN(1)

       XN(3)=(ASIN(X(2)/PT)-ASIN(XN(2)/PT))/DIR/EL%BN(1)

       XN(6)=X(6)+XN(3)*(one+X(5))
       XN(6)=XN(6)+(EL%P%TOTALPATH-1)*DL

       XN(3)=X(3)+X(4)*XN(3)

    endif
    X(1)=XN(1)
    X(2)=XN(2)
    X(3)=XN(3)
    X(6)=XN(6)
    Y=X
    CALL KILL(X,6)
    CALL KILL(XN,6)
    CALL KILL(PZ,PZS,PT)


  END SUBROUTINE SPARS

  SUBROUTINE check_root_drift(p,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    type(magnet_chart),intent(in):: p
    real(dp) PZ

    IF(P%EXACT) THEN
       if(P%TIME) then
          PZ=ROOT(one+two*X(5)/P%BETA0+x(5)**2-X(2)**2-X(4)**2)
       else
          PZ=ROOT((one+X(5))**2-X(2)**2-X(4)**2)
       endif
    ENDIF
    !       write(30,*) x(1:5),c_%check_stable
    if(.not.c_%check_stable)x=zero

  END SUBROUTINE check_root_drift


  SUBROUTINE wedger(A,X,EL1,EL2)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    real(dp),INTENT(IN):: A
    TYPE(STREX),optional,INTENT(IN):: EL1
    TYPE(TEAPOT),optional,INTENT(IN):: EL2
    real(dp) XN(6),PZ,PZS,PT,B1
    real(dp)  b
    integer TOTALPATH
    logical(lp) time,EXACT
    EXACT=.TRUE.

    !    if(abs(x(1))+abs(x(3))+abs(x(2))+abs(x(4))>absolute_aperture.or.(.not.CHECK_MADX_APERTURE)) then
    !       if(CHECK_MADX_APERTURE) c_%message="exceed absolute_aperture in wedger"
    !       CHECK_STABLE=.false.
    !    endif
    !    if(.not.CHECK_STABLE) return


    IF(PRESENT(EL1)) THEN
       B1=EL1%P%DIR*EL1%P%CHARGE*EL1%BN(1)
       B=EL1%P%BETA0
       TOTALPATH=EL1%P%TOTALPATH
       time=EL1%P%TIME
       b=EL1%P%BETA0
    ELSEIF(PRESENT(EL2)) THEN
       B1=EL2%P%DIR*EL2%P%CHARGE*EL2%BN(1)
       B=EL2%P%BETA0
       TOTALPATH=EL2%P%TOTALPATH
       time=EL2%P%TIME
       b=EL2%P%BETA0
    ELSE
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       w_p%c(1)= " ERROR IN WEDGER "
       call write_e(101)
    ENDIF

    IF(B1==ZERO) THEN
       call ROT_XZ(A,X,B,EXACT,time)

    ELSE


       if(TIME) then
          PZ=ROOT(one+two*x(5)/b+X(5)**2-X(2)**2-X(4)**2)

          XN(2)=X(2)*COS(A)+(PZ-B1*X(1))*SIN(A)

          PT=ROOT(one+two*x(5)/b+X(5)**2-X(4)**2)
          PZS=ROOT(one+two*x(5)/b+X(5)**2-XN(2)**2-X(4)**2)

          XN(1)=X(1)*COS(A)+(X(1)*X(2)*SIN(two*A)+SIN(A)**2*(two*X(1)*PZ-B1*X(1)**2) )&
               & /(PZS+PZ*COS(A)-X(2)*SIN(A))
          XN(3)=(A+ARCSIN(X(2)/PT)-ARCSIN(XN(2)/PT))/B1

          XN(6)=X(6)+XN(3)*(one/b+x(5))

          XN(3)=X(3)+X(4)*XN(3)
       else
          PZ=ROOT((one+X(5))**2-X(2)**2-X(4)**2)
          XN(2)=X(2)*COS(A)+(PZ-B1*X(1))*SIN(A)
          PT=ROOT((one+X(5))**2-X(4)**2)
          PZS=ROOT((one+X(5))**2-XN(2)**2-X(4)**2)
          XN(1)=X(1)*COS(A)+(X(1)*X(2)*SIN(two*A)+SIN(A)**2*(two*X(1)*PZ-B1*X(1)**2))&
               & /(PZS+PZ*COS(A)-X(2)*SIN(A))

          XN(3)=(A+ARCSIN(X(2)/PT)-ARCSIN(XN(2)/PT))/B1

          XN(6)=X(6)+XN(3)*(one+X(5))

          XN(3)=X(3)+X(4)*XN(3)

       endif
       X(1)=XN(1)
       X(2)=XN(2)
       X(3)=XN(3)
       X(6)=XN(6)
    ENDIF
    !    CALL CHECK_STABILITY(X)

  END SUBROUTINE wedger


  SUBROUTINE wedgeP(A,X,EL1,EL2)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    real(dp),INTENT(IN):: A
    TYPE(STREXP),optional,INTENT(IN):: EL1
    TYPE(TEAPOTP),optional,INTENT(IN):: EL2
    TYPE(REAL_8) XN(6),PZ,PZS,PT,B1
    real(dp)  b
    integer TOTALPATH
    logical(lp) time,EXACT
    EXACT=.TRUE.

    CALL ALLOC(PZ,PZS,PT,B1)
    CALL ALLOC(XN,6)


    IF(PRESENT(EL1)) THEN
       B1=EL1%P%DIR*EL1%P%CHARGE*EL1%BN(1)
       B=EL1%P%BETA0
       TOTALPATH=EL1%P%TOTALPATH
       time=EL1%P%TIME
       b=EL1%P%BETA0
    ELSEIF(PRESENT(EL2)) THEN
       B1=EL2%P%DIR*EL2%P%CHARGE*EL2%BN(1)
       B=EL2%P%BETA0
       TOTALPATH=EL2%P%TOTALPATH
       time=EL2%P%TIME
       b=EL2%P%BETA0
    ELSE
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       w_p%c(1)= " ERROR IN WEDGEP "
       call write_e(102)
    ENDIF

    IF(B1==ZERO) THEN
       call ROT_XZ(A,X,B,EXACT,time)

    ELSE

       if(TIME) then
          PZ=SQRT(one+two*x(5)/b+X(5)**2-X(2)**2-X(4)**2)
          XN(2)=X(2)*COS(A)+(PZ-B1*X(1))*SIN(A)
          PT=SQRT(one+two*x(5)/b+X(5)**2-X(4)**2)
          PZS=SQRT(one+two*x(5)/b+X(5)**2-XN(2)**2-X(4)**2)
          XN(1)=X(1)*COS(A)+(X(1)*X(2)*SIN(two*A)+SIN(A)**2*(two*X(1)*PZ-B1*X(1)**2))&
               & /(PZS+PZ*COS(A)-X(2)*SIN(A))

          XN(3)=(A+ASIN(X(2)/PT)-ASIN(XN(2)/PT))/B1

          XN(6)=X(6)+XN(3)*(one/b+x(5))

          XN(3)=X(3)+X(4)*XN(3)
       else
          PZ=SQRT((one+X(5))**2-X(2)**2-X(4)**2)
          XN(2)=X(2)*COS(A)+(PZ-B1*X(1))*SIN(A)
          PT=SQRT((one+X(5))**2-X(4)**2)
          PZS=SQRT((one+X(5))**2-XN(2)**2-X(4)**2)
          XN(1)=X(1)*COS(A)+(X(1)*X(2)*SIN(two*A)+SIN(A)**2*(two*X(1)*PZ-B1*X(1)**2))&
               & /(PZS+PZ*COS(A)-X(2)*SIN(A))

          XN(3)=(A+ASIN(X(2)/PT)-ASIN(XN(2)/PT))/B1

          XN(6)=X(6)+XN(3)*(one+X(5))

          XN(3)=X(3)+X(4)*XN(3)

       endif
       X(1)=XN(1)
       X(2)=XN(2)
       X(3)=XN(3)
       X(6)=XN(6)
    ENDIF
    CALL KILL(PZ,PZS,PT,B1)
    CALL KILL(XN,6)

  END SUBROUTINE wedgeP

  SUBROUTINE wedgeS(A,y,EL1,EL2)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(REAL_8)  X(6)
    real(dp),INTENT(IN):: A
    TYPE(STREXP),optional,INTENT(IN):: EL1
    TYPE(TEAPOTP),optional,INTENT(IN):: EL2
    TYPE(REAL_8) XN(6),PZ,PZS,PT,B1
    real(dp)  b
    integer TOTALPATH
    logical(lp) time,EXACT
    EXACT=.TRUE.


    CALL ALLOC(PZ,PZS,PT,B1)
    CALL ALLOC(XN,6)
    CALL ALLOC(X,6)

    X=Y
    IF(PRESENT(EL1)) THEN
       B1=EL1%P%DIR*EL1%P%CHARGE*EL1%BN(1)
       B=EL1%P%BETA0
       TOTALPATH=EL1%P%TOTALPATH
       time=EL1%P%TIME
       b=EL1%P%BETA0
    ELSEIF(PRESENT(EL2)) THEN
       B1=EL2%P%DIR*EL2%P%CHARGE*EL2%BN(1)
       B=EL2%P%BETA0
       TOTALPATH=EL2%P%TOTALPATH
       time=EL2%P%TIME
       b=EL2%P%BETA0
    ELSE
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       w_p%c(1)= " ERROR IN WEDGES "
       call write_e(103)
    ENDIF

    IF(B1==ZERO) THEN
       call ROT_XZ(A,X,B,EXACT,time)

    ELSE

       if(TIME) then
          PZ=SQRT(one+two*x(5)/b+X(5)**2-X(2)**2-X(4)**2)
          XN(2)=X(2)*COS(A)+(PZ-B1*X(1))*SIN(A)
          PT=SQRT(one+two*x(5)/b+X(5)**2-X(4)**2)
          PZS=SQRT(one+two*x(5)/b+X(5)**2-XN(2)**2-X(4)**2)
          XN(1)=X(1)*COS(A)+(X(1)*X(2)*SIN(two*A)+SIN(A)**2*(two*X(1)*PZ-B1*X(1)**2))&
               & /(PZS+PZ*COS(A)-X(2)*SIN(A))

          XN(3)=(A+ASIN(X(2)/PT)-ASIN(XN(2)/PT))/B1

          XN(6)=X(6)+XN(3)*(one/b+x(5))

          XN(3)=X(3)+X(4)*XN(3)
       else
          PZ=SQRT((one+X(5))**2-X(2)**2-X(4)**2)
          XN(2)=X(2)*COS(A)+(PZ-B1*X(1))*SIN(A)
          PT=SQRT((one+X(5))**2-X(4)**2)
          PZS=SQRT((one+X(5))**2-XN(2)**2-X(4)**2)
          XN(1)=X(1)*COS(A)+(X(1)*X(2)*SIN(two*A)+SIN(A)**2*(two*X(1)*PZ-B1*X(1)**2))&
               & /(PZS+PZ*COS(A)-X(2)*SIN(A))

          XN(3)=(A+ASIN(X(2)/PT)-ASIN(XN(2)/PT))/B1

          XN(6)=X(6)+XN(3)*(one+X(5))

          XN(3)=X(3)+X(4)*XN(3)

       endif
       X(1)=XN(1)
       X(2)=XN(2)
       X(3)=XN(3)
       X(6)=XN(6)

    ENDIF
    Y=X

    CALL KILL(PZ,PZS,PT,B1)
    CALL KILL(XN,6)
    CALL KILL(X,6)

  END SUBROUTINE wedgeS

  !  CAV_TRAV

  SUBROUTINE CAVER_TRAV(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: MID
    TYPE(CAV_TRAV),INTENT(INOUT):: EL
    real(dp) D1
    real(dp) DF(4),DK(4),DDF(4)
    INTEGER I,J
    REAL(DP) Z0
    INTEGER TOTALPATH

    !    IF(EL%P%FRINGE)
    CALL FRINGECAV_TRAV(EL,EL%P%DIR,X)

    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    IF(EL%P%DIR==1) THEN
       Z0=ZERO
    ELSE
       Z0=EL%L
    ENDIF
    TOTALPATH=EL%P%TOTALPATH
    EL%P%TOTALPATH=1
    SELECT CASE(EL%P%METHOD)
    CASE(2)
       D1=EL%L/EL%P%NST
       DO I=1,EL%P%NST
          call rk2_cav(z0,d1,el,x)
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO
    CASE(4)

       D1=EL%L/EL%P%NST
       DO I=1,EL%P%NST
          call rk4_cav(z0,d1,el,x)
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO

    CASE(6)

       D1=EL%L/EL%P%NST
       DO I=1,EL%P%NST
          call rk6_cav(z0,d1,el,x)
          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO

    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

    !    IF(EL%P%FRINGE)
    CALL FRINGECAV_TRAV(EL,-EL%P%DIR,X)

    EL%P%TOTALPATH=TOTALPATH

    if(EL%P%TIME) then
       X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/EL%P%BETA0
    else
       X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD
    endif

  END SUBROUTINE CAVER_TRAV

  SUBROUTINE CAVEP_TRAV(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: MID
    TYPE(CAV_TRAVP),INTENT(INOUT):: EL
    TYPE(REAL_8) D1
    INTEGER I,J
    TYPE(REAL_8) Z0
    INTEGER TOTALPATH

    CALL ALLOC(Z0)

    !    IF(EL%P%FRINGE)
    CALL FRINGECAV_TRAV(EL,EL%P%DIR,X)
    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    IF(EL%P%DIR==1) THEN
       Z0=ZERO
    ELSE
       Z0=EL%L
    ENDIF
    TOTALPATH=EL%P%TOTALPATH
    EL%P%TOTALPATH=1

    SELECT CASE(EL%P%METHOD)

    CASE(2)
       CALL ALLOC(D1)

       D1=EL%L/EL%P%NST
       DO I=1,EL%P%NST
          call rk2_cav(z0,d1,el,x)
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO

       CALL KILL(D1)
    CASE(4)
       CALL ALLOC(D1)

       D1=EL%L/EL%P%NST
       DO I=1,EL%P%NST
          call rk4_cav(z0,d1,el,x)
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO

       CALL KILL(D1)

    CASE(6)
       CALL ALLOC(D1)

       D1=EL%L/EL%P%NST
       DO I=1,EL%P%NST
          call rk6_cav(z0,d1,el,x)
          !          IF(PRESENT(MID)) CALL XMID(MID,X,I)
       ENDDO

       CALL KILL(D1)




    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT

    !    IF(EL%P%FRINGE)
    CALL FRINGECAV_TRAV(EL,-EL%P%DIR,X)

    EL%P%TOTALPATH=TOTALPATH

    if(EL%P%TIME) then
       X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD/EL%P%BETA0
    else
       X(6)=X(6)-(1-EL%P%TOTALPATH)*EL%P%LD
    endif

    CALL KILL(Z0)

  END SUBROUTINE CAVEP_TRAV


  SUBROUTINE CAVES_TRAV(EL,X)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: X(6)
    TYPE(CAV_TRAVP),INTENT(INOUT):: EL
    TYPE(REAL_8) Y(6)

    CALL ALLOC(Y)
    Y=X
    CALL TRACK(EL,Y)
    X=Y
    CALL KILL(Y)

  END SUBROUTINE CAVES_TRAV





  SUBROUTINE FRINGECAVR_TRAV(EL,I,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(CAV_TRAV),INTENT(INOUT):: EL
    integer, intent(in) :: i
    real(dp) C1,S1,C2,S2,V,O,Z0,CPSI,SPSI
    integer eps1,eps2
    real(dp) dv

    IF(EL%P%NOCAVITY) RETURN

    !    IF(I==1.AND.EL%P%KILL_ENT_FRINGE) RETURN
    !    IF(I==-1.AND.EL%P%KILL_EXI_FRINGE) RETURN
    eps1=1
    eps2=-1
    if(EL%P%DIR*I==1) then
       Z0=ZERO
       dv=zero
    else
       Z0=EL%L
       dv=EL%dvds*z0
    endif

    CPSI=COS(EL%PSI)
    SPSI=SIN(EL%PSI)

    O=EL%freq*twopi/CLIGHT
    C1=(eps1+(EL%P%DIR-eps1)*half)*COS(O*(x(6)-Z0)+EL%PHAS+phase0)
    C2=(eps2+(EL%P%DIR-eps2)*half)*COS(O*(x(6)+Z0)+EL%PHAS+phase0+EL%DPHAS)
    ! REMOVE FRINGE IN OPPOSITE DIRECTION  ULTRA RELATIVISTIC
    S1=(eps1+(EL%P%DIR-eps1)*half)*SIN(O*(x(6)-Z0)+EL%PHAS+phase0)
    S2=(eps2+(EL%P%DIR-eps2)*half)*SIN(O*(x(6)+Z0)+EL%PHAS+phase0+EL%DPHAS)
    ! REMOVE FRINGE IN OPPOSITE DIRECTION   ULTRA RELATIVISTIC
    V=I*EL%P%CHARGE*(EL%volt-dv)*c_1d_3/EL%P%P0C

    X(2)=X(2)+V*(CPSI*S1+SPSI*S2)*X(1)
    X(4)=X(4)+V*(CPSI*S1+SPSI*S2)*X(3)
    x(5)=x(5)-HALF*(X(1)**2+X(3)**2)*V*(CPSI*C1+SPSI*C2)*O

  END SUBROUTINE FRINGECAVR_TRAV

  SUBROUTINE FRINGECAVP_TRAV(EL,I,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(CAV_TRAVP),INTENT(INOUT):: EL
    integer, intent(in) :: i
    TYPE(REAL_8) C1,S1,C2,S2,V,O,Z0,F,CPSI,SPSI,dv
    integer eps1,eps2


    IF(EL%P%NOCAVITY) RETURN

    !    IF(I==1.AND.EL%P%KILL_ENT_FRINGE) RETURN
    !    IF(I==-1.AND.EL%P%KILL_EXI_FRINGE) RETURN

    CALL ALLOC(C1,S1,C2,S2,V,O,Z0,F,CPSI,SPSI)
    call alloc(dv)

    eps1=1
    eps2=-1
    if(EL%P%DIR*I==1) then
       Z0=ZERO
       dv=zero
    else
       Z0=EL%L
       dv=EL%dvds*z0
    endif

    CPSI=COS(EL%PSI)
    SPSI=SIN(EL%PSI)

    O=EL%freq*twopi/CLIGHT
    C1=(eps1+(EL%P%DIR-eps1)*half)*COS(O*(x(6)-Z0)+EL%PHAS+phase0)
    C2=(eps2+(EL%P%DIR-eps2)*half)*COS(O*(x(6)+Z0)+EL%PHAS+phase0+EL%DPHAS)
    ! REMOVE FRINGE IN OPPOSITE DIRECTION  ULTRA RELATIVISTIC
    S1=(eps1+(EL%P%DIR-eps1)*half)*SIN(O*(x(6)-Z0)+EL%PHAS+phase0)
    S2=(eps2+(EL%P%DIR-eps2)*half)*SIN(O*(x(6)+Z0)+EL%PHAS+phase0+EL%DPHAS)
    ! REMOVE FRINGE IN OPPOSITE DIRECTION   ULTRA RELATIVISTIC
    V=I*EL%P%CHARGE*(EL%volt-dv)*c_1d_3/EL%P%P0C

    X(2)=X(2)+V*(CPSI*S1+SPSI*S2)*X(1)
    X(4)=X(4)+V*(CPSI*S1+SPSI*S2)*X(3)
    x(5)=x(5)-HALF*(X(1)**2+X(3)**2)*V*(CPSI*C1+SPSI*C2)*O

    call KILL(dv)
    CALL KILL(C1,S1,C2,S2,V,O,Z0,F,CPSI,SPSI)
  END SUBROUTINE FRINGECAVP_TRAV

  SUBROUTINE FRINGECAVS_TRAV(EL,I,Y)
    IMPLICIT NONE
    TYPE(ENV_8),INTENT(INOUT):: Y(6)
    TYPE(REAL_8)  X(6)
    TYPE(CAV_TRAVP),INTENT(INOUT):: EL
    integer, intent(in) :: i

    CALL ALLOC(X)
    X=Y
    CALL FRINGECAV_TRAV(EL,I,X)
    Y=X

    CALL KILL(X)
  END SUBROUTINE FRINGECAVS_TRAV

  SUBROUTINE ZEROR_CAV_TRAV(EL,I)
    IMPLICIT NONE
    TYPE(CAV_TRAV), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%DPHAS)) then
          deallocate(EL%PSI)
          deallocate(EL%DPHAS)
          deallocate(EL%DVDS)
       endif
    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%PSI)
       NULLIFY(EL%DPHAS)
       NULLIFY(EL%DVDS)
    endif

  END SUBROUTINE ZEROR_CAV_TRAV

  SUBROUTINE ZEROP_CAV_TRAV(EL,I)
    IMPLICIT NONE
    TYPE(CAV_TRAVP), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%DPHAS)) then
          CALL KILL(EL%DPHAS)
          deallocate(EL%DPHAS)
          CALL KILL(EL%PSI)
          deallocate(EL%PSI)
          CALL KILL(EL%DVDS)
          deallocate(EL%DVDS)
       endif
    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%DPHAS)
       NULLIFY(EL%PSI)
       NULLIFY(EL%DVDS)
    endif

  END SUBROUTINE ZEROP_CAV_TRAV


  SUBROUTINE ZEROr_SOL(EL,I)
    IMPLICIT NONE
    TYPE(SOLT), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%MAT)) then
          deallocate(EL%MAT)
          deallocate(EL%LXY)
       endif

    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%MAT)
       NULLIFY(EL%LXY)
    endif

  END SUBROUTINE ZEROr_SOL

  SUBROUTINE ZEROP_SOL(EL,I)
    IMPLICIT NONE
    TYPE(SOLTP), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k,j
    IF(I==-1) THEN
       if(ASSOCIATED(EL%MAT)) then
          deallocate(EL%MAT)
          deallocate(EL%LXY)
       endif

    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%MAT)
       NULLIFY(EL%LXY)
    endif

  END SUBROUTINE ZEROP_SOL

  SUBROUTINE ZEROr_mon(EL,I)
    IMPLICIT NONE
    TYPE(MON), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%x)) deallocate(EL%x)
       if(ASSOCIATED(EL%y)) deallocate(EL%y)

    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%x)
       NULLIFY(EL%y)

    endif


  END SUBROUTINE ZEROr_mon

  SUBROUTINE ZEROP_mon(EL,I)
    IMPLICIT NONE
    TYPE(MONP), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k,j
    IF(I==-1) THEN
       if(ASSOCIATED(EL%x)) deallocate(EL%x)
       if(ASSOCIATED(EL%y)) deallocate(EL%y)

    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%x)
       NULLIFY(EL%y)

    endif

  END SUBROUTINE ZEROP_mon

  SUBROUTINE ZEROr_RCOL(EL,I)
    IMPLICIT NONE
    TYPE(RCOL), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%A)) THEN
          CALL KILL(EL%A)
          deallocate(EL%A)
       ENDIF

    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%A)

    endif


  END SUBROUTINE ZEROr_RCOL

  SUBROUTINE ZEROP_RCOL(EL,I)
    IMPLICIT NONE
    TYPE(RCOLP), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k,j
    IF(I==-1) THEN
       if(ASSOCIATED(EL%A)) THEN
          CALL KILL(EL%A)
          deallocate(EL%A)
       ENDIF

    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%A)

    endif

  END SUBROUTINE ZEROP_RCOL


  SUBROUTINE ZEROr_ECOL(EL,I)
    IMPLICIT NONE
    TYPE(ECOL), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%A)) THEN
          CALL KILL(EL%A)
          deallocate(EL%A)
       ENDIF

    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%A)

    endif

  END SUBROUTINE ZEROr_ECOL

  SUBROUTINE ZEROP_ECOL(EL,I)
    IMPLICIT NONE
    TYPE(ECOLP), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k,j
    IF(I==-1) THEN
       if(ASSOCIATED(EL%A)) THEN
          CALL KILL(EL%A)
          deallocate(EL%A)
       ENDIF

    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%A)

    endif

  END SUBROUTINE ZEROP_ECOL


  SUBROUTINE ZERO_MARTIN(EL,I)
    IMPLICIT NONE
    TYPE(MARTIN), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%T)) then
          CALL KILL(EL%T)
          deallocate(EL%T)
       endif
       if(ASSOCIATED(EL%T_RAD)) then
          CALL KILL(EL%T_RAD)
          deallocate(EL%T_RAD)
       endif
       if(ASSOCIATED(EL%T_REV)) then
          CALL KILL(EL%T_REV)
          deallocate(EL%T_REV)
       endif
       if(ASSOCIATED(EL%T_RAD_REV)) then
          CALL KILL(EL%T_RAD_REV)
          deallocate(EL%T_RAD_REV)
       endif

       if(ASSOCIATED(EL%DELTAMAP)) then
          deallocate(EL%DELTAMAP)
       endif
       if(ASSOCIATED(EL%E)) then
          deallocate(EL%E)
       endif
       if(ASSOCIATED(EL%E_REV)) then
          deallocate(EL%E_REV)
       endif

    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%T)
       NULLIFY(EL%T_RAD)
       NULLIFY(EL%DELTAMAP)
       NULLIFY(EL%T_REV)
       NULLIFY(EL%T_RAD_REV)
       NULLIFY(EL%DELTAMAP)
       NULLIFY(EL%E)
       NULLIFY(EL%E_REV)
    endif

  END SUBROUTINE ZERO_MARTIN

  ! TYPE multip



  SUBROUTINE ZEROr_KTK(EL,I)
    IMPLICIT NONE
    TYPE(KTK), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%MATX)) then
          deallocate(EL%MATX)
          deallocate(EL%LX)
       endif
       if(ASSOCIATED(EL%MATY)) then
          deallocate(EL%MATY)
          deallocate(EL%LY)
       endif

    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%MATX)
       NULLIFY(EL%MATY)
       NULLIFY(EL%LX)
       NULLIFY(EL%LY)
    endif

  END SUBROUTINE ZEROr_KTK

  SUBROUTINE ZEROP_KTK(EL,I)
    IMPLICIT NONE
    TYPE(KTKP), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k,j
    IF(I==-1) THEN
       if(ASSOCIATED(EL%MATX)) then
          deallocate(EL%MATX)
          deallocate(EL%LX)
       endif
       if(ASSOCIATED(EL%MATY)) then
          deallocate(EL%MATY)
          deallocate(EL%LY)
       endif

    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%MATX)
       NULLIFY(EL%MATY)
       NULLIFY(EL%LX)
       NULLIFY(EL%LY)

    endif

  END SUBROUTINE ZEROP_KTK

  SUBROUTINE ALLOCKTK(EL)
    IMPLICIT NONE
    TYPE(KTKP), INTENT(INOUT)::EL
    INTEGER I,J

    DO I=1,2
       DO J=1,3
          CALL ALLOC(EL%MATX(I,J))
          CALL ALLOC(EL%MATY(I,J))
       ENDDO
    ENDDO

    DO I=1,6
       CALL ALLOC(EL%LX(I))
    ENDDO
    DO I=1,3
       CALL ALLOC(EL%LY(I))
    ENDDO

  END SUBROUTINE ALLOCKTK

  SUBROUTINE KILLKTK(EL)
    IMPLICIT NONE
    TYPE(KTKP), INTENT(INOUT)::EL
    INTEGER I,J

    DO I=1,2
       DO J=1,3
          CALL KILL(EL%MATX(I,J))
          CALL KILL(EL%MATY(I,J))
       ENDDO
    ENDDO

    DO I=1,6
       CALL KILL(EL%LX(I))
    ENDDO
    DO I=1,3
       CALL KILL(EL%LY(I))
    ENDDO

  END SUBROUTINE KILLKTK

  SUBROUTINE ZEROr_TKT7(EL,I)
    IMPLICIT NONE
    TYPE(TKTF), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%MATX)) then
          deallocate(EL%MATX)
       endif
       if(ASSOCIATED(EL%MATY)) then
          deallocate(EL%MATY)
       endif
       if(ASSOCIATED(EL%LX)) then
          deallocate(EL%LX)
       endif
       if(ASSOCIATED(EL%RMATX)) then
          deallocate(EL%RMATX)
       endif
       if(ASSOCIATED(EL%RMATY)) then
          deallocate(EL%RMATY)
       endif
       if(ASSOCIATED(EL%RLX)) then
          deallocate(EL%RLX)
       endif
    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%MATX)
       NULLIFY(EL%MATY)
       NULLIFY(EL%LX)
       NULLIFY(EL%RMATX)
       NULLIFY(EL%RMATY)
       NULLIFY(EL%RLX)
    endif

  END SUBROUTINE ZEROr_TKT7

  SUBROUTINE ZEROP_TKT7(EL,I)
    IMPLICIT NONE
    TYPE(TKTFP), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    integer k,j

    IF(I==-1) THEN
       if(ASSOCIATED(EL%MATX)) then
          DO K=1,2
             DO J=1,3
                CALL KILL(EL%MATX(K,J))   ! not used, will be used locally only
             ENDDO
          ENDDO
          deallocate(EL%MATX)
       endif
       if(ASSOCIATED(EL%MATY)) then
          DO K=1,2
             DO J=1,3
                CALL KILL(EL%MATY(K,J))   ! not used, will be used locally only
             ENDDO
          ENDDO
          deallocate(EL%MATY)
       endif

       if(ASSOCIATED(EL%LX)) then
          DO J=1,3
             CALL KILL(EL%LX(J))   ! not used, will be used locally only
          ENDDO
          deallocate(EL%LX)
       endif
       if(ASSOCIATED(EL%RMATX)) then
          DO K=1,2
             DO J=1,3
                CALL KILL(EL%RMATX(K,J))   ! not used, will be used locally only
             ENDDO
          ENDDO
          deallocate(EL%RMATX)
       endif
       if(ASSOCIATED(EL%RMATY)) then
          DO K=1,2
             DO J=1,3
                CALL KILL(EL%RMATY(K,J))   ! not used, will be used locally only
             ENDDO
          ENDDO
          deallocate(EL%RMATY)
       endif

       if(ASSOCIATED(EL%RLX)) then
          DO J=1,3
             CALL KILL(EL%RLX(J))   ! not used, will be used locally only
          ENDDO
          deallocate(EL%RLX)
       endif

    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%MATX)
       NULLIFY(EL%MATY)
       NULLIFY(EL%LX)
       NULLIFY(EL%RMATX)
       NULLIFY(EL%RMATY)
       NULLIFY(EL%RLX)

    endif

  END SUBROUTINE ZEROP_TKT7

  SUBROUTINE ALLOCTKT7(EL)
    IMPLICIT NONE
    TYPE(TKTFP), INTENT(INOUT)::EL
    INTEGER I,J

    DO I=1,2
       DO J=1,3
          CALL ALLOC(EL%MATX(I,J))
          CALL ALLOC(EL%MATY(I,J))
          CALL ALLOC(EL%RMATX(I,J))
          CALL ALLOC(EL%RMATY(I,J))
       ENDDO
    ENDDO

    DO I=1,3
       CALL ALLOC(EL%LX(I))
       CALL ALLOC(EL%RLX(I))
    ENDDO

  END SUBROUTINE ALLOCTKT7

  SUBROUTINE KILLTKT7(EL)
    IMPLICIT NONE
    TYPE(TKTFP), INTENT(INOUT)::EL
    INTEGER I,J

    DO I=1,2
       DO J=1,3
          CALL KILL(EL%MATX(I,J))
          CALL KILL(EL%MATY(I,J))
          CALL KILL(EL%RMATX(I,J))
          CALL KILL(EL%RMATY(I,J))
       ENDDO
    ENDDO
    DO I=1,3
       CALL KILL(EL%LX(I))
       CALL KILL(EL%RLX(I))
    ENDDO

  END SUBROUTINE KILLTKT7

  SUBROUTINE ZEROr_teapot(EL,I)
    IMPLICIT NONE
    TYPE(TEAPOT), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%bf_x)) then
          deallocate(EL%bf_x)
       endif
       if(ASSOCIATED(EL%bf_y)) then
          deallocate(EL%bf_y)
       endif
       if(ASSOCIATED(EL%DRIFTKICK)) then
          deallocate(EL%DRIFTKICK)
       endif
    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%bf_x)
       NULLIFY(EL%bf_y)
       NULLIFY(EL%DRIFTKICK)
    endif

  END SUBROUTINE ZEROr_teapot

  SUBROUTINE ZEROP_teapot(EL,I)
    IMPLICIT NONE
    TYPE(TEAPOTP), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I

    IF(I==-1) THEN
       if(ASSOCIATED(EL%bf_x)) then
          CALL KILL(EL%bf_x,S_B(SECTOR_NMUL)%N_MONO)   ! not used, will be used locally only
          !          CALL KILL(EL%bf_x,S_B(EL%P%NMUL)%N_MONO)   ! not used, will be used locally only
          deallocate(EL%bf_x)
       endif
       if(ASSOCIATED(EL%bf_Y)) then
          CALL KILL(EL%bf_Y,S_B(SECTOR_NMUL)%N_MONO)   ! not used, will be used locally only
          !          CALL KILL(EL%bf_Y,S_B(EL%P%NMUL)%N_MONO)   ! not used, will be used locally only
          deallocate(EL%bf_Y)
       endif
       if(ASSOCIATED(EL%DRIFTKICK)) then
          deallocate(EL%DRIFTKICK)
       endif

    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%bf_x)
       NULLIFY(EL%bf_Y)
       NULLIFY(EL%DRIFTKICK)

    endif

  END SUBROUTINE ZEROP_teapot

  SUBROUTINE ZEROR_CAV4(EL,I)
    IMPLICIT NONE
    TYPE(CAV4), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%N_BESSEL)) then
          deallocate(EL%N_BESSEL)
       endif
    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%N_BESSEL)
    endif

  END SUBROUTINE ZEROR_CAV4

  SUBROUTINE ZEROP_CAV4(EL,I)
    IMPLICIT NONE
    TYPE(CAV4P), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%N_BESSEL)) then
          deallocate(EL%N_BESSEL)
       endif
    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%N_BESSEL)
    endif

  END SUBROUTINE ZEROP_CAV4

  SUBROUTINE ZEROR_KICKT3(EL,I)
    IMPLICIT NONE
    TYPE(KICKT3), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%thin_h_foc)) then
          deallocate(EL%thin_h_foc)
          deallocate(EL%thin_v_foc)
          deallocate(EL%thin_h_angle)
          deallocate(EL%thin_v_angle)
       endif
    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%thin_h_foc)
       NULLIFY(EL%thin_v_foc)
       NULLIFY(EL%thin_h_angle)
       NULLIFY(EL%thin_v_angle)
    endif

  END SUBROUTINE ZEROR_KICKT3

  SUBROUTINE ZEROP_KICKT3(EL,I)
    IMPLICIT NONE
    TYPE(KICKT3P), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%thin_h_foc)) then
          CALL KILL(EL%thin_h_foc)
          CALL KILL(EL%thin_v_foc)
          CALL KILL(EL%thin_h_angle)
          CALL KILL(EL%thin_v_angle)

          deallocate(EL%thin_h_foc)
          deallocate(EL%thin_v_foc)
          deallocate(EL%thin_h_angle)
          deallocate(EL%thin_v_angle)
       endif
    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%thin_h_foc)
       NULLIFY(EL%thin_v_foc)
       NULLIFY(EL%thin_h_angle)
       NULLIFY(EL%thin_v_angle)
    endif

  END SUBROUTINE ZEROP_KICKT3


  SUBROUTINE ZEROr_STREX(EL,I)
    IMPLICIT NONE
    TYPE(STREX), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%DRIFTKICK)) then
          deallocate(EL%DRIFTKICK)
       endif
       if(ASSOCIATED(EL%LIKEMAD)) then
          deallocate(EL%LIKEMAD)
       endif
    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%DRIFTKICK)
       NULLIFY(EL%LIKEMAD)
    endif

  END SUBROUTINE ZEROr_STREX

  SUBROUTINE ZEROP_STREX(EL,I)
    IMPLICIT NONE
    TYPE(STREXP), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%DRIFTKICK)) then
          deallocate(EL%DRIFTKICK)
       endif
       if(ASSOCIATED(EL%LIKEMAD)) then
          deallocate(EL%LIKEMAD)
       endif
       NULLIFY(EL%LIKEMAD)
    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%DRIFTKICK)
    endif

  END SUBROUTINE ZEROP_STREX


  SUBROUTINE ALLOCTEAPOT(EL)
    IMPLICIT NONE
    TYPE(TEAPOTP), INTENT(INOUT)::EL

    CALL ALLOC(EL%bf_x,S_B(EL%P%NMUL)%N_MONO)
    CALL ALLOC(EL%bf_Y,S_B(EL%P%NMUL)%N_MONO)

  END SUBROUTINE ALLOCTEAPOT

  SUBROUTINE KILLTEAPOT(EL)
    IMPLICIT NONE
    TYPE(TEAPOTP), INTENT(INOUT)::EL

    CALL KILL(EL%bf_x,S_B(EL%P%NMUL)%N_MONO)
    CALL KILL(EL%bf_Y,S_B(EL%P%NMUL)%N_MONO)

  END SUBROUTINE KILLTEAPOT
  SUBROUTINE ALLOCSOL(EL)
    IMPLICIT NONE
    TYPE(SOLTP), INTENT(INOUT)::EL
    INTEGER I,J

    DO I=1,4
       DO J=1,4
          CALL ALLOC(EL%MAT(I,J))
       ENDDO
    ENDDO

    DO I=0,10
       CALL ALLOC(EL%LXY(I))
    ENDDO

  END SUBROUTINE ALLOCSOL

  SUBROUTINE KILLSOL(EL)
    IMPLICIT NONE
    TYPE(SOLTP), INTENT(INOUT)::EL
    INTEGER I,J

    DO I=1,4
       DO J=1,4
          CALL KILL(EL%MAT(I,J))
       ENDDO
    ENDDO

    DO I=0,10
       CALL KILL(EL%LXY(I))
    ENDDO

  END SUBROUTINE KILLSOL




  subroutine fxr(f,x,b,p)
    implicit none

    real(dp)  d(3),c(6),BETA0,GAMMA0I,hcurv,b2
    real(dp) ,intent(in) :: b(3)
    type(MAGNET_CHART), pointer:: p
    real(dp) ,intent(inout) :: x(6)
    real(dp), intent(out):: f(6)

    if(p%time) then
       beta0=p%beta0;GAMMA0I=p%GAMMA0I;
    else
       beta0=one;GAMMA0I=zero;
    endif

    hcurv=p%b0

    d(1)=root(x(2)**2+x(4)**2+(one+hcurv*x(1))**2)
    d(2)=(d(1)**3)/root(one+2*x(5)/beta0+x(5)**2)
    d(3)=one+hcurv*x(1)

    c(1)=d(1)**2-x(2)**2
    c(2)=-x(2)*x(4)
    c(3)= x(2)*x(4)
    c(4)=-d(1)**2+x(4)**2
    c(5)=d(2)*(x(4)*b(3)-d(3)*b(2)) +hcurv*d(3)*(d(1)**2+x(2)**2)
    c(6)=d(2)*(x(2)*b(3)-d(3)*b(1)) -hcurv*d(3)*c(3)

    d(3)=c(1)*c(4)-c(2)*c(3)
    f(1)=x(2)
    f(2)=(c(4)*c(5)-c(2)*c(6))/d(3)
    f(3)=x(4)
    f(4)=(c(1)*c(6)-c(3)*c(5))/d(3)
    d(2)=one+two*x(5)/beta0+x(5)**2
    d(2)=gamma0I/beta0/d(2)
    f(6)=root((1+d(2)**2))*d(1)  ! (time)-prime = dt/dz

    if(p%radiation) then
       !    d(1)=root(x(2)**2+x(4)**2+(one+hcurv*x(1))**2)
       c(1)=x(2)/d(1)
       c(2)=x(4)/d(1)
       c(3)=one/d(1)
       B2=zero
       B2=(B(2)*c(3)-B(3)*c(2))**2+B2
       B2=(B(1)*c(2)-B(2)*c(1))**2+B2
       B2=(B(3)*c(1)-B(1)*c(3))**2+B2
       f(5)=-CRADF(P)*(one+X(5))**2*B2*f(6)
    else
       f(5)=zero
    endif


  end subroutine fxr

  subroutine fxp(f,x,b,p)
    implicit none

    type(real_8)  d(3),c(6),b2
    type(real_8) ,intent(inout) :: x(6)
    type(real_8) ,intent(in) :: b(3)
    real(dp)   BETA0,GAMMA0I,hcurv
    type(real_8), intent(out):: f(6)
    type(MAGNET_CHART), pointer:: p

    call alloc(d,3)
    call alloc(c,6)
    hcurv=p%b0
    if(p%time) then
       beta0=p%beta0;GAMMA0I=p%GAMMA0I;
    else
       beta0=one;GAMMA0I=zero;
    endif

    d(1)=SQRT(x(2)**2+x(4)**2+(one+hcurv*x(1))**2)
    d(2)=(d(1)**3)/SQRT(one+2*x(5)/beta0+x(5)**2)
    d(3)=one+hcurv*x(1)

    c(1)=d(1)**2-x(2)**2
    c(2)=-x(2)*x(4)
    c(3)= x(2)*x(4)
    c(4)=-d(1)**2+x(4)**2
    c(5)=d(2)*(x(4)*b(3)-d(3)*b(2)) +hcurv*d(3)*(d(1)**2+x(2)**2)
    c(6)=d(2)*(x(2)*b(3)-d(3)*b(1)) -hcurv*d(3)*c(3)

    d(3)=c(1)*c(4)-c(2)*c(3)
    f(1)=x(2)
    f(2)=(c(4)*c(5)-c(2)*c(6))/d(3)
    f(3)=x(4)
    f(4)=(c(1)*c(6)-c(3)*c(5))/d(3)
    f(5)=zero
    d(2)=one+two*x(5)/beta0+x(5)**2
    !   d(2)=SQRT((one+d(2)*gambet)/d(2)/gambet)
    !   f(6)=d(2)*d(1)

    d(2)=gamma0I/beta0/d(2)
    f(6)=SQRT((1+d(2)**2))*d(1)  ! (time)-prime = dt/dz

    if(p%radiation) then
       !    d(1)=root(x(2)**2+x(4)**2+(one+hcurv*x(1))**2)
       c(1)=x(2)/d(1)
       c(2)=x(4)/d(1)
       c(3)=one/d(1)
       call alloc(b2)

       B2=zero
       B2=(B(2)*c(3)-B(3)*c(2))**2+B2
       B2=(B(1)*c(2)-B(2)*c(1))**2+B2
       B2=(B(3)*c(1)-B(1)*c(3))**2+B2
       f(5)=-CRADF(P)*(one+X(5))**2*B2*f(6)
       call kill(b2)
    else
       f(5)=zero
    endif

    call kill(d,3)
    call kill(c,6)
  end subroutine fxp

  subroutine fxs(f,y,b,p)
    implicit none

    type(real_8)  d(3),c(6),b2,x(6)
    type(env_8) ,intent(inout) :: y(6)
    type(real_8) ,intent(in) :: b(3)
    real(dp)   BETA0,GAMMA0I,hcurv
    type(real_8), intent(out):: f(6)
    type(MAGNET_CHART), pointer:: p

    call alloc(d,3)
    call alloc(c,6)
    call alloc(x,6)
    x=y
    hcurv=p%b0
    if(p%time) then
       beta0=p%beta0;GAMMA0I=p%GAMMA0I;
    else
       beta0=one;GAMMA0I=zero;
    endif

    d(1)=SQRT(x(2)**2+x(4)**2+(one+hcurv*x(1))**2)
    d(2)=(d(1)**3)/SQRT(one+2*x(5)/beta0+x(5)**2)
    d(3)=one+hcurv*x(1)

    c(1)=d(1)**2-x(2)**2
    c(2)=-x(2)*x(4)
    c(3)= x(2)*x(4)
    c(4)=-d(1)**2+x(4)**2
    c(5)=d(2)*(x(4)*b(3)-d(3)*b(2)) +hcurv*d(3)*(d(1)**2+x(2)**2)
    c(6)=d(2)*(x(2)*b(3)-d(3)*b(1)) -hcurv*d(3)*c(3)

    d(3)=c(1)*c(4)-c(2)*c(3)
    f(1)=x(2)
    f(2)=(c(4)*c(5)-c(2)*c(6))/d(3)
    f(3)=x(4)
    f(4)=(c(1)*c(6)-c(3)*c(5))/d(3)
    f(5)=zero
    d(2)=one+two*x(5)/beta0+x(5)**2
    !   d(2)=SQRT((one+d(2)*gambet)/d(2)/gambet)
    !   f(6)=d(2)*d(1)

    d(2)=gamma0I/beta0/d(2)
    f(6)=SQRT((1+d(2)**2))*d(1)  ! (time)-prime = dt/dz

    if(p%radiation) then
       !    d(1)=root(x(2)**2+x(4)**2+(one+hcurv*x(1))**2)
       c(1)=x(2)/d(1)
       c(2)=x(4)/d(1)
       c(3)=one/d(1)
       call alloc(b2)

       B2=zero
       B2=(B(2)*c(3)-B(3)*c(2))**2+B2
       B2=(B(1)*c(2)-B(2)*c(1))**2+B2
       B2=(B(3)*c(1)-B(1)*c(3))**2+B2
       f(5)=-CRADF(P)*(one+X(5))**3*B2/SQRT((one+X(5))**2-X(2)**2-X(4)**2)*(one+P%B0*X(1))
       call kill(b2)
    else
       f(5)=zero
    endif
    y=x

    call kill(d,3)
    call kill(x,6)
    call kill(c,6)
  end subroutine fxs





  ! TYPE PANCAKE


  SUBROUTINE ZEROr_PANCAKE(EL,I)
    IMPLICIT NONE
    TYPE(PANCAKE), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%B)) then
          CALL KILL(EL%B)    ! forgotten???
          deallocate(EL%B)
          !          deallocate(EL%Ax)
          !          deallocate(EL%Ay)

          deallocate(EL%SCALE)
          !          deallocate(EL%D_IN)
          !          deallocate(EL%D_OUT)
          !          deallocate(EL%ANG_IN)
          !          deallocate(EL%ANG_OUT)
       endif

    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%B)
       NULLIFY(EL%SCALE)
       !       NULLIFY(EL%Ax)
       !       NULLIFY(EL%Ay)
       !       NULLIFY(EL%D_IN)
       !       NULLIFY(EL%D_OUT)
       !       NULLIFY(EL%ANG_IN)
       !       NULLIFY(EL%ANG_OUT)
    endif

  END SUBROUTINE ZEROr_PANCAKE

  SUBROUTINE ZEROP_PANCAKE(EL,I)
    IMPLICIT NONE
    TYPE(PANCAKEP), INTENT(INOUT)::EL
    INTEGER, INTENT(IN)::I
    !integer k
    IF(I==-1) THEN
       if(ASSOCIATED(EL%B)) then
          CALL KILL(EL%SCALE)
          CALL KILL(EL%B)
          !          CALL KILL(EL%Ax)
          !          CALL KILL(EL%Ay)

          !          deallocate(EL%Ax)
          !          deallocate(EL%Ay)
          deallocate(EL%B)
          deallocate(EL%SCALE)
          !          deallocate(EL%D_IN)
          !          deallocate(EL%D_OUT)
          !          deallocate(EL%ANG_IN)
          !          deallocate(EL%ANG_OUT)
       endif

    elseif(i==0)       then          ! nullifies

       NULLIFY(EL%B)
       !       NULLIFY(EL%Ax)
       !       NULLIFY(EL%Ay)
       NULLIFY(EL%SCALE)
       !       NULLIFY(EL%D_IN)
       !       NULLIFY(EL%D_OUT)
       !       NULLIFY(EL%ANG_IN)
       !       NULLIFY(EL%ANG_OUT)
    endif

  END SUBROUTINE ZEROP_PANCAKE

  SUBROUTINE POINTERS_PANCAKER(EL,T) !,t_ax,t_ay)
    IMPLICIT NONE
    TYPE(PANCAKE), INTENT(INOUT)::EL
    TYPE(TREE_ELEMENT), INTENT(IN)::T(:) !,T_ax(:) ,T_ay(:)  ! DATA PASSED HERE SPECIAL
    INTEGER I

    ALLOCATE(EL%B(2*el%p%NST+1))
    !    ALLOCATE(EL%Ax(el%p%NST))
    !    ALLOCATE(EL%Ay(el%p%NST))
    ALLOCATE(  EL%SCALE )
    !    ALLOCATE(  EL%D_IN(3) )
    !    ALLOCATE(  EL%D_OUT(3) )
    !    ALLOCATE(  EL%ANG_IN(3) )
    !    ALLOCATE(  EL%ANG_OUT(3) )

    DO I=1,2*el%p%NST+1
       CALL ALLOC_TREE(EL%B(I),T(I)%N,3)
       !       CALL ALLOC_TREE(EL%Ax(I),T_ax(I)%N,2)
       !       CALL ALLOC_TREE(EL%Ay(I),T_ay(I)%N,2)
       EL%B(I)%CC=T(I)%CC
       EL%B(I)%JL=T(I)%JL
       EL%B(I)%JV=T(I)%JV
       EL%B(I)%N=T(I)%N
       EL%B(I)%ND2=T(I)%ND2
       EL%B(I)%no=T(I)%no
       !       EL%ax(I)%CC=t_ax(I)%CC
       !       EL%ax(I)%JL=t_ax(I)%JL
       !       EL%ax(I)%JV=t_ax(I)%JV
       !       EL%ax(I)%N=t_ax(I)%N
       !       EL%ax(I)%ND2=t_ax(I)%ND2
       !
       !       EL%ay(I)%CC=t_ay(I)%CC
       !       EL%ay(I)%JL=t_ay(I)%JL
       !       EL%ay(I)%JV=t_ay(I)%JV
       !       EL%ay(I)%N=t_ay(I)%N
       !       EL%ay(I)%ND2=t_ay(I)%ND2
    ENDDO



    EL%SCALE=ONE
    !    EL%D_IN=ZERO
    !    EL%D_OUT=ZERO
    !    EL%ANG_IN=ZERO
    !    EL%ANG_OUT=ZERO

  END SUBROUTINE POINTERS_PANCAKER

  SUBROUTINE POINTERS_PANCAKEP(EL,T) !,t_ax,t_ay)
    IMPLICIT NONE
    TYPE(PANCAKEP), INTENT(INOUT)::EL
    TYPE(TREE_ELEMENT), INTENT(IN)::T(:) !,t_ax(:),t_ay(:) ! DATA PASSED HERE SPECIAL
    INTEGER I



    ALLOCATE(EL%B(2*el%p%NST+1))
    !    ALLOCATE(EL%Ax(el%p%NST))
    !    ALLOCATE(EL%Ay(el%p%NST))
    ALLOCATE(  EL%SCALE )
    !    ALLOCATE(  EL%D_IN(3) )
    !    ALLOCATE(  EL%D_OUT(3) )
    !    ALLOCATE(  EL%ANG_IN(3) )
    !    ALLOCATE(  EL%ANG_OUT(3) )

    DO I=1,2*el%p%NST+1
       CALL ALLOC_TREE(EL%B(I),T(I)%N,3)
       !       CALL ALLOC_TREE(EL%Ax(I),T_ax(I)%N,2)
       !       CALL ALLOC_TREE(EL%Ay(I),T_ay(I)%N,2)
       EL%B(I)%CC=T(I)%CC
       EL%B(I)%JL=T(I)%JL
       EL%B(I)%JV=T(I)%JV
       EL%B(I)%N=T(I)%N
       EL%B(I)%ND2=T(I)%ND2
       EL%B(I)%no=T(I)%no
       !       EL%ax(I)%CC=t_ax(I)%CC
       !       EL%ax(I)%JL=t_ax(I)%JL
       !       EL%ax(I)%JV=t_ax(I)%JV
       !       EL%ax(I)%N=t_ax(I)%N
       !       EL%ax(I)%ND2=t_ax(I)%ND2
       !
       !       EL%ay(I)%CC=t_ay(I)%CC
       !       EL%ay(I)%JL=t_ay(I)%JL
       !       EL%ay(I)%JV=t_ay(I)%JV
       !       EL%ay(I)%N=t_ay(I)%N
       !       EL%ay(I)%ND2=t_ay(I)%ND2
    ENDDO



    !    EL%D_IN=ZERO
    !    EL%D_OUT=ZERO
    !    EL%ANG_IN=ZERO
    !    EL%ANG_OUT=ZERO
    ! EL%SCALE MUST BE CREATED IN SETFAMILYP
  END SUBROUTINE POINTERS_PANCAKEP

  SUBROUTINE copyPANCAKE_el_elp(EL,ELP)
    IMPLICIT NONE
    TYPE(PANCAKE), INTENT(in)::EL
    TYPE(PANCAKEP), INTENT(inout)::ELP

    CALL COPY_TREE_N(EL%B,ELP%B)
    !    CALL COPY_TREE_N(EL%ax,ELP%ax)
    !    CALL COPY_TREE_N(EL%ay,ELP%ay)
    !
    !!    ELP%D_IN    =  EL%D_IN
    !    ELP%D_OUT    =  EL%D_OUT
    !    ELP%ANG_IN    =  EL%ANG_IN
    !    ELP%ANG_OUT    =  EL%ANG_OUT
    ELP%SCALE  = EL%SCALE
  END SUBROUTINE copyPANCAKE_el_elp

  SUBROUTINE copyPANCAKE_el_el(EL,ELP)
    IMPLICIT NONE
    TYPE(PANCAKE), INTENT(in)::EL
    TYPE(PANCAKE), INTENT(inout)::ELP

    CALL COPY_TREE_N(EL%B,ELP%B)
    !    CALL COPY_TREE_N(EL%ax,ELP%ax)
    !    CALL COPY_TREE_N(EL%ay,ELP%ay)
    !
    !!    ELP%D_IN    =  EL%D_IN
    !    ELP%D_OUT    =  EL%D_OUT
    !    ELP%ANG_IN    =  EL%ANG_IN
    !    ELP%ANG_OUT    =  EL%ANG_OUT
    ELP%SCALE  = EL%SCALE
  END SUBROUTINE copyPANCAKE_el_el

  SUBROUTINE copyPANCAKE_elP_el(EL,ELP)
    IMPLICIT NONE
    TYPE(PANCAKEP), INTENT(in)::EL
    TYPE(PANCAKE), INTENT(inout)::ELP

    CALL COPY_TREE_N(EL%B,ELP%B)
    !    CALL COPY_TREE_N(EL%ax,ELP%ax)
    !    CALL COPY_TREE_N(EL%ay,ELP%ay)
    !
    !!    ELP%D_IN    =  EL%D_IN
    !    ELP%D_OUT    =  EL%D_OUT
    !    ELP%ANG_IN    =  EL%ANG_IN
    !    ELP%ANG_OUT    =  EL%ANG_OUT
    ELP%SCALE  = EL%SCALE
  END SUBROUTINE copyPANCAKE_elP_el

  SUBROUTINE reset_pa(EL)
    IMPLICIT NONE
    TYPE(PANCAKEP), INTENT(INOUT)::EL
    integer i
    ! CALL resetpoly_R31 ON ALL THE INTERNAL POLYMORPHS

    call resetpoly_R31(EL%SCALE)

  END SUBROUTINE reset_pa

  subroutine feval_PANCAkEr(POS,X,f,EL)
    IMPLICIT NONE
    real(dp), INTENT(INout) :: X(6)
    INTEGER, INTENT(INOUT) :: POS
    real(dp), INTENT(OUT) :: F(6)
    TYPE(PANCAKE),  INTENT(INOUT) :: EL
    real(dp) B(3)

    B(1)=X(1);
    B(2)=X(3);
    B(3)=ZERO;

    !       CALL track3(EL%B(POS),B)
    CALL trackg(EL%B(POS),B)

    b(1)=EL%SCALE*el%p%charge*el%p%dir*b(1)
    b(2)=EL%SCALE*el%p%charge*el%p%dir*b(2)
    !    b(3)=EL%SCALE*el%p%charge*el%p%dir*b(3)
    b(3)=EL%SCALE*el%p%charge*b(3)

    CALL f_M(f,x,b,EL%p)

  END subroutine feval_PANCAkEr

  subroutine feval_PANCAkEP(POS,X,f,EL)
    IMPLICIT NONE
    TYPE(REAL_8), INTENT(INout) :: X(6)
    INTEGER, INTENT(INOUT) :: POS
    TYPE(REAL_8), INTENT(OUT) :: F(6)
    TYPE(PANCAKEP),  INTENT(INOUT) :: EL
    TYPE(REAL_8) B(3)
    CALL ALLOC(B)
    B(1)=X(1);
    B(2)=X(3);
    B(3)=ZERO;

    !       CALL track3(EL%B(POS),B)
    CALL trackg(EL%B(POS),B)

    b(1)=EL%SCALE*el%p%charge*el%p%dir*b(1)
    b(2)=EL%SCALE*el%p%charge*el%p%dir*b(2)
    !    b(3)=EL%SCALE*el%p%charge*el%p%dir*b(3)
    b(3)=EL%SCALE*el%p%charge*b(3)

    CALL f_M(f,x,b,EL%p)

    CALL KILL(B)

  END subroutine feval_PANCAkEP

  subroutine feval_PANCAkEs(POS,y,f,EL)
    IMPLICIT NONE
    TYPE(REAL_8)  X(6)
    TYPE(env_8), INTENT(INout) :: y(6)
    INTEGER, INTENT(INOUT) :: POS
    TYPE(REAL_8), INTENT(OUT) :: F(6)
    TYPE(PANCAKEP),  INTENT(INOUT) :: EL
    TYPE(REAL_8) B(3)
    CALL ALLOC(B)

    call alloc(x,6)
    x=y
    B(1)=X(1);
    B(2)=X(3);
    B(3)=ZERO;

    !       CALL track3(EL%B(POS),B)
    CALL trackg(EL%B(POS),B)

    b(1)=EL%SCALE*el%p%charge*el%p%dir*b(1)
    b(2)=EL%SCALE*el%p%charge*el%p%dir*b(2)
    !    b(3)=EL%SCALE*el%p%charge*el%p%dir*b(3)
    b(3)=EL%SCALE*el%p%charge*b(3)
    y=x
    CALL f_M(f,y,b,EL%p)

    CALL KILL(B)
    call kill(x,6)

  END subroutine feval_PANCAkEs

  ! 4 order Runge
  subroutine rk4_pancaker(ti,h,GR,y)
    IMPLICIT none

    integer ne
    parameter (ne=6)
    real(dp), INTENT(INOUT)::  y(ne)
    real(dp)  yt(ne),f(ne),a(ne),b(ne),c(ne),d(ne)
    type (pancake) ,INTENT(INOUT)::  GR
    integer j
    real(dp), intent(inout) :: h
    integer, intent(inout) :: ti
    INTEGER TT


    call feval(tI,y,f,gr)
    do  j=1,ne
       a(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j)=y(j)+a(j)/two
    enddo

    tt=tI+GR%p%dir
    call feval(tt,yt,f,gr)
    do  j=1,ne
       b(j)=h*f(j)
    enddo
    do   j=1,ne
       yt(j)=y(j) + b(j)/two
    enddo


    tt=tI+GR%p%dir
    call feval(tt,yt,f,gr)
    do  j=1,ne
       c(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j)=y(j)+c(j)
    enddo

    tt=tI+2*GR%p%dir
    call feval(tt,yt,f,gr)
    do  j=1,ne
       d(j)=h*f(j)
    enddo

    do  j=1,ne
       y(j) = y(j)+(a(j)+two*b(j)+two*c(j)+d(j))/six
    enddo
    tI=ti+2*GR%p%dir

    if(GR%P%TIME) then
       Y(6)=Y(6)-(1-GR%P%TOTALPATH)*GR%P%LD/GR%P%beta0/GR%P%nst
    else
       Y(6)=Y(6)-(1-GR%P%TOTALPATH)*GR%P%LD/GR%P%nst
    endif

    return
  end  subroutine rk4_pancaker

  subroutine rk4_pancakeP(ti,h,GR,y)
    IMPLICIT none

    integer ne
    parameter (ne=6)
    TYPE(REAL_8), INTENT(INOUT)::  y(ne)
    TYPE(REAL_8)  yt(ne),f(ne),a(ne),b(ne),c(ne),d(ne)
    type (pancakeP) ,INTENT(INOUT)::  GR
    integer j
    TYPE(REAL_8), intent(inout) :: h
    integer, intent(inout) :: ti
    INTEGER TT
    call alloc(yt,ne)
    call alloc(f,ne)
    call alloc(a,ne)
    call alloc(b,ne)
    call alloc(c,ne)
    call alloc(d,ne)


    call feval(tI,y,f,gr)
    do  j=1,ne
       a(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j)=y(j)+a(j)/two
    enddo

    tt=tI+GR%p%dir
    call feval(tt,yt,f,gr)
    do  j=1,ne
       b(j)=h*f(j)
    enddo
    do   j=1,ne
       yt(j)=y(j) + b(j)/two
    enddo


    tt=tI+GR%p%dir
    call feval(tt,yt,f,gr)
    do  j=1,ne
       c(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j)=y(j)+c(j)
    enddo

    tt=tI+2*GR%p%dir
    call feval(tt,yt,f,gr)
    do  j=1,ne
       d(j)=h*f(j)
    enddo


    do  j=1,ne
       y(j) = y(j)+(a(j)+two*b(j)+two*c(j)+d(j))/six
    enddo
    tI=ti+2*GR%p%dir

    if(GR%P%TIME) then
       Y(6)=Y(6)-(1-GR%P%TOTALPATH)*GR%P%LD/GR%P%beta0/GR%P%nst
    else
       Y(6)=Y(6)-(1-GR%P%TOTALPATH)*GR%P%LD/GR%P%nst
    endif

    call KILL(yt,ne)
    call KILL(f,ne)
    call KILL(a,ne)
    call KILL(b,ne)
    call KILL(c,ne)
    call KILL(d,ne)

    return
  end  subroutine rk4_pancakeP

  subroutine rk4_pancakes(ti,h,GR,x)
    IMPLICIT none

    integer ne
    parameter (ne=6)
    TYPE(env_8), INTENT(INOUT)::  x(ne)
    TYPE(REAL_8)  y(ne)
    TYPE(REAL_8)  yt(ne),f(ne),a(ne),b(ne),c(ne),d(ne)
    type (pancakeP) ,INTENT(INOUT)::  GR
    TYPE(REAL_8), intent(inout) :: h
    integer, intent(inout) :: ti
    INTEGER TT
    TYPE(REAL_8) X1,X3,X5,Bs(3),B2,DENF,XR(6)
    TYPE(DAMAP) XP,ID,DISP,XT
    INTEGER J,I    !,M,K,DIR
    real(dp) B20,B30,BFf, v(6)  !,R1,R2,DEN0
    logical(lp) done_stoch
    real(dp) :: tot=0.d0


    call alloc(y,ne)
    call alloc(yt,ne)
    call alloc(f,ne)
    call alloc(a,ne)
    call alloc(b,ne)
    call alloc(c,ne)
    call alloc(d,ne)

    CALL ALLOC(X1,X3,X5,B2)
    CALL ALLOC(BS,3)
    CALL ALLOC(XP)
    CALL ALLOC(denf)
    CALL ALLOC(XR)
    CALL ALLOC(ID)
    CALL ALLOC(DISP)
    CALL ALLOC(XT)

    y=x
    call feval(tI,y,f,gr)
    do  j=1,ne
       a(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j)=y(j)+a(j)/two
    enddo

    tt=tI+GR%p%dir
    call feval(tt,yt,f,gr)
    do  j=1,ne
       b(j)=h*f(j)
    enddo
    do   j=1,ne
       yt(j)=y(j) + b(j)/two
    enddo


    tt=tI+GR%p%dir
    call feval(tt,yt,f,gr)
    do  j=1,ne
       c(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j)=y(j)+c(j)
    enddo

    tt=tI+2*GR%p%dir
    call feval(tt,yt,f,gr)
    do  j=1,ne
       d(j)=h*f(j)
    enddo

    XP=y
    XR=y
    if(gr%P%TIME) then
       X5=SQRT(one+two*y(5)/gr%P%beta0+y(5)**2)-one
    else
       X5=y(5)
    endif


    do  j=1,ne
       y(j) = y(j)+(a(j)+two*b(j)+two*c(j)+d(j))/six
    enddo
    c(6)=(a(6)+two*b(6)+two*c(6)+d(6))/six
    tI=ti+2*GR%p%dir

    if(GR%P%TIME) then
       Y(6)=Y(6)-(1-GR%P%TOTALPATH)*GR%P%LD/GR%P%beta0/GR%P%nst
    else
       Y(6)=Y(6)-(1-GR%P%TOTALPATH)*GR%P%LD/GR%P%nst
    endif

    done_stoch=.false.
    if(GR%P%B0==zero.and.stoch_in_rec) then

       ! b2perp
       d(1)=sqrt(xr(2)**2+xr(4)**2+(one+gR%P%B0*xr(1))**2)
       c(1)=xr(2)/d(1)
       c(2)=xr(4)/d(1)
       c(3)=one/d(1)
       Bs(1)=xr(1);
       Bs(2)=xr(3);
       Bs(3)=ZERO;

       CALL trackg(gr%B(ti-GR%p%dir),Bs)

       B2=zero
       B2=(Bs(2)*c(3)-Bs(3)*c(2))**2+B2
       B2=(Bs(1)*c(2)-Bs(2)*c(1))**2+B2
       B2=(Bs(3)*c(1)-Bs(1)*c(3))**2+B2

       denf=(one+xr(5))**4*c(6)
       b20=b2
       b30=b20**c_1_5
       bfF=cflucf(gr%p)*b30
       denf=denf*bfF
       done_stoch=.true.
    elseif(GR%P%B0/=zero)   then
       done_stoch=.true.
    endif

    if(done_stoch) then

       if(GR%P%B0/=zero) then
          !
          if(knob) then
             v=XR
             DISP=xp*id
             id=1
             DISP=ID-DISP
             XP=DISP*XP

             id=0
             XT=XR
             DISP=XT*ID
             ID=1
             DISP=ID-DISP
             XT=DISP*XT

             xr=xt+V
             ! b2perp
             d(1)=sqrt(xr(2)**2+xr(4)**2+(one+gR%P%B0*xr(1))**2)
             c(1)=xr(2)/d(1)
             c(2)=xr(4)/d(1)
             c(3)=one/d(1)
             Bs(1)=xr(1);
             Bs(2)=xr(3);
             Bs(3)=ZERO;

             CALL trackg(gr%B(ti-GR%p%dir),Bs)

             B2=zero
             B2=(Bs(2)*c(3)-Bs(3)*c(2))**2+B2
             B2=(Bs(1)*c(2)-Bs(2)*c(1))**2+B2
             B2=(Bs(3)*c(1)-Bs(1)*c(3))**2+B2


             denf=(one+xr(5))**4*c(6)

             denf=DENF*cflucf(gr%p)*b2**c_1_5
          else

             ! b2perp
             d(1)=sqrt(xr(2)**2+xr(4)**2+(one+gR%P%B0*xr(1))**2)
             c(1)=xr(2)/d(1)
             c(2)=xr(4)/d(1)
             c(3)=one/d(1)
             Bs(1)=xr(1);
             Bs(2)=xr(3);
             Bs(3)=ZERO;

             CALL trackg(gr%B(ti-GR%p%dir),Bs)

             B2=zero
             B2=(Bs(2)*c(3)-Bs(3)*c(2))**2+B2
             B2=(Bs(1)*c(2)-Bs(2)*c(1))**2+B2
             B2=(Bs(3)*c(1)-Bs(1)*c(3))**2+B2

             denf=(one+xr(5))**4*c(6)
             b20=b2
             b30=b20**c_1_5
             bfF=cflucf(gr%p)*b30
             denf=denf*bfF
          endif
       endif

       xp=xp**(-1)
       do i=1,6
          do j=1,6
             X1=(xp%v(i)).par.'000010'
             X3=(xp%v(j)).par.'000010'
             denf=denf.par.'000000'
             x(I)%E(J)=x(I)%E(J)+denf*x1*x3
          enddo
       enddo
    endif

    x=y

    call KILL(y,ne)
    call KILL(yt,ne)
    call KILL(f,ne)
    call KILL(a,ne)
    call KILL(b,ne)
    call KILL(c,ne)
    call KILL(d,ne)

    CALL KILL(X1,X3,X5,B2)
    CALL KILL(BS,3)
    CALL KILL(XP)
    CALL KILL(denf)
    CALL KILL(XR)
    CALL KILL(ID)
    CALL KILL(DISP)
    CALL KILL(XT)

    return
  end  subroutine rk4_pancakes

  SUBROUTINE conv_to_xpr(EL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(PANCAKE),INTENT(INOUT):: EL
    real(dp) ti
    if(el%p%time) then
       ti=ROOT(one+two*X(5)/el%p%beta0+x(5)**2-X(2)**2-X(4)**2)
       x(2)=(ONE+el%p%B0*X(1))*x(2)/ti
       x(4)=(ONE+el%p%B0*X(1))*x(4)/ti
    else
       ti=ROOT((one+x(5))**2-X(2)**2-X(4)**2)
       x(2)=(ONE+el%p%B0*X(1))*x(2)/ti
       x(4)=(ONE+el%p%B0*X(1))*x(4)/ti
    endif

  end SUBROUTINE conv_to_xpr

  SUBROUTINE conv_to_xpp(EL,X)
    IMPLICIT NONE
    type(real_8),INTENT(INOUT):: X(6)
    TYPE(PANCAKEp),INTENT(INOUT):: EL
    type(real_8) ti
    call alloc(ti)
    if(el%p%time) then
       ti=sqrt(one+two*X(5)/el%p%beta0+x(5)**2-X(2)**2-X(4)**2)
       x(2)=(ONE+el%p%B0*X(1))*x(2)/ti
       x(4)=(ONE+el%p%B0*X(1))*x(4)/ti
    else
       ti=sqrt((one+x(5))**2-X(2)**2-X(4)**2)
       x(2)=(ONE+el%p%B0*X(1))*x(2)/ti
       x(4)=(ONE+el%p%B0*X(1))*x(4)/ti
    endif
    call kill(ti)

  end SUBROUTINE conv_to_xpp

  SUBROUTINE conv_to_pxr(EL,X)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(PANCAKE),INTENT(INOUT):: EL
    real(dp) ti
    ti=ROOT((ONE+el%p%B0*X(1))**2+X(2)**2+X(4)**2)
    if(el%p%time) then
       x(2)=x(2)*ROOT(one+two*X(5)/el%p%beta0+x(5)**2)/ti
       x(4)=x(4)*ROOT(one+two*X(5)/el%p%beta0+x(5)**2)/ti
    else
       x(2)=x(2)*(one+x(5))/ti
       x(4)=x(4)*(one+x(5))/ti
    endif
  end SUBROUTINE conv_to_pxr

  SUBROUTINE conv_to_pxp(EL,X)
    IMPLICIT NONE
    type(real_8),INTENT(INOUT):: X(6)
    TYPE(PANCAKEp),INTENT(INOUT):: EL
    type(real_8) ti
    call alloc(ti)
    ti=SQRT((ONE+el%p%B0*X(1))**2+X(2)**2+X(4)**2)
    if(el%p%time) then
       x(2)=x(2)*sqrt(one+two*X(5)/el%p%beta0+x(5)**2)/ti
       x(4)=x(4)*sqrt(one+two*X(5)/el%p%beta0+x(5)**2)/ti
    else
       x(2)=x(2)*(one+x(5))/ti
       x(4)=x(4)*(one+x(5))/ti
    endif
    call kill(ti)

  end SUBROUTINE conv_to_pxp


  ! ETIENNE_PANCAKE
  SUBROUTINE INTPANCAKER(EL,X,MID)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    TYPE(WORM),OPTIONAL,INTENT(INOUT):: MID
    TYPE(PANCAKE),INTENT(INOUT):: EL
    INTEGER I,IS
    real(dp) ti,h

    H=el%L/el%p%NST

    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    SELECT CASE(EL%P%METHOD)
    CASE(4)
       call conv_to_xp(EL,X)
       IF(EL%P%DIR==1) THEN
          IS=1
          DO I=1,el%p%NST
             call rk4_m(IS,h,el,X)
             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO
       else
          IS=2*el%p%NST+1
          DO I=1,el%p%NST
             call rk4_m(IS,h,el,X)
             IF(PRESENT(MID)) CALL XMID(MID,X,I)
          ENDDO

       ENDIF
       call conv_to_px(EL,X)

       !       CASE(2)
       !
       !          IS=1
       !          call DRIFT_pancake(EL,hh,is,1,X)
       !          call DRIFT_pancake(EL,hh,is,2,X)
       !          call KICKPATH(EL,hf,X)
       !          DO I=1,el%p%NST-2
       !             IS=is+1
       !             call DRIFT_pancake(EL,hh,is,2,X)
       !             call DRIFT_pancake(EL,hf,is,1,X)
       !             call DRIFT_pancake(EL,hh,is,2,X)
       !             call KICKPATH(EL,hf,X)
       !          ENDDO
       !          IS=is+1
       !          call DRIFT_pancake(EL,hh,is,2,X)
       !          call DRIFT_pancake(EL,hf,is,1,X)
       !          a(1)=x(1)
       !          a(2)=x(3)
       !          CALL trackg(EL%ax(is),A)
       !          X(2)=X(2)-EL%SCALE*el%p%charge*A(1)
       !          a(1)=x(1)
       !          a(2)=x(3)
       !          CALL trackg(EL%ay(is),A)
       !          X(4)=X(4)-EL%SCALE*el%p%charge*A(1)
       !
    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT




  END SUBROUTINE INTPANCAKER

  SUBROUTINE INTPANCAKEP(EL,X)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    ! TYPE(WORM_8),OPTIONAL,INTENT(INOUT):: MID
    TYPE(PANCAKEP),INTENT(INOUT):: EL
    INTEGER I,IS
    TYPE(REAL_8) ti,h
    REAL(DP) a(2)

    CALL ALLOC(TI,H)


    H=el%L/el%p%NST




    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    SELECT CASE(EL%P%METHOD)
    CASE(4)
       call conv_to_xp(EL,X)
       IF(EL%P%DIR==1) THEN
          IS=1
          DO I=1,el%p%NST
             call rk4_m(IS,h,el,X)
          ENDDO
       else
          IS=2*el%p%NST+1
          DO I=1,el%p%NST
             call rk4_m(IS,h,el,X)
          ENDDO

       ENDIF


       call conv_to_px(EL,X)
       !       CASE(2)
       !          IS=1
       !          call DRIFT_pancake(EL,hh,is,1,X)
       !          call DRIFT_pancake(EL,hh,is,2,X)
       !          call KICKPATH(EL,hf,X)
       !          DO I=1,el%p%NST-2
       !             IS=is+1
       !             call DRIFT_pancake(EL,hh,is,2,X)
       !             call DRIFT_pancake(EL,hf,is,1,X)
       !             call DRIFT_pancake(EL,hh,is,2,X)
       !             call KICKPATH(EL,hf,X)
       !          ENDDO
       !          IS=is+1
       !          call DRIFT_pancake(EL,hh,is,2,X)
       !          call DRIFT_pancake(EL,hf,is,1,X)
       !          a(1)=x(1)
       !          a(2)=x(3)
       !          CALL trackg(EL%ax(is),A)
       !          X(2)=X(2)-EL%SCALE*el%p%charge*A(1)
       !          a(1)=x(1)
       !          a(2)=x(3)
       !          CALL trackg(EL%ay(is),A)
       !          X(4)=X(4)-EL%SCALE*el%p%charge*A(1)
       !

    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT




    CALL KILL(TI,H)

  END SUBROUTINE INTPANCAKEP

  SUBROUTINE INTPANCAKEs(EL,Y)
    IMPLICIT NONE
    TYPE(env_8),INTENT(INOUT):: Y(6)
    TYPE(REAL_8)  X(6)
    TYPE(PANCAKEP),INTENT(INOUT):: EL
    INTEGER I,IS
    TYPE(REAL_8) ti,h
    REAL(DP) a(2)

    CALL ALLOC(TI,H)
    CALL ALLOC(X)


    H=el%L/el%p%NST




    !    IF(PRESENT(MID)) CALL XMID(MID,X,0)

    SELECT CASE(EL%P%METHOD)
    CASE(4)
       X=Y
       call conv_to_xp(EL,X)
       Y=X
       IF(EL%P%DIR==1) THEN
          IS=1
          DO I=1,el%p%NST
             call rk4_m(IS,h,el,Y)
          ENDDO
       else
          IS=2*el%p%NST+1
          DO I=1,el%p%NST
             call rk4_m(IS,h,el,Y)
          ENDDO

       ENDIF

       X=Y
       call conv_to_px(EL,X)
       Y=X



    CASE DEFAULT
       w_p=0
       w_p%nc=1
       w_p%fc='(1(1X,A72))'
       WRITE(w_p%c(1),'(a12,1x,i4,1x,a17)') " THE METHOD ",EL%P%METHOD," IS NOT SUPPORTED"
       call write_e(357)
    END SELECT



    CALL KILL(X)

    CALL KILL(TI,H)

  END SUBROUTINE INTPANCAKEs





  ! cav_trav

  subroutine feval_CAVR(Z0,X,f,D)   ! MODELLED BASED ON DRIFT
    IMPLICIT NONE
    real(dp), INTENT(INout) :: X(6)
    real(dp),INTENT(INOUT):: Z0
    real(dp), INTENT(OUT) :: F(6)
    REAL(DP) A(3),AD(2),PZ
    TYPE(CAV_TRAV),  INTENT(INOUT) :: D

    A=zero;AD=zero;
    CALL A_TRANS(D,Z0,X,A,AD)

    X(2)=X(2)-A(1)
    X(4)=X(4)-A(2)

    IF(D%P%EXACT) THEN
       if(D%P%TIME) then
          PZ=ROOT(one+two*X(5)/D%P%BETA0+x(5)**2-X(2)**2-X(4)**2)
          F(1)=X(2)/PZ
          F(3)=X(4)/PZ
          F(2)=F(1)*AD(1)
          F(4)=F(3)*AD(1)
          F(5)=-(F(1)*X(1)+F(3)*X(3))*AD(2)+A(3)
          F(6)=(one/D%P%BETA0+X(5))/PZ-(1-D%P%TOTALPATH)/D%P%BETA0
       else
          PZ=ROOT((one+X(5))**2-X(2)**2-X(4)**2)
          F(1)=X(2)/PZ
          F(3)=X(4)/PZ
          F(2)=F(1)*AD(1)
          F(4)=F(3)*AD(1)
          F(5)=-(F(1)*X(1)+F(3)*X(3))*AD(2)+A(3)
          F(6)=(one+X(5))/PZ-(1-D%P%TOTALPATH)
       endif
    ELSE
       if(D%P%TIME) then
          PZ=ROOT(one+two*X(5)/D%P%BETA0+x(5)**2)
          F(1)=X(2)/PZ
          F(3)=X(4)/PZ
          F(2)=F(1)*AD(1)
          F(4)=F(3)*AD(1)
          F(5)=-(F(1)*X(1)+F(3)*X(3))*AD(2)+A(3)
          F(6)=((X(2)*X(2)+X(4)*X(4))/two/pz**2+one)*(one/D%P%BETA0+x(5))/pz
          F(6)=F(6)-(1-D%P%TOTALPATH)/D%P%BETA0
       else
          F(1)=X(2)/(one+X(5))
          F(3)=X(4)/(one+X(5))
          F(2)=F(1)*AD(1)
          F(4)=F(3)*AD(1)
          F(5)=-(F(1)*X(1)+F(3)*X(3))*AD(2)+A(3)
          F(6)=(ONE/(one+X(5)))*(X(2)*X(2)+X(4)*X(4))/two/(one+X(5))+D%P%TOTALPATH
       endif
    ENDIF

    X(2)=X(2)+A(1)
    X(4)=X(4)+A(2)

  END subroutine feval_CAVR

  subroutine feval_CAVP(Z0,X,f,D)   ! MODELLED BASED ON DRIFT
    IMPLICIT NONE
    TYPE(REAL_8), INTENT(INout) :: X(6)
    TYPE(REAL_8), INTENT(INOUT):: Z0
    TYPE(REAL_8), INTENT(OUT) :: F(6)
    TYPE(REAL_8)  A(3),AD(2),PZ
    TYPE(CAV_TRAVp),  INTENT(INOUT) :: D

    CALL ALLOC(A)
    CALL ALLOC(AD)
    CALL ALLOC(PZ)


    CALL A_TRANS(D,Z0,X,A,AD)

    X(2)=X(2)-A(1)
    X(4)=X(4)-A(2)

    IF(D%P%EXACT) THEN
       if(D%P%TIME) then
          PZ=sqrt(one+two*X(5)/D%P%BETA0+x(5)**2-X(2)**2-X(4)**2)
          F(1)=X(2)/PZ
          F(3)=X(4)/PZ
          F(2)=F(1)*AD(1)
          F(4)=F(3)*AD(1)
          F(5)=-(F(1)*X(1)+F(3)*X(3))*AD(2)+A(3)
          F(6)=(one/D%P%BETA0+X(5))/PZ-(1-D%P%TOTALPATH)/D%P%BETA0
       else
          PZ=sqrt((one+X(5))**2-X(2)**2-X(4)**2)
          F(1)=X(2)/PZ
          F(3)=X(4)/PZ
          F(2)=F(1)*AD(1)
          F(4)=F(3)*AD(1)
          F(5)=-(F(1)*X(1)+F(3)*X(3))*AD(2)+A(3)
          F(6)=(one+X(5))/PZ-(1-D%P%TOTALPATH)
       endif
    ELSE
       if(D%P%TIME) then
          PZ=sqrt(one+two*X(5)/D%P%BETA0+x(5)**2)
          F(1)=X(2)/PZ
          F(3)=X(4)/PZ
          F(2)=F(1)*AD(1)
          F(4)=F(3)*AD(1)
          F(5)=-(F(1)*X(1)+F(3)*X(3))*AD(2)+A(3)
          F(6)=((X(2)*X(2)+X(4)*X(4))/two/pz**2+one)*(one/D%P%BETA0+x(5))/pz
          F(6)=F(6)-(1-D%P%TOTALPATH)/D%P%BETA0
       else
          F(1)=X(2)/(one+X(5))
          F(3)=X(4)/(one+X(5))
          F(2)=F(1)*AD(1)
          F(4)=F(3)*AD(1)
          F(5)=-(F(1)*X(1)+F(3)*X(3))*AD(2)+A(3)
          F(6)=(ONE/(one+X(5)))*(X(2)*X(2)+X(4)*X(4))/two/(one+X(5))+D%P%TOTALPATH
       endif
    ENDIF

    X(2)=X(2)+A(1)
    X(4)=X(4)+A(2)

    CALL KILL(A)
    CALL KILL(AD)
    CALL KILL(PZ)


  END subroutine feval_CAVP

  SUBROUTINE A_TRANSR(EL,Z0,X,A,AD)    ! EXP(-I:(X^2+Y^2)/2*A_TRANS:)
    IMPLICIT NONE
    real(dp),INTENT(INOUT):: X(6)
    real(dp),INTENT(INOUT):: Z0,A(3),ad(2)
    TYPE(CAV_TRAV),INTENT(INOUT):: EL
    real(dp) C1,S1,C2,S2,V,O

    !    IF(EL%P%NOCAVITY.OR.(.NOT.EL%P%FRINGE)) RETURN
    IF(EL%P%NOCAVITY) RETURN

    O=EL%freq*twopi/CLIGHT
    C1=COS(O*(x(6)-Z0)+EL%PHAS+phase0)
    C2=COS(O*(x(6)+Z0)+EL%PHAS+phase0+EL%DPHAS)
    S1=SIN(O*(x(6)-Z0)+EL%PHAS+phase0)
    S2=SIN(O*(x(6)+Z0)+EL%PHAS+phase0+EL%DPHAS)
    V=EL%P%CHARGE*(EL%volt-el%dvds*z0)*c_1d_3/EL%P%P0C

    AD(1)=HALF*V*(COS(EL%PSI)*S1-SIN(EL%PSI)*S2)
    AD(2)=O*HALF*V*(COS(EL%PSI)*C1-SIN(EL%PSI)*C2)
    A(1)=AD(1)*X(1)
    A(2)=AD(1)*X(3)
    A(3)=-EL%P%DIR*V*(COS(EL%PSI)*S1+SIN(EL%PSI)*S2)


  END SUBROUTINE A_TRANSR


  SUBROUTINE A_TRANSP(EL,Z0,X,A,AD)    ! EXP(-I:(X^2+Y^2)/2*A_TRANS:)
    IMPLICIT NONE
    TYPE(REAL_8),INTENT(INOUT):: X(6)
    TYPE(REAL_8),INTENT(INOUT):: Z0,A(3),ad(2)
    TYPE(CAV_TRAVP),INTENT(INOUT):: EL
    TYPE(REAL_8) C1,S1,C2,S2,V,O

    !    IF(EL%P%NOCAVITY.OR.(.NOT.EL%P%FRINGE)) RETURN
    IF(EL%P%NOCAVITY) RETURN

    CALL ALLOC(C1,S1,C2,S2,V,O)
    O=EL%freq*twopi/CLIGHT
    C1=COS(O*(x(6)-Z0)+EL%PHAS+phase0)
    C2=COS(O*(x(6)+Z0)+EL%PHAS+phase0+EL%DPHAS)
    S1=SIN(O*(x(6)-Z0)+EL%PHAS+phase0)
    S2=SIN(O*(x(6)+Z0)+EL%PHAS+phase0+EL%DPHAS)
    V=EL%P%CHARGE*(EL%volt-el%dvds*z0)*c_1d_3/EL%P%P0C

    AD(1)=HALF*V*(COS(EL%PSI)*S1-SIN(EL%PSI)*S2)
    AD(2)=O*HALF*V*(COS(EL%PSI)*C1-SIN(EL%PSI)*C2)
    A(1)=AD(1)*X(1)
    A(2)=AD(1)*X(3)
    A(3)=-EL%P%DIR*V*(COS(EL%PSI)*S1+SIN(EL%PSI)*S2)

    CALL KILL(C1,S1,C2,S2,V,O)

  END SUBROUTINE A_TRANSP

  subroutine rk2_cavr(ti,h,GR,y)
    IMPLICIT none

    integer ne
    parameter (ne=6)
    real(dp), INTENT(INOUT)::  y(ne)
    real(dp)  yt(ne),f(ne),a(ne),b(ne)
    real(dp)  tt
    type (cav_trav) ,INTENT(INOUT)::  GR
    integer j
    real(dp), intent(inout) :: ti,h


    call feval_cav(tI,y,f,gr)
    do  j=1,ne
       a(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j)=y(j)+a(j)/two
    enddo

    tt=tI+h/two
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       b(j)=h*f(j)
    enddo

    do  j=1,ne
       y(j) = y(j)+b(j)
    enddo
    tI=ti+h

    return
  end  subroutine rk2_cavr

  ! 2 order Runge
  subroutine rk2_cavp(ti,h,GR,y)
    IMPLICIT none

    integer ne
    parameter (ne=6)
    type (real_8), INTENT(INOUT)::  y(ne)
    type (real_8)  yt(ne),f(ne),a(ne),b(ne)
    type (real_8)  tt
    type (cav_travp) ,INTENT(INOUT)::  GR
    integer j,n_g,n_g_p
    type(real_8), intent(inout) :: ti,h

    call alloc(yt,ne)
    call alloc(f,ne)
    call alloc(a,ne)
    call alloc(b,ne)

    call alloc(tt)

    call feval_cav(tI,y,f,gr)
    do  j=1,ne
       a(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j)=y(j)+a(j)/two
    enddo

    tt=tI+h/two
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       b(j)=h*f(j)
    enddo

    do  j=1,ne
       y(j) = y(j)+b(j)
    enddo
    tI=ti+h

    call kill(tt)
    call kill(yt,ne)
    call kill(f,ne)
    call kill(a,ne)
    call kill(b,ne)

    return
  end  subroutine rk2_cavp

  subroutine rk4_cavr(ti,h,GR,y)
    IMPLICIT none

    integer ne
    parameter (ne=6)
    real(dp), INTENT(INOUT)::  y(ne)
    real(dp)  yt(ne),f(ne),a(ne),b(ne),c(ne),d(ne)
    type (CAV_TRAV) ,INTENT(INOUT)::  GR
    integer j
    real(dp), intent(inout) :: h
    real(dp), intent(inout) :: ti
    real(dp) TT


    call feval_cav(tI,y,f,gr)
    do  j=1,ne
       a(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j)=y(j)+a(j)/two
    enddo

    tt=tI+h/two
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       b(j)=h*f(j)
    enddo
    do   j=1,ne
       yt(j)=y(j) + b(j)/two
    enddo


    !      tt=tI+1
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       c(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j)=y(j)+c(j)
    enddo

    tt=tI+h
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       d(j)=h*f(j)
    enddo


    do  j=1,ne
       y(j) = y(j)+(a(j)+two*b(j)+two*c(j)+d(j))/six
    enddo
    tI=tt

    return
  end  subroutine rk4_cavr

  subroutine rk4_cavp(ti,h,GR,y)
    IMPLICIT none

    integer ne
    parameter (ne=6)
    type(real_8), INTENT(INOUT)::  y(ne)
    type (CAV_TRAVp) ,INTENT(INOUT)::  GR
    type(real_8), intent(inout) :: h
    type(real_8), intent(inout) :: ti
    type(real_8)  yt(ne),f(ne),a(ne),b(ne),c(ne),d(ne)
    type(real_8) TT
    integer j

    call alloc(tt)
    call alloc(yt)
    call alloc(f)
    call alloc(a)
    call alloc(b)
    call alloc(c)
    call alloc(d)

    call feval_cav(tI,y,f,gr)
    do  j=1,ne
       a(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j)=y(j)+a(j)/two
    enddo

    tt=tI+h/two
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       b(j)=h*f(j)
    enddo
    do   j=1,ne
       yt(j)=y(j) + b(j)/two
    enddo


    !      tt=tI+1
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       c(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j)=y(j)+c(j)
    enddo

    tt=tI+h
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       d(j)=h*f(j)
    enddo


    do  j=1,ne
       y(j) = y(j)+(a(j)+two*b(j)+two*c(j)+d(j))/six
    enddo
    tI=tt

    call kill(tt)
    call kill(yt)
    call kill(f)
    call kill(a)
    call kill(b)
    call kill(c)
    call kill(d)

    return
  end  subroutine rk4_cavp

  subroutine rk6_cavr(ti,h,GR,y)
    IMPLICIT none
    !  Written by Rob Ryne, Spring 1986, based on a routine of
    !c  J. Milutinovic.
    !c  For a reference, see page 76 of F. Ceschino and J Kuntzmann,
    !c  Numerical Solution of Initial Value Problems, Prentice Hall 1966.
    !c  This integration routine makes local truncation errors at each
    !c  step of order h**7.
    !c  That is, it is locally correct through terms of order h**6.
    !c  Each step requires 8 function evaluations.

    integer ne
    parameter (ne=6)
    real(dp), INTENT(INOUT)::  y(ne)
    real(dp)  yt(ne),f(ne),a(ne),b(ne),c(ne),d(ne),e(ne),g(ne),o(ne),p(ne)
    real(dp)  tt
    type (CAV_TRAV) ,INTENT(INOUT)::  GR
    integer j
    real(dp), intent(inout) :: ti,h


    call feval_cav(tI,y,f,gr)
    do  j=1,ne
       a(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j)=y(j)+a(j)/nine
    enddo
    tt=tI+h/nine
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       b(j)=h*f(j)
    enddo
    do   j=1,ne
       yt(j)=y(j) + (a(j) + three*b(j))/c_24
    enddo
    tt=tI+h/six
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       c(j)=h*f(j)
    enddo

    do  j=1,ne
       yt(j)=y(j)+(a(j)-three*b(j)+four*c(j))/six
    enddo

    tt=tI+h/three
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       d(j)=h*f(j)
    enddo

    do  j=1,ne
       yt(j)=y(j) + (-five*a(j) + c_27*b(j) - c_24*c(j) + six*d(j))/eight
    enddo
    tt=tI+half*h
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       e(j)=h*f(j)
    enddo

    do  j=1,ne
       yt(j)=y(j) + (c_221*a(j) - c_981*b(j) + c_867*c(j)- c_102*d(j) + e(j))/nine
    enddo
    tt = tI+two*h/three
    call feval_cav(tt,yt,f,gr)
    do   j=1,ne
       g(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j) = y(j)+(-c_183*a(j)+c_678*b(j)-c_472*c(j)-c_66*d(j)+c_80*e(j) + three*g(j))/c_48
    enddo
    tt = tI + five*h/six
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       o(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j) = y(j)+(c_716*a(j)-c_2079*b(j)+c_1002*c(j)+c_834*d(j)-c_454*e(j)-nine*g(j)+c_72*o(j))/c_82
    enddo

    tt = tI + h
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       p(j)=h*f(j)
    enddo

    do  j=1,ne
       y(j) = y(j)+(c_41*a(j)+c_216*c(j)+c_27*d(j)+c_272*e(j)+c_27*g(j)+c_216*o(j)+c_41*p(j))/c_840
    enddo
    tI=ti+h

    return
  end  subroutine rk6_cavr



  ! sixth order Runge
  subroutine rk6_cavp(ti,h,GR,y)
    IMPLICIT none


    integer ne
    parameter (ne=6)
    type (real_8), INTENT(INOUT)::  y(ne)
    type (real_8)  yt(ne),f(ne),a(ne),b(ne),c(ne),d(ne),e(ne),g(ne),o(ne),p(ne)
    type (real_8)  tt
    type (cav_travp) ,INTENT(INOUT)::  GR
    integer j
    type(real_8), intent(inout) :: ti,h

    call alloc(yt,ne)
    call alloc(f,ne)
    call alloc(a,ne)
    call alloc(b,ne)
    call alloc(c,ne)
    call alloc(d,ne)
    call alloc(e,ne)
    call alloc(g,ne)
    call alloc(o,ne)
    call alloc(p,ne)
    call alloc(tt)

    call feval_cav(tI,y,f,gr)
    do  j=1,ne
       a(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j)=y(j)+a(j)/nine
    enddo
    tt=tI+h/nine
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       b(j)=h*f(j)
    enddo
    do   j=1,ne
       yt(j)=y(j) + (a(j) + three*b(j))/c_24
    enddo
    tt=tI+h/six
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       c(j)=h*f(j)
    enddo

    do  j=1,ne
       yt(j)=y(j)+(a(j)-three*b(j)+four*c(j))/six
    enddo

    tt=tI+h/three
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       d(j)=h*f(j)
    enddo

    do  j=1,ne
       yt(j)=y(j) + (-five*a(j) + c_27*b(j) - c_24*c(j) + six*d(j))/eight
    enddo
    tt=tI+half*h
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       e(j)=h*f(j)
    enddo

    do  j=1,ne
       yt(j)=y(j) + (c_221*a(j) - c_981*b(j) + c_867*c(j)- c_102*d(j) + e(j))/nine
    enddo
    tt = tI+two*h/three
    call feval_cav(tt,yt,f,gr)
    do   j=1,ne
       g(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j) = y(j)+(-c_183*a(j)+c_678*b(j)-c_472*c(j)-c_66*d(j)+c_80*e(j) + three*g(j))/c_48
    enddo
    tt = tI + five*h/six
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       o(j)=h*f(j)
    enddo
    do  j=1,ne
       yt(j) = y(j)+(c_716*a(j)-c_2079*b(j)+c_1002*c(j)+c_834*d(j)-c_454*e(j)-nine*g(j)+c_72*o(j))/c_82
    enddo

    tt = tI + h
    call feval_cav(tt,yt,f,gr)
    do  j=1,ne
       p(j)=h*f(j)
    enddo

    do  j=1,ne
       y(j) = y(j)+(c_41*a(j)+c_216*c(j)+c_27*d(j)+c_272*e(j)+c_27*g(j)+c_216*o(j)+c_41*p(j))/c_840
    enddo
    tI=ti+h
    call kill(tt)
    call kill(yt,ne)
    call kill(f,ne)
    call kill(a,ne)
    call kill(b,ne)
    call kill(c,ne)
    call kill(d,ne)
    call kill(e,ne)
    call kill(g,ne)
    call kill(o,ne)
    call kill(p,ne)

    return
  end  subroutine rk6_cavp


END MODULE S_DEF_KIND
